// Generated from pkg/grammar/SyslParser.g4 by ANTLR 4.7.

package parser // SyslParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 153, 1740,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 3, 2, 3, 2, 3, 2, 3, 2,
	7, 2, 367, 10, 2, 12, 2, 14, 2, 370, 11, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5,
	3, 376, 10, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 6, 5, 385, 10,
	5, 13, 5, 14, 5, 386, 3, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3,
	8, 7, 8, 398, 10, 8, 12, 8, 14, 8, 401, 11, 8, 3, 8, 3, 8, 3, 9, 3, 9,
	3, 9, 3, 9, 7, 9, 409, 10, 9, 12, 9, 14, 9, 412, 11, 9, 3, 9, 3, 9, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 421, 10, 10, 3, 11, 3, 11, 5, 11,
	425, 10, 11, 3, 12, 3, 12, 3, 12, 3, 12, 7, 12, 431, 10, 12, 12, 12, 14,
	12, 434, 11, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14, 5, 14,
	443, 10, 14, 3, 15, 3, 15, 5, 15, 447, 10, 15, 3, 16, 3, 16, 3, 16, 5,
	16, 452, 10, 16, 3, 17, 3, 17, 5, 17, 456, 10, 17, 3, 18, 3, 18, 3, 18,
	5, 18, 461, 10, 18, 3, 19, 3, 19, 5, 19, 465, 10, 19, 3, 20, 3, 20, 3,
	20, 6, 20, 470, 10, 20, 13, 20, 14, 20, 471, 3, 20, 3, 20, 3, 21, 3, 21,
	3, 21, 5, 21, 479, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 23, 3,
	23, 6, 23, 488, 10, 23, 13, 23, 14, 23, 489, 3, 23, 3, 23, 3, 24, 3, 24,
	3, 24, 3, 24, 5, 24, 498, 10, 24, 5, 24, 500, 10, 24, 3, 24, 5, 24, 503,
	10, 24, 3, 24, 5, 24, 506, 10, 24, 3, 24, 3, 24, 5, 24, 510, 10, 24, 3,
	25, 3, 25, 3, 25, 3, 25, 5, 25, 516, 10, 25, 3, 25, 3, 25, 3, 26, 3, 26,
	6, 26, 522, 10, 26, 13, 26, 14, 26, 523, 3, 26, 3, 26, 3, 27, 3, 27, 5,
	27, 530, 10, 27, 3, 27, 3, 27, 3, 27, 5, 27, 535, 10, 27, 3, 27, 5, 27,
	538, 10, 27, 5, 27, 540, 10, 27, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 6, 29, 550, 10, 29, 13, 29, 14, 29, 551, 3, 29, 3, 29,
	3, 30, 5, 30, 557, 10, 30, 3, 30, 3, 30, 3, 30, 5, 30, 562, 10, 30, 3,
	31, 7, 31, 565, 10, 31, 12, 31, 14, 31, 568, 11, 31, 3, 31, 3, 31, 3, 31,
	3, 31, 3, 32, 7, 32, 575, 10, 32, 12, 32, 14, 32, 578, 11, 32, 3, 32, 3,
	32, 3, 32, 5, 32, 583, 10, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32,
	3, 32, 6, 32, 592, 10, 32, 13, 32, 14, 32, 593, 3, 32, 5, 32, 597, 10,
	32, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 7, 35, 606, 10, 35,
	12, 35, 14, 35, 609, 11, 35, 3, 36, 3, 36, 5, 36, 613, 10, 36, 3, 36, 5,
	36, 616, 10, 36, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38,
	625, 10, 38, 6, 38, 627, 10, 38, 13, 38, 14, 38, 628, 3, 38, 3, 38, 3,
	39, 3, 39, 3, 39, 5, 39, 636, 10, 39, 3, 40, 7, 40, 639, 10, 40, 12, 40,
	14, 40, 642, 11, 40, 3, 40, 3, 40, 3, 40, 3, 40, 6, 40, 648, 10, 40, 13,
	40, 14, 40, 649, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42,
	3, 42, 3, 42, 3, 42, 5, 42, 663, 10, 42, 3, 42, 5, 42, 666, 10, 42, 3,
	43, 3, 43, 3, 43, 3, 43, 7, 43, 672, 10, 43, 12, 43, 14, 43, 675, 11, 43,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 7, 44, 686,
	10, 44, 12, 44, 14, 44, 689, 11, 44, 5, 44, 691, 10, 44, 3, 44, 5, 44,
	694, 10, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 702, 10,
	45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 5, 47, 711, 10, 47,
	3, 48, 3, 48, 6, 48, 715, 10, 48, 13, 48, 14, 48, 716, 5, 48, 719, 10,
	48, 3, 49, 3, 49, 3, 49, 7, 49, 724, 10, 49, 12, 49, 14, 49, 727, 11, 49,
	3, 50, 3, 50, 3, 50, 3, 51, 3, 51, 3, 52, 3, 52, 3, 53, 3, 53, 6, 53, 738,
	10, 53, 13, 53, 14, 53, 739, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53, 746, 10,
	53, 5, 53, 748, 10, 53, 3, 54, 3, 54, 3, 54, 3, 54, 7, 54, 754, 10, 54,
	12, 54, 14, 54, 757, 11, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55,
	5, 55, 765, 10, 55, 3, 55, 3, 55, 5, 55, 769, 10, 55, 3, 56, 3, 56, 3,
	56, 3, 56, 3, 56, 7, 56, 776, 10, 56, 12, 56, 14, 56, 779, 11, 56, 3, 56,
	3, 56, 3, 57, 3, 57, 5, 57, 785, 10, 57, 3, 57, 3, 57, 3, 57, 7, 57, 790,
	10, 57, 12, 57, 14, 57, 793, 11, 57, 3, 57, 3, 57, 3, 58, 3, 58, 7, 58,
	799, 10, 58, 12, 58, 14, 58, 802, 11, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3,
	59, 7, 59, 809, 10, 59, 12, 59, 14, 59, 812, 11, 59, 3, 59, 3, 59, 3, 60,
	3, 60, 3, 61, 3, 61, 3, 61, 3, 61, 6, 61, 822, 10, 61, 13, 61, 14, 61,
	823, 3, 61, 3, 61, 3, 62, 6, 62, 829, 10, 62, 13, 62, 14, 62, 830, 3, 63,
	5, 63, 834, 10, 63, 3, 63, 3, 63, 3, 63, 6, 63, 839, 10, 63, 13, 63, 14,
	63, 840, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64, 3, 64, 6, 64, 849, 10, 64,
	13, 64, 14, 64, 850, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5,
	65, 860, 10, 65, 3, 65, 5, 65, 863, 10, 65, 3, 66, 3, 66, 3, 66, 3, 67,
	3, 67, 5, 67, 870, 10, 67, 3, 68, 3, 68, 3, 68, 7, 68, 875, 10, 68, 12,
	68, 14, 68, 878, 11, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 893, 10, 70, 3, 70, 5,
	70, 896, 10, 70, 3, 71, 3, 71, 5, 71, 900, 10, 71, 3, 71, 5, 71, 903, 10,
	71, 3, 71, 5, 71, 906, 10, 71, 3, 71, 3, 71, 3, 71, 6, 71, 911, 10, 71,
	13, 71, 14, 71, 912, 3, 71, 3, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 5,
	73, 922, 10, 73, 3, 73, 5, 73, 925, 10, 73, 3, 73, 5, 73, 928, 10, 73,
	3, 73, 3, 73, 3, 73, 3, 73, 6, 73, 934, 10, 73, 13, 73, 14, 73, 935, 3,
	73, 3, 73, 5, 73, 940, 10, 73, 5, 73, 942, 10, 73, 3, 74, 3, 74, 5, 74,
	946, 10, 74, 3, 74, 3, 74, 3, 74, 3, 74, 6, 74, 952, 10, 74, 13, 74, 14,
	74, 953, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75, 962, 10, 75,
	3, 76, 3, 76, 3, 76, 3, 76, 7, 76, 968, 10, 76, 12, 76, 14, 76, 971, 11,
	76, 3, 77, 3, 77, 3, 77, 3, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78,
	982, 10, 78, 3, 79, 3, 79, 6, 79, 986, 10, 79, 13, 79, 14, 79, 987, 3,
	79, 5, 79, 991, 10, 79, 3, 80, 3, 80, 3, 80, 3, 81, 3, 81, 3, 82, 3, 82,
	3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 85, 3, 85, 3,
	85, 3, 85, 5, 85, 1012, 10, 85, 3, 85, 3, 85, 3, 86, 3, 86, 3, 86, 3, 86,
	3, 86, 6, 86, 1021, 10, 86, 13, 86, 14, 86, 1022, 3, 86, 3, 86, 5, 86,
	1027, 10, 86, 3, 87, 3, 87, 3, 87, 5, 87, 1032, 10, 87, 3, 87, 5, 87, 1035,
	10, 87, 3, 87, 3, 87, 3, 87, 3, 87, 6, 87, 1041, 10, 87, 13, 87, 14, 87,
	1042, 3, 87, 3, 87, 5, 87, 1047, 10, 87, 3, 88, 3, 88, 3, 88, 3, 88, 5,
	88, 1053, 10, 88, 3, 88, 3, 88, 3, 88, 3, 88, 6, 88, 1059, 10, 88, 13,
	88, 14, 88, 1060, 3, 88, 3, 88, 5, 88, 1065, 10, 88, 3, 89, 3, 89, 5, 89,
	1069, 10, 89, 3, 90, 3, 90, 3, 91, 3, 91, 5, 91, 1075, 10, 91, 3, 91, 3,
	91, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 7, 93, 1084, 10, 93, 12, 93, 14,
	93, 1087, 11, 93, 3, 94, 3, 94, 3, 94, 5, 94, 1092, 10, 94, 3, 94, 3, 94,
	3, 95, 3, 95, 5, 95, 1098, 10, 95, 3, 96, 3, 96, 3, 96, 7, 96, 1103, 10,
	96, 12, 96, 14, 96, 1106, 11, 96, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 5,
	97, 1113, 10, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 98, 3, 98,
	3, 98, 5, 98, 1124, 10, 98, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3,
	100, 3, 100, 5, 100, 1134, 10, 100, 3, 101, 3, 101, 3, 101, 3, 101, 3,
	101, 5, 101, 1141, 10, 101, 3, 101, 3, 101, 3, 101, 3, 102, 3, 102, 3,
	103, 3, 103, 3, 103, 5, 103, 1151, 10, 103, 3, 103, 3, 103, 3, 103, 3,
	104, 3, 104, 3, 104, 3, 104, 3, 104, 3, 105, 3, 105, 3, 106, 3, 106, 3,
	107, 3, 107, 3, 108, 5, 108, 1168, 10, 108, 3, 108, 3, 108, 3, 109, 5,
	109, 1173, 10, 109, 3, 109, 3, 109, 5, 109, 1177, 10, 109, 3, 109, 3, 109,
	3, 109, 5, 109, 1182, 10, 109, 3, 110, 3, 110, 3, 110, 3, 110, 5, 110,
	1188, 10, 110, 3, 111, 3, 111, 3, 111, 3, 111, 7, 111, 1194, 10, 111, 12,
	111, 14, 111, 1197, 11, 111, 3, 111, 3, 111, 3, 112, 5, 112, 1202, 10,
	112, 3, 112, 3, 112, 5, 112, 1206, 10, 112, 3, 112, 3, 112, 3, 112, 3,
	113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3,
	113, 3, 113, 5, 113, 1222, 10, 113, 3, 114, 3, 114, 3, 115, 3, 115, 3,
	115, 7, 115, 1229, 10, 115, 12, 115, 14, 115, 1232, 11, 115, 3, 116, 3,
	116, 3, 116, 3, 116, 3, 117, 3, 117, 3, 118, 3, 118, 3, 118, 3, 118, 3,
	118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 5, 118, 1251, 10,
	118, 3, 119, 3, 119, 3, 119, 3, 119, 5, 119, 1257, 10, 119, 3, 120, 3,
	120, 3, 121, 3, 121, 3, 121, 3, 121, 3, 122, 3, 122, 3, 122, 3, 122, 3,
	123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 5, 123, 1277,
	10, 123, 3, 124, 3, 124, 7, 124, 1281, 10, 124, 12, 124, 14, 124, 1284,
	11, 124, 3, 125, 3, 125, 3, 125, 3, 126, 3, 126, 5, 126, 1291, 10, 126,
	3, 127, 5, 127, 1294, 10, 127, 3, 127, 3, 127, 3, 128, 3, 128, 3, 128,
	3, 129, 3, 129, 7, 129, 1303, 10, 129, 12, 129, 14, 129, 1306, 11, 129,
	3, 130, 3, 130, 3, 130, 3, 131, 3, 131, 7, 131, 1313, 10, 131, 12, 131,
	14, 131, 1316, 11, 131, 3, 132, 3, 132, 3, 133, 3, 133, 3, 133, 3, 133,
	7, 133, 1324, 10, 133, 12, 133, 14, 133, 1327, 11, 133, 3, 134, 3, 134,
	3, 134, 7, 134, 1332, 10, 134, 12, 134, 14, 134, 1335, 11, 134, 3, 135,
	3, 135, 3, 135, 7, 135, 1340, 10, 135, 12, 135, 14, 135, 1343, 11, 135,
	3, 136, 3, 136, 3, 136, 7, 136, 1348, 10, 136, 12, 136, 14, 136, 1351,
	11, 136, 3, 137, 3, 137, 3, 137, 7, 137, 1356, 10, 137, 12, 137, 14, 137,
	1359, 11, 137, 3, 138, 3, 138, 3, 138, 7, 138, 1364, 10, 138, 12, 138,
	14, 138, 1367, 11, 138, 3, 139, 3, 139, 3, 139, 7, 139, 1372, 10, 139,
	12, 139, 14, 139, 1375, 11, 139, 3, 140, 3, 140, 3, 140, 7, 140, 1380,
	10, 140, 12, 140, 14, 140, 1383, 11, 140, 3, 141, 3, 141, 5, 141, 1387,
	10, 141, 3, 141, 3, 141, 3, 141, 3, 141, 3, 141, 3, 142, 3, 142, 3, 142,
	3, 143, 3, 143, 3, 144, 3, 144, 3, 144, 7, 144, 1402, 10, 144, 12, 144,
	14, 144, 1405, 11, 144, 3, 145, 3, 145, 3, 145, 3, 145, 3, 145, 5, 145,
	1412, 10, 145, 3, 146, 3, 146, 3, 146, 3, 146, 5, 146, 1418, 10, 146, 3,
	147, 3, 147, 3, 147, 3, 148, 5, 148, 1424, 10, 148, 3, 148, 3, 148, 3,
	148, 3, 148, 6, 148, 1430, 10, 148, 13, 148, 14, 148, 1431, 3, 148, 5,
	148, 1435, 10, 148, 3, 148, 3, 148, 3, 149, 3, 149, 3, 149, 3, 149, 3,
	149, 5, 149, 1444, 10, 149, 3, 150, 3, 150, 3, 150, 3, 150, 5, 150, 1450,
	10, 150, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 5, 151,
	1459, 10, 151, 3, 152, 3, 152, 3, 152, 3, 152, 3, 153, 3, 153, 3, 153,
	3, 153, 3, 153, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154, 3, 155, 3, 155,
	3, 156, 3, 156, 3, 157, 3, 157, 3, 157, 7, 157, 1482, 10, 157, 12, 157,
	14, 157, 1485, 11, 157, 3, 157, 5, 157, 1488, 10, 157, 3, 158, 3, 158,
	5, 158, 1492, 10, 158, 3, 158, 7, 158, 1495, 10, 158, 12, 158, 14, 158,
	1498, 11, 158, 3, 158, 3, 158, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159,
	3, 159, 3, 159, 3, 159, 3, 159, 5, 159, 1511, 10, 159, 3, 159, 3, 159,
	5, 159, 1515, 10, 159, 3, 160, 3, 160, 3, 160, 3, 160, 3, 160, 3, 161,
	3, 161, 3, 161, 5, 161, 1525, 10, 161, 3, 162, 3, 162, 3, 162, 5, 162,
	1530, 10, 162, 3, 163, 3, 163, 3, 164, 3, 164, 3, 165, 3, 165, 3, 166,
	5, 166, 1539, 10, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 5, 166,
	1546, 10, 166, 3, 166, 3, 166, 5, 166, 1550, 10, 166, 3, 166, 3, 166, 3,
	166, 3, 166, 3, 166, 6, 166, 1557, 10, 166, 13, 166, 14, 166, 1558, 3,
	166, 3, 166, 3, 166, 3, 166, 3, 167, 3, 167, 3, 167, 3, 167, 3, 168, 3,
	168, 3, 168, 3, 168, 3, 169, 3, 169, 3, 169, 7, 169, 1576, 10, 169, 12,
	169, 14, 169, 1579, 11, 169, 3, 170, 3, 170, 3, 171, 3, 171, 3, 171, 3,
	171, 3, 171, 3, 171, 3, 171, 5, 171, 1590, 10, 171, 3, 171, 5, 171, 1593,
	10, 171, 3, 171, 3, 171, 3, 171, 3, 171, 3, 171, 5, 171, 1600, 10, 171,
	3, 172, 3, 172, 3, 172, 5, 172, 1605, 10, 172, 3, 172, 3, 172, 7, 172,
	1609, 10, 172, 12, 172, 14, 172, 1612, 11, 172, 3, 172, 3, 172, 5, 172,
	1616, 10, 172, 3, 172, 3, 172, 7, 172, 1620, 10, 172, 12, 172, 14, 172,
	1623, 11, 172, 3, 172, 3, 172, 5, 172, 1627, 10, 172, 3, 172, 3, 172, 5,
	172, 1631, 10, 172, 3, 173, 3, 173, 3, 173, 3, 173, 3, 174, 3, 174, 3,
	174, 6, 174, 1640, 10, 174, 13, 174, 14, 174, 1641, 3, 174, 3, 174, 3,
	175, 3, 175, 3, 175, 5, 175, 1649, 10, 175, 3, 175, 3, 175, 3, 175, 5,
	175, 1654, 10, 175, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3,
	176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3,
	176, 3, 176, 6, 176, 1673, 10, 176, 13, 176, 14, 176, 1674, 3, 176, 3,
	176, 5, 176, 1679, 10, 176, 3, 177, 7, 177, 1682, 10, 177, 12, 177, 14,
	177, 1685, 11, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 178, 3, 178, 3,
	178, 3, 179, 3, 179, 3, 179, 3, 179, 3, 179, 3, 179, 7, 179, 1700, 10,
	179, 12, 179, 14, 179, 1703, 11, 179, 5, 179, 1705, 10, 179, 3, 179, 7,
	179, 1708, 10, 179, 12, 179, 14, 179, 1711, 11, 179, 3, 179, 5, 179, 1714,
	10, 179, 3, 179, 7, 179, 1717, 10, 179, 12, 179, 14, 179, 1720, 11, 179,
	3, 179, 5, 179, 1723, 10, 179, 3, 180, 6, 180, 1726, 10, 180, 13, 180,
	14, 180, 1727, 3, 181, 5, 181, 1731, 10, 181, 3, 181, 6, 181, 1734, 10,
	181, 13, 181, 14, 181, 1735, 3, 181, 3, 181, 3, 181, 2, 2, 182, 2, 4, 6,
	8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
	174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
	204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
	234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
	264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
	294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322,
	324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352,
	354, 356, 358, 360, 2, 21, 4, 2, 65, 66, 145, 145, 4, 2, 46, 46, 146, 146,
	3, 2, 8, 9, 4, 2, 8, 9, 12, 12, 4, 2, 18, 20, 22, 24, 4, 2, 62, 62, 65,
	66, 4, 2, 120, 122, 140, 143, 4, 2, 90, 90, 146, 146, 5, 2, 5, 5, 137,
	137, 145, 145, 3, 2, 126, 127, 4, 2, 133, 133, 135, 135, 3, 2, 124, 125,
	4, 2, 78, 78, 145, 146, 5, 2, 99, 99, 102, 102, 104, 105, 4, 2, 100, 101,
	113, 113, 4, 2, 99, 99, 102, 102, 4, 2, 81, 82, 85, 86, 4, 2, 109, 109,
	111, 111, 4, 2, 149, 149, 153, 153, 2, 1818, 2, 362, 3, 2, 2, 2, 4, 371,
	3, 2, 2, 2, 6, 379, 3, 2, 2, 2, 8, 381, 3, 2, 2, 2, 10, 388, 3, 2, 2, 2,
	12, 391, 3, 2, 2, 2, 14, 393, 3, 2, 2, 2, 16, 404, 3, 2, 2, 2, 18, 415,
	3, 2, 2, 2, 20, 424, 3, 2, 2, 2, 22, 426, 3, 2, 2, 2, 24, 437, 3, 2, 2,
	2, 26, 442, 3, 2, 2, 2, 28, 446, 3, 2, 2, 2, 30, 448, 3, 2, 2, 2, 32, 455,
	3, 2, 2, 2, 34, 457, 3, 2, 2, 2, 36, 464, 3, 2, 2, 2, 38, 466, 3, 2, 2,
	2, 40, 478, 3, 2, 2, 2, 42, 480, 3, 2, 2, 2, 44, 485, 3, 2, 2, 2, 46, 499,
	3, 2, 2, 2, 48, 511, 3, 2, 2, 2, 50, 519, 3, 2, 2, 2, 52, 527, 3, 2, 2,
	2, 54, 541, 3, 2, 2, 2, 56, 543, 3, 2, 2, 2, 58, 556, 3, 2, 2, 2, 60, 566,
	3, 2, 2, 2, 62, 576, 3, 2, 2, 2, 64, 598, 3, 2, 2, 2, 66, 600, 3, 2, 2,
	2, 68, 603, 3, 2, 2, 2, 70, 610, 3, 2, 2, 2, 72, 617, 3, 2, 2, 2, 74, 620,
	3, 2, 2, 2, 76, 632, 3, 2, 2, 2, 78, 640, 3, 2, 2, 2, 80, 653, 3, 2, 2,
	2, 82, 657, 3, 2, 2, 2, 84, 667, 3, 2, 2, 2, 86, 693, 3, 2, 2, 2, 88, 695,
	3, 2, 2, 2, 90, 705, 3, 2, 2, 2, 92, 707, 3, 2, 2, 2, 94, 718, 3, 2, 2,
	2, 96, 720, 3, 2, 2, 2, 98, 728, 3, 2, 2, 2, 100, 731, 3, 2, 2, 2, 102,
	733, 3, 2, 2, 2, 104, 747, 3, 2, 2, 2, 106, 749, 3, 2, 2, 2, 108, 764,
	3, 2, 2, 2, 110, 770, 3, 2, 2, 2, 112, 782, 3, 2, 2, 2, 114, 796, 3, 2,
	2, 2, 116, 803, 3, 2, 2, 2, 118, 815, 3, 2, 2, 2, 120, 817, 3, 2, 2, 2,
	122, 828, 3, 2, 2, 2, 124, 833, 3, 2, 2, 2, 126, 844, 3, 2, 2, 2, 128,
	862, 3, 2, 2, 2, 130, 864, 3, 2, 2, 2, 132, 869, 3, 2, 2, 2, 134, 871,
	3, 2, 2, 2, 136, 879, 3, 2, 2, 2, 138, 892, 3, 2, 2, 2, 140, 897, 3, 2,
	2, 2, 142, 916, 3, 2, 2, 2, 144, 941, 3, 2, 2, 2, 146, 943, 3, 2, 2, 2,
	148, 957, 3, 2, 2, 2, 150, 963, 3, 2, 2, 2, 152, 972, 3, 2, 2, 2, 154,
	981, 3, 2, 2, 2, 156, 985, 3, 2, 2, 2, 158, 992, 3, 2, 2, 2, 160, 995,
	3, 2, 2, 2, 162, 997, 3, 2, 2, 2, 164, 999, 3, 2, 2, 2, 166, 1005, 3, 2,
	2, 2, 168, 1011, 3, 2, 2, 2, 170, 1015, 3, 2, 2, 2, 172, 1028, 3, 2, 2,
	2, 174, 1048, 3, 2, 2, 2, 176, 1068, 3, 2, 2, 2, 178, 1070, 3, 2, 2, 2,
	180, 1072, 3, 2, 2, 2, 182, 1078, 3, 2, 2, 2, 184, 1080, 3, 2, 2, 2, 186,
	1088, 3, 2, 2, 2, 188, 1095, 3, 2, 2, 2, 190, 1099, 3, 2, 2, 2, 192, 1107,
	3, 2, 2, 2, 194, 1120, 3, 2, 2, 2, 196, 1128, 3, 2, 2, 2, 198, 1133, 3,
	2, 2, 2, 200, 1135, 3, 2, 2, 2, 202, 1145, 3, 2, 2, 2, 204, 1147, 3, 2,
	2, 2, 206, 1155, 3, 2, 2, 2, 208, 1160, 3, 2, 2, 2, 210, 1162, 3, 2, 2,
	2, 212, 1164, 3, 2, 2, 2, 214, 1167, 3, 2, 2, 2, 216, 1172, 3, 2, 2, 2,
	218, 1187, 3, 2, 2, 2, 220, 1189, 3, 2, 2, 2, 222, 1201, 3, 2, 2, 2, 224,
	1221, 3, 2, 2, 2, 226, 1223, 3, 2, 2, 2, 228, 1225, 3, 2, 2, 2, 230, 1233,
	3, 2, 2, 2, 232, 1237, 3, 2, 2, 2, 234, 1239, 3, 2, 2, 2, 236, 1256, 3,
	2, 2, 2, 238, 1258, 3, 2, 2, 2, 240, 1260, 3, 2, 2, 2, 242, 1264, 3, 2,
	2, 2, 244, 1276, 3, 2, 2, 2, 246, 1278, 3, 2, 2, 2, 248, 1285, 3, 2, 2,
	2, 250, 1288, 3, 2, 2, 2, 252, 1293, 3, 2, 2, 2, 254, 1297, 3, 2, 2, 2,
	256, 1300, 3, 2, 2, 2, 258, 1307, 3, 2, 2, 2, 260, 1310, 3, 2, 2, 2, 262,
	1317, 3, 2, 2, 2, 264, 1319, 3, 2, 2, 2, 266, 1328, 3, 2, 2, 2, 268, 1336,
	3, 2, 2, 2, 270, 1344, 3, 2, 2, 2, 272, 1352, 3, 2, 2, 2, 274, 1360, 3,
	2, 2, 2, 276, 1368, 3, 2, 2, 2, 278, 1376, 3, 2, 2, 2, 280, 1384, 3, 2,
	2, 2, 282, 1393, 3, 2, 2, 2, 284, 1396, 3, 2, 2, 2, 286, 1398, 3, 2, 2,
	2, 288, 1406, 3, 2, 2, 2, 290, 1413, 3, 2, 2, 2, 292, 1419, 3, 2, 2, 2,
	294, 1423, 3, 2, 2, 2, 296, 1438, 3, 2, 2, 2, 298, 1449, 3, 2, 2, 2, 300,
	1451, 3, 2, 2, 2, 302, 1460, 3, 2, 2, 2, 304, 1464, 3, 2, 2, 2, 306, 1469,
	3, 2, 2, 2, 308, 1474, 3, 2, 2, 2, 310, 1476, 3, 2, 2, 2, 312, 1487, 3,
	2, 2, 2, 314, 1489, 3, 2, 2, 2, 316, 1510, 3, 2, 2, 2, 318, 1516, 3, 2,
	2, 2, 320, 1524, 3, 2, 2, 2, 322, 1529, 3, 2, 2, 2, 324, 1531, 3, 2, 2,
	2, 326, 1533, 3, 2, 2, 2, 328, 1535, 3, 2, 2, 2, 330, 1538, 3, 2, 2, 2,
	332, 1564, 3, 2, 2, 2, 334, 1568, 3, 2, 2, 2, 336, 1572, 3, 2, 2, 2, 338,
	1580, 3, 2, 2, 2, 340, 1582, 3, 2, 2, 2, 342, 1601, 3, 2, 2, 2, 344, 1632,
	3, 2, 2, 2, 346, 1636, 3, 2, 2, 2, 348, 1645, 3, 2, 2, 2, 350, 1655, 3,
	2, 2, 2, 352, 1683, 3, 2, 2, 2, 354, 1690, 3, 2, 2, 2, 356, 1693, 3, 2,
	2, 2, 358, 1725, 3, 2, 2, 2, 360, 1730, 3, 2, 2, 2, 362, 363, 7, 40, 2,
	2, 363, 368, 7, 66, 2, 2, 364, 365, 7, 38, 2, 2, 365, 367, 7, 66, 2, 2,
	366, 364, 3, 2, 2, 2, 367, 370, 3, 2, 2, 2, 368, 366, 3, 2, 2, 2, 368,
	369, 3, 2, 2, 2, 369, 3, 3, 2, 2, 2, 370, 368, 3, 2, 2, 2, 371, 372, 7,
	54, 2, 2, 372, 375, 7, 61, 2, 2, 373, 374, 7, 46, 2, 2, 374, 376, 7, 61,
	2, 2, 375, 373, 3, 2, 2, 2, 375, 376, 3, 2, 2, 2, 376, 377, 3, 2, 2, 2,
	377, 378, 7, 55, 2, 2, 378, 5, 3, 2, 2, 2, 379, 380, 9, 2, 2, 2, 380, 7,
	3, 2, 2, 2, 381, 384, 5, 68, 35, 2, 382, 383, 9, 3, 2, 2, 383, 385, 5,
	6, 4, 2, 384, 382, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 384, 3, 2, 2,
	2, 386, 387, 3, 2, 2, 2, 387, 9, 3, 2, 2, 2, 388, 389, 7, 58, 2, 2, 389,
	390, 7, 73, 2, 2, 390, 11, 3, 2, 2, 2, 391, 392, 7, 62, 2, 2, 392, 13,
	3, 2, 2, 2, 393, 394, 7, 50, 2, 2, 394, 399, 5, 12, 7, 2, 395, 396, 7,
	41, 2, 2, 396, 398, 5, 12, 7, 2, 397, 395, 3, 2, 2, 2, 398, 401, 3, 2,
	2, 2, 399, 397, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2, 400, 402, 3, 2, 2, 2,
	401, 399, 3, 2, 2, 2, 402, 403, 7, 51, 2, 2, 403, 15, 3, 2, 2, 2, 404,
	405, 7, 50, 2, 2, 405, 410, 5, 14, 8, 2, 406, 407, 7, 41, 2, 2, 407, 409,
	5, 14, 8, 2, 408, 406, 3, 2, 2, 2, 409, 412, 3, 2, 2, 2, 410, 408, 3, 2,
	2, 2, 410, 411, 3, 2, 2, 2, 411, 413, 3, 2, 2, 2, 412, 410, 3, 2, 2, 2,
	413, 414, 7, 51, 2, 2, 414, 17, 3, 2, 2, 2, 415, 416, 7, 66, 2, 2, 416,
	420, 7, 42, 2, 2, 417, 421, 5, 12, 7, 2, 418, 421, 5, 14, 8, 2, 419, 421,
	5, 16, 9, 2, 420, 417, 3, 2, 2, 2, 420, 418, 3, 2, 2, 2, 420, 419, 3, 2,
	2, 2, 421, 19, 3, 2, 2, 2, 422, 425, 5, 18, 10, 2, 423, 425, 5, 2, 2, 2,
	424, 422, 3, 2, 2, 2, 424, 423, 3, 2, 2, 2, 425, 21, 3, 2, 2, 2, 426, 427,
	7, 50, 2, 2, 427, 432, 5, 20, 11, 2, 428, 429, 7, 41, 2, 2, 429, 431, 5,
	20, 11, 2, 430, 428, 3, 2, 2, 2, 431, 434, 3, 2, 2, 2, 432, 430, 3, 2,
	2, 2, 432, 433, 3, 2, 2, 2, 433, 435, 3, 2, 2, 2, 434, 432, 3, 2, 2, 2,
	435, 436, 7, 51, 2, 2, 436, 23, 3, 2, 2, 2, 437, 438, 5, 6, 4, 2, 438,
	25, 3, 2, 2, 2, 439, 443, 5, 24, 13, 2, 440, 443, 5, 8, 5, 2, 441, 443,
	7, 5, 2, 2, 442, 439, 3, 2, 2, 2, 442, 440, 3, 2, 2, 2, 442, 441, 3, 2,
	2, 2, 443, 27, 3, 2, 2, 2, 444, 447, 7, 28, 2, 2, 445, 447, 7, 125, 2,
	2, 446, 444, 3, 2, 2, 2, 446, 445, 3, 2, 2, 2, 447, 29, 3, 2, 2, 2, 448,
	449, 5, 28, 15, 2, 449, 451, 5, 26, 14, 2, 450, 452, 5, 4, 3, 2, 451, 450,
	3, 2, 2, 2, 451, 452, 3, 2, 2, 2, 452, 31, 3, 2, 2, 2, 453, 456, 7, 27,
	2, 2, 454, 456, 7, 124, 2, 2, 455, 453, 3, 2, 2, 2, 455, 454, 3, 2, 2,
	2, 456, 33, 3, 2, 2, 2, 457, 458, 5, 32, 17, 2, 458, 460, 5, 26, 14, 2,
	459, 461, 5, 4, 3, 2, 460, 459, 3, 2, 2, 2, 460, 461, 3, 2, 2, 2, 461,
	35, 3, 2, 2, 2, 462, 465, 5, 30, 16, 2, 463, 465, 5, 34, 18, 2, 464, 462,
	3, 2, 2, 2, 464, 463, 3, 2, 2, 2, 465, 37, 3, 2, 2, 2, 466, 467, 7, 45,
	2, 2, 467, 469, 7, 3, 2, 2, 468, 470, 5, 10, 6, 2, 469, 468, 3, 2, 2, 2,
	470, 471, 3, 2, 2, 2, 471, 469, 3, 2, 2, 2, 471, 472, 3, 2, 2, 2, 472,
	473, 3, 2, 2, 2, 473, 474, 7, 4, 2, 2, 474, 39, 3, 2, 2, 2, 475, 479, 7,
	62, 2, 2, 476, 479, 5, 14, 8, 2, 477, 479, 5, 38, 20, 2, 478, 475, 3, 2,
	2, 2, 478, 476, 3, 2, 2, 2, 478, 477, 3, 2, 2, 2, 479, 41, 3, 2, 2, 2,
	480, 481, 7, 48, 2, 2, 481, 482, 7, 75, 2, 2, 482, 483, 7, 42, 2, 2, 483,
	484, 5, 40, 21, 2, 484, 43, 3, 2, 2, 2, 485, 487, 7, 3, 2, 2, 486, 488,
	5, 42, 22, 2, 487, 486, 3, 2, 2, 2, 488, 489, 3, 2, 2, 2, 489, 487, 3,
	2, 2, 2, 489, 490, 3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491, 492, 7, 4, 2,
	2, 492, 45, 3, 2, 2, 2, 493, 500, 5, 36, 19, 2, 494, 497, 5, 26, 14, 2,
	495, 498, 5, 48, 25, 2, 496, 498, 5, 4, 3, 2, 497, 495, 3, 2, 2, 2, 497,
	496, 3, 2, 2, 2, 497, 498, 3, 2, 2, 2, 498, 500, 3, 2, 2, 2, 499, 493,
	3, 2, 2, 2, 499, 494, 3, 2, 2, 2, 500, 502, 3, 2, 2, 2, 501, 503, 7, 47,
	2, 2, 502, 501, 3, 2, 2, 2, 502, 503, 3, 2, 2, 2, 503, 505, 3, 2, 2, 2,
	504, 506, 5, 22, 12, 2, 505, 504, 3, 2, 2, 2, 505, 506, 3, 2, 2, 2, 506,
	509, 3, 2, 2, 2, 507, 508, 7, 45, 2, 2, 508, 510, 5, 44, 23, 2, 509, 507,
	3, 2, 2, 2, 509, 510, 3, 2, 2, 2, 510, 47, 3, 2, 2, 2, 511, 512, 7, 54,
	2, 2, 512, 513, 7, 61, 2, 2, 513, 515, 7, 26, 2, 2, 514, 516, 7, 61, 2,
	2, 515, 514, 3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516, 517, 3, 2, 2, 2, 517,
	518, 7, 55, 2, 2, 518, 49, 3, 2, 2, 2, 519, 521, 7, 3, 2, 2, 520, 522,
	5, 52, 27, 2, 521, 520, 3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523, 521, 3,
	2, 2, 2, 523, 524, 3, 2, 2, 2, 524, 525, 3, 2, 2, 2, 525, 526, 7, 4, 2,
	2, 526, 51, 3, 2, 2, 2, 527, 539, 5, 6, 4, 2, 528, 530, 5, 48, 25, 2, 529,
	528, 3, 2, 2, 2, 529, 530, 3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531, 534,
	7, 34, 2, 2, 532, 535, 5, 46, 24, 2, 533, 535, 5, 50, 26, 2, 534, 532,
	3, 2, 2, 2, 534, 533, 3, 2, 2, 2, 535, 537, 3, 2, 2, 2, 536, 538, 7, 62,
	2, 2, 537, 536, 3, 2, 2, 2, 537, 538, 3, 2, 2, 2, 538, 540, 3, 2, 2, 2,
	539, 529, 3, 2, 2, 2, 539, 540, 3, 2, 2, 2, 540, 53, 3, 2, 2, 2, 541, 542,
	5, 60, 31, 2, 542, 55, 3, 2, 2, 2, 543, 549, 7, 3, 2, 2, 544, 550, 7, 64,
	2, 2, 545, 550, 5, 52, 27, 2, 546, 550, 5, 42, 22, 2, 547, 550, 5, 54,
	28, 2, 548, 550, 7, 25, 2, 2, 549, 544, 3, 2, 2, 2, 549, 545, 3, 2, 2,
	2, 549, 546, 3, 2, 2, 2, 549, 547, 3, 2, 2, 2, 549, 548, 3, 2, 2, 2, 550,
	551, 3, 2, 2, 2, 551, 549, 3, 2, 2, 2, 551, 552, 3, 2, 2, 2, 552, 553,
	3, 2, 2, 2, 553, 554, 7, 4, 2, 2, 554, 57, 3, 2, 2, 2, 555, 557, 5, 22,
	12, 2, 556, 555, 3, 2, 2, 2, 556, 557, 3, 2, 2, 2, 557, 558, 3, 2, 2, 2,
	558, 561, 7, 45, 2, 2, 559, 562, 7, 25, 2, 2, 560, 562, 5, 56, 29, 2, 561,
	559, 3, 2, 2, 2, 561, 560, 3, 2, 2, 2, 562, 59, 3, 2, 2, 2, 563, 565, 7,
	64, 2, 2, 564, 563, 3, 2, 2, 2, 565, 568, 3, 2, 2, 2, 566, 564, 3, 2, 2,
	2, 566, 567, 3, 2, 2, 2, 567, 569, 3, 2, 2, 2, 568, 566, 3, 2, 2, 2, 569,
	570, 9, 4, 2, 2, 570, 571, 5, 6, 4, 2, 571, 572, 5, 58, 30, 2, 572, 61,
	3, 2, 2, 2, 573, 575, 7, 64, 2, 2, 574, 573, 3, 2, 2, 2, 575, 578, 3, 2,
	2, 2, 576, 574, 3, 2, 2, 2, 576, 577, 3, 2, 2, 2, 577, 579, 3, 2, 2, 2,
	578, 576, 3, 2, 2, 2, 579, 580, 7, 12, 2, 2, 580, 582, 5, 6, 4, 2, 581,
	583, 5, 22, 12, 2, 582, 581, 3, 2, 2, 2, 582, 583, 3, 2, 2, 2, 583, 584,
	3, 2, 2, 2, 584, 596, 7, 45, 2, 2, 585, 597, 7, 25, 2, 2, 586, 591, 7,
	3, 2, 2, 587, 592, 7, 64, 2, 2, 588, 592, 5, 24, 13, 2, 589, 592, 5, 42,
	22, 2, 590, 592, 7, 25, 2, 2, 591, 587, 3, 2, 2, 2, 591, 588, 3, 2, 2,
	2, 591, 589, 3, 2, 2, 2, 591, 590, 3, 2, 2, 2, 592, 593, 3, 2, 2, 2, 593,
	591, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 595, 3, 2, 2, 2, 595, 597,
	7, 4, 2, 2, 596, 585, 3, 2, 2, 2, 596, 586, 3, 2, 2, 2, 597, 63, 3, 2,
	2, 2, 598, 599, 5, 6, 4, 2, 599, 65, 3, 2, 2, 2, 600, 601, 7, 33, 2, 2,
	601, 602, 5, 64, 33, 2, 602, 67, 3, 2, 2, 2, 603, 607, 5, 64, 33, 2, 604,
	606, 5, 66, 34, 2, 605, 604, 3, 2, 2, 2, 606, 609, 3, 2, 2, 2, 607, 605,
	3, 2, 2, 2, 607, 608, 3, 2, 2, 2, 608, 69, 3, 2, 2, 2, 609, 607, 3, 2,
	2, 2, 610, 612, 5, 68, 35, 2, 611, 613, 7, 62, 2, 2, 612, 611, 3, 2, 2,
	2, 612, 613, 3, 2, 2, 2, 613, 615, 3, 2, 2, 2, 614, 616, 5, 22, 12, 2,
	615, 614, 3, 2, 2, 2, 615, 616, 3, 2, 2, 2, 616, 71, 3, 2, 2, 2, 617, 618,
	7, 66, 2, 2, 618, 619, 7, 45, 2, 2, 619, 73, 3, 2, 2, 2, 620, 621, 7, 45,
	2, 2, 621, 626, 7, 3, 2, 2, 622, 624, 7, 66, 2, 2, 623, 625, 5, 22, 12,
	2, 624, 623, 3, 2, 2, 2, 624, 625, 3, 2, 2, 2, 625, 627, 3, 2, 2, 2, 626,
	622, 3, 2, 2, 2, 627, 628, 3, 2, 2, 2, 628, 626, 3, 2, 2, 2, 628, 629,
	3, 2, 2, 2, 629, 630, 3, 2, 2, 2, 630, 631, 7, 4, 2, 2, 631, 75, 3, 2,
	2, 2, 632, 633, 9, 5, 2, 2, 633, 635, 7, 66, 2, 2, 634, 636, 5, 74, 38,
	2, 635, 634, 3, 2, 2, 2, 635, 636, 3, 2, 2, 2, 636, 77, 3, 2, 2, 2, 637,
	639, 7, 64, 2, 2, 638, 637, 3, 2, 2, 2, 639, 642, 3, 2, 2, 2, 640, 638,
	3, 2, 2, 2, 640, 641, 3, 2, 2, 2, 641, 643, 3, 2, 2, 2, 642, 640, 3, 2,
	2, 2, 643, 644, 7, 7, 2, 2, 644, 645, 5, 72, 37, 2, 645, 647, 7, 3, 2,
	2, 646, 648, 5, 76, 39, 2, 647, 646, 3, 2, 2, 2, 648, 649, 3, 2, 2, 2,
	649, 647, 3, 2, 2, 2, 649, 650, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651,
	652, 7, 4, 2, 2, 652, 79, 3, 2, 2, 2, 653, 654, 7, 52, 2, 2, 654, 655,
	7, 66, 2, 2, 655, 656, 7, 53, 2, 2, 656, 81, 3, 2, 2, 2, 657, 658, 7, 66,
	2, 2, 658, 662, 7, 42, 2, 2, 659, 663, 7, 5, 2, 2, 660, 663, 5, 6, 4, 2,
	661, 663, 5, 80, 41, 2, 662, 659, 3, 2, 2, 2, 662, 660, 3, 2, 2, 2, 662,
	661, 3, 2, 2, 2, 663, 665, 3, 2, 2, 2, 664, 666, 7, 47, 2, 2, 665, 664,
	3, 2, 2, 2, 665, 666, 3, 2, 2, 2, 666, 83, 3, 2, 2, 2, 667, 668, 7, 47,
	2, 2, 668, 673, 5, 82, 42, 2, 669, 670, 7, 49, 2, 2, 670, 672, 5, 82, 42,
	2, 671, 669, 3, 2, 2, 2, 672, 675, 3, 2, 2, 2, 673, 671, 3, 2, 2, 2, 673,
	674, 3, 2, 2, 2, 674, 85, 3, 2, 2, 2, 675, 673, 3, 2, 2, 2, 676, 690, 5,
	6, 4, 2, 677, 678, 7, 47, 2, 2, 678, 679, 7, 66, 2, 2, 679, 680, 7, 42,
	2, 2, 680, 687, 7, 66, 2, 2, 681, 682, 7, 49, 2, 2, 682, 683, 7, 66, 2,
	2, 683, 684, 7, 42, 2, 2, 684, 686, 7, 66, 2, 2, 685, 681, 3, 2, 2, 2,
	686, 689, 3, 2, 2, 2, 687, 685, 3, 2, 2, 2, 687, 688, 3, 2, 2, 2, 688,
	691, 3, 2, 2, 2, 689, 687, 3, 2, 2, 2, 690, 677, 3, 2, 2, 2, 690, 691,
	3, 2, 2, 2, 691, 694, 3, 2, 2, 2, 692, 694, 7, 61, 2, 2, 693, 676, 3, 2,
	2, 2, 693, 692, 3, 2, 2, 2, 694, 87, 3, 2, 2, 2, 695, 696, 7, 52, 2, 2,
	696, 697, 5, 86, 44, 2, 697, 701, 7, 34, 2, 2, 698, 702, 7, 5, 2, 2, 699,
	702, 5, 6, 4, 2, 700, 702, 5, 8, 5, 2, 701, 698, 3, 2, 2, 2, 701, 699,
	3, 2, 2, 2, 701, 700, 3, 2, 2, 2, 702, 703, 3, 2, 2, 2, 703, 704, 7, 53,
	2, 2, 704, 89, 3, 2, 2, 2, 705, 706, 5, 86, 44, 2, 706, 91, 3, 2, 2, 2,
	707, 710, 7, 44, 2, 2, 708, 711, 5, 90, 46, 2, 709, 711, 5, 88, 45, 2,
	710, 708, 3, 2, 2, 2, 710, 709, 3, 2, 2, 2, 711, 93, 3, 2, 2, 2, 712, 719,
	7, 44, 2, 2, 713, 715, 5, 92, 47, 2, 714, 713, 3, 2, 2, 2, 715, 716, 3,
	2, 2, 2, 716, 714, 3, 2, 2, 2, 716, 717, 3, 2, 2, 2, 717, 719, 3, 2, 2,
	2, 718, 712, 3, 2, 2, 2, 718, 714, 3, 2, 2, 2, 719, 95, 3, 2, 2, 2, 720,
	725, 5, 6, 4, 2, 721, 722, 7, 44, 2, 2, 722, 724, 5, 6, 4, 2, 723, 721,
	3, 2, 2, 2, 724, 727, 3, 2, 2, 2, 725, 723, 3, 2, 2, 2, 725, 726, 3, 2,
	2, 2, 726, 97, 3, 2, 2, 2, 727, 725, 3, 2, 2, 2, 728, 729, 7, 16, 2, 2,
	729, 730, 7, 73, 2, 2, 730, 99, 3, 2, 2, 2, 731, 732, 5, 68, 35, 2, 732,
	101, 3, 2, 2, 2, 733, 734, 5, 6, 4, 2, 734, 103, 3, 2, 2, 2, 735, 738,
	7, 62, 2, 2, 736, 738, 5, 6, 4, 2, 737, 735, 3, 2, 2, 2, 737, 736, 3, 2,
	2, 2, 738, 739, 3, 2, 2, 2, 739, 737, 3, 2, 2, 2, 739, 740, 3, 2, 2, 2,
	740, 748, 3, 2, 2, 2, 741, 742, 5, 6, 4, 2, 742, 745, 7, 34, 2, 2, 743,
	746, 5, 6, 4, 2, 744, 746, 7, 5, 2, 2, 745, 743, 3, 2, 2, 2, 745, 744,
	3, 2, 2, 2, 746, 748, 3, 2, 2, 2, 747, 737, 3, 2, 2, 2, 747, 741, 3, 2,
	2, 2, 748, 105, 3, 2, 2, 2, 749, 750, 7, 54, 2, 2, 750, 755, 5, 104, 53,
	2, 751, 752, 7, 41, 2, 2, 752, 754, 5, 104, 53, 2, 753, 751, 3, 2, 2, 2,
	754, 757, 3, 2, 2, 2, 755, 753, 3, 2, 2, 2, 755, 756, 3, 2, 2, 2, 756,
	758, 3, 2, 2, 2, 757, 755, 3, 2, 2, 2, 758, 759, 7, 55, 2, 2, 759, 107,
	3, 2, 2, 2, 760, 765, 7, 32, 2, 2, 761, 762, 5, 100, 51, 2, 762, 763, 7,
	35, 2, 2, 763, 765, 3, 2, 2, 2, 764, 760, 3, 2, 2, 2, 764, 761, 3, 2, 2,
	2, 765, 766, 3, 2, 2, 2, 766, 768, 5, 102, 52, 2, 767, 769, 5, 106, 54,
	2, 768, 767, 3, 2, 2, 2, 768, 769, 3, 2, 2, 2, 769, 109, 3, 2, 2, 2, 770,
	771, 7, 17, 2, 2, 771, 772, 7, 69, 2, 2, 772, 773, 7, 45, 2, 2, 773, 777,
	7, 3, 2, 2, 774, 776, 5, 138, 70, 2, 775, 774, 3, 2, 2, 2, 776, 779, 3,
	2, 2, 2, 777, 775, 3, 2, 2, 2, 777, 778, 3, 2, 2, 2, 778, 780, 3, 2, 2,
	2, 779, 777, 3, 2, 2, 2, 780, 781, 7, 4, 2, 2, 781, 111, 3, 2, 2, 2, 782,
	784, 7, 21, 2, 2, 783, 785, 7, 69, 2, 2, 784, 783, 3, 2, 2, 2, 784, 785,
	3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 787, 7, 45, 2, 2, 787, 791, 7, 3,
	2, 2, 788, 790, 5, 138, 70, 2, 789, 788, 3, 2, 2, 2, 790, 793, 3, 2, 2,
	2, 791, 789, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 794, 3, 2, 2, 2, 793,
	791, 3, 2, 2, 2, 794, 795, 7, 4, 2, 2, 795, 113, 3, 2, 2, 2, 796, 800,
	5, 110, 56, 2, 797, 799, 5, 112, 57, 2, 798, 797, 3, 2, 2, 2, 799, 802,
	3, 2, 2, 2, 800, 798, 3, 2, 2, 2, 800, 801, 3, 2, 2, 2, 801, 115, 3, 2,
	2, 2, 802, 800, 3, 2, 2, 2, 803, 804, 9, 6, 2, 2, 804, 805, 7, 69, 2, 2,
	805, 806, 7, 45, 2, 2, 806, 810, 7, 3, 2, 2, 807, 809, 5, 138, 70, 2, 808,
	807, 3, 2, 2, 2, 809, 812, 3, 2, 2, 2, 810, 808, 3, 2, 2, 2, 810, 811,
	3, 2, 2, 2, 811, 813, 3, 2, 2, 2, 812, 810, 3, 2, 2, 2, 813, 814, 7, 4,
	2, 2, 814, 117, 3, 2, 2, 2, 815, 816, 7, 64, 2, 2, 816, 119, 3, 2, 2, 2,
	817, 818, 5, 6, 4, 2, 818, 819, 7, 45, 2, 2, 819, 821, 7, 3, 2, 2, 820,
	822, 5, 138, 70, 2, 821, 820, 3, 2, 2, 2, 822, 823, 3, 2, 2, 2, 823, 821,
	3, 2, 2, 2, 823, 824, 3, 2, 2, 2, 824, 825, 3, 2, 2, 2, 825, 826, 7, 4,
	2, 2, 826, 121, 3, 2, 2, 2, 827, 829, 9, 7, 2, 2, 828, 827, 3, 2, 2, 2,
	829, 830, 3, 2, 2, 2, 830, 828, 3, 2, 2, 2, 830, 831, 3, 2, 2, 2, 831,
	123, 3, 2, 2, 2, 832, 834, 5, 122, 62, 2, 833, 832, 3, 2, 2, 2, 833, 834,
	3, 2, 2, 2, 834, 835, 3, 2, 2, 2, 835, 836, 7, 45, 2, 2, 836, 838, 7, 3,
	2, 2, 837, 839, 5, 138, 70, 2, 838, 837, 3, 2, 2, 2, 839, 840, 3, 2, 2,
	2, 840, 838, 3, 2, 2, 2, 840, 841, 3, 2, 2, 2, 841, 842, 3, 2, 2, 2, 842,
	843, 7, 4, 2, 2, 843, 125, 3, 2, 2, 2, 844, 845, 7, 29, 2, 2, 845, 846,
	7, 45, 2, 2, 846, 848, 7, 3, 2, 2, 847, 849, 5, 124, 63, 2, 848, 847, 3,
	2, 2, 2, 849, 850, 3, 2, 2, 2, 850, 848, 3, 2, 2, 2, 850, 851, 3, 2, 2,
	2, 851, 852, 3, 2, 2, 2, 852, 853, 7, 4, 2, 2, 853, 127, 3, 2, 2, 2, 854,
	863, 5, 10, 6, 2, 855, 863, 7, 62, 2, 2, 856, 859, 5, 68, 35, 2, 857, 858,
	7, 36, 2, 2, 858, 860, 5, 6, 4, 2, 859, 857, 3, 2, 2, 2, 859, 860, 3, 2,
	2, 2, 860, 863, 3, 2, 2, 2, 861, 863, 7, 25, 2, 2, 862, 854, 3, 2, 2, 2,
	862, 855, 3, 2, 2, 2, 862, 856, 3, 2, 2, 2, 862, 861, 3, 2, 2, 2, 863,
	129, 3, 2, 2, 2, 864, 865, 7, 30, 2, 2, 865, 866, 5, 68, 35, 2, 866, 131,
	3, 2, 2, 2, 867, 870, 5, 8, 5, 2, 868, 870, 5, 52, 27, 2, 869, 867, 3,
	2, 2, 2, 869, 868, 3, 2, 2, 2, 870, 133, 3, 2, 2, 2, 871, 876, 5, 132,
	67, 2, 872, 873, 7, 41, 2, 2, 873, 875, 5, 132, 67, 2, 874, 872, 3, 2,
	2, 2, 875, 878, 3, 2, 2, 2, 876, 874, 3, 2, 2, 2, 876, 877, 3, 2, 2, 2,
	877, 135, 3, 2, 2, 2, 878, 876, 3, 2, 2, 2, 879, 880, 7, 54, 2, 2, 880,
	881, 5, 134, 68, 2, 881, 882, 7, 55, 2, 2, 882, 137, 3, 2, 2, 2, 883, 893,
	5, 114, 58, 2, 884, 893, 5, 116, 59, 2, 885, 893, 5, 98, 50, 2, 886, 893,
	5, 108, 55, 2, 887, 893, 5, 126, 64, 2, 888, 893, 5, 118, 60, 2, 889, 893,
	5, 120, 61, 2, 890, 893, 5, 128, 65, 2, 891, 893, 5, 42, 22, 2, 892, 883,
	3, 2, 2, 2, 892, 884, 3, 2, 2, 2, 892, 885, 3, 2, 2, 2, 892, 886, 3, 2,
	2, 2, 892, 887, 3, 2, 2, 2, 892, 888, 3, 2, 2, 2, 892, 889, 3, 2, 2, 2,
	892, 890, 3, 2, 2, 2, 892, 891, 3, 2, 2, 2, 893, 895, 3, 2, 2, 2, 894,
	896, 5, 22, 12, 2, 895, 894, 3, 2, 2, 2, 895, 896, 3, 2, 2, 2, 896, 139,
	3, 2, 2, 2, 897, 899, 7, 6, 2, 2, 898, 900, 5, 136, 69, 2, 899, 898, 3,
	2, 2, 2, 899, 900, 3, 2, 2, 2, 900, 902, 3, 2, 2, 2, 901, 903, 5, 84, 43,
	2, 902, 901, 3, 2, 2, 2, 902, 903, 3, 2, 2, 2, 903, 905, 3, 2, 2, 2, 904,
	906, 5, 22, 12, 2, 905, 904, 3, 2, 2, 2, 905, 906, 3, 2, 2, 2, 906, 907,
	3, 2, 2, 2, 907, 908, 7, 45, 2, 2, 908, 910, 7, 3, 2, 2, 909, 911, 5, 138,
	70, 2, 910, 909, 3, 2, 2, 2, 911, 912, 3, 2, 2, 2, 912, 910, 3, 2, 2, 2,
	912, 913, 3, 2, 2, 2, 913, 914, 3, 2, 2, 2, 914, 915, 7, 4, 2, 2, 915,
	141, 3, 2, 2, 2, 916, 917, 7, 25, 2, 2, 917, 143, 3, 2, 2, 2, 918, 942,
	7, 25, 2, 2, 919, 921, 5, 96, 49, 2, 920, 922, 7, 62, 2, 2, 921, 920, 3,
	2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 924, 3, 2, 2, 2, 923, 925, 5, 136,
	69, 2, 924, 923, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925, 927, 3, 2, 2, 2,
	926, 928, 5, 22, 12, 2, 927, 926, 3, 2, 2, 2, 927, 928, 3, 2, 2, 2, 928,
	929, 3, 2, 2, 2, 929, 939, 7, 45, 2, 2, 930, 940, 5, 142, 72, 2, 931, 933,
	7, 3, 2, 2, 932, 934, 5, 138, 70, 2, 933, 932, 3, 2, 2, 2, 934, 935, 3,
	2, 2, 2, 935, 933, 3, 2, 2, 2, 935, 936, 3, 2, 2, 2, 936, 937, 3, 2, 2,
	2, 937, 938, 7, 4, 2, 2, 938, 940, 3, 2, 2, 2, 939, 930, 3, 2, 2, 2, 939,
	931, 3, 2, 2, 2, 940, 942, 3, 2, 2, 2, 941, 918, 3, 2, 2, 2, 941, 919,
	3, 2, 2, 2, 942, 145, 3, 2, 2, 2, 943, 945, 5, 94, 48, 2, 944, 946, 5,
	22, 12, 2, 945, 944, 3, 2, 2, 2, 945, 946, 3, 2, 2, 2, 946, 947, 3, 2,
	2, 2, 947, 948, 7, 45, 2, 2, 948, 951, 7, 3, 2, 2, 949, 952, 5, 140, 71,
	2, 950, 952, 5, 146, 74, 2, 951, 949, 3, 2, 2, 2, 951, 950, 3, 2, 2, 2,
	952, 953, 3, 2, 2, 2, 953, 951, 3, 2, 2, 2, 953, 954, 3, 2, 2, 2, 954,
	955, 3, 2, 2, 2, 955, 956, 7, 4, 2, 2, 956, 147, 3, 2, 2, 2, 957, 958,
	5, 6, 4, 2, 958, 961, 7, 42, 2, 2, 959, 962, 7, 5, 2, 2, 960, 962, 5, 6,
	4, 2, 961, 959, 3, 2, 2, 2, 961, 960, 3, 2, 2, 2, 962, 149, 3, 2, 2, 2,
	963, 964, 7, 47, 2, 2, 964, 969, 5, 148, 75, 2, 965, 966, 7, 49, 2, 2,
	966, 968, 5, 148, 75, 2, 967, 965, 3, 2, 2, 2, 968, 971, 3, 2, 2, 2, 969,
	967, 3, 2, 2, 2, 969, 970, 3, 2, 2, 2, 970, 151, 3, 2, 2, 2, 971, 969,
	3, 2, 2, 2, 972, 973, 5, 100, 51, 2, 973, 974, 7, 35, 2, 2, 974, 975, 5,
	102, 52, 2, 975, 153, 3, 2, 2, 2, 976, 982, 5, 6, 4, 2, 977, 978, 7, 52,
	2, 2, 978, 979, 5, 6, 4, 2, 979, 980, 7, 53, 2, 2, 980, 982, 3, 2, 2, 2,
	981, 976, 3, 2, 2, 2, 981, 977, 3, 2, 2, 2, 982, 155, 3, 2, 2, 2, 983,
	984, 7, 44, 2, 2, 984, 986, 5, 154, 78, 2, 985, 983, 3, 2, 2, 2, 986, 987,
	3, 2, 2, 2, 987, 985, 3, 2, 2, 2, 987, 988, 3, 2, 2, 2, 988, 990, 3, 2,
	2, 2, 989, 991, 5, 150, 76, 2, 990, 989, 3, 2, 2, 2, 990, 991, 3, 2, 2,
	2, 991, 157, 3, 2, 2, 2, 992, 993, 7, 6, 2, 2, 993, 994, 5, 156, 79, 2,
	994, 159, 3, 2, 2, 2, 995, 996, 5, 68, 35, 2, 996, 161, 3, 2, 2, 2, 997,
	998, 5, 68, 35, 2, 998, 163, 3, 2, 2, 2, 999, 1000, 5, 162, 82, 2, 1000,
	1001, 7, 35, 2, 2, 1001, 1002, 5, 160, 81, 2, 1002, 1003, 7, 36, 2, 2,
	1003, 1004, 5, 6, 4, 2, 1004, 165, 3, 2, 2, 2, 1005, 1006, 5, 6, 4, 2,
	1006, 167, 3, 2, 2, 2, 1007, 1012, 5, 166, 84, 2, 1008, 1012, 5, 152, 77,
	2, 1009, 1012, 5, 158, 80, 2, 1010, 1012, 5, 164, 83, 2, 1011, 1007, 3,
	2, 2, 2, 1011, 1008, 3, 2, 2, 2, 1011, 1009, 3, 2, 2, 2, 1011, 1010, 3,
	2, 2, 2, 1012, 1013, 3, 2, 2, 2, 1013, 1014, 5, 22, 12, 2, 1014, 169, 3,
	2, 2, 2, 1015, 1016, 7, 37, 2, 2, 1016, 1026, 7, 45, 2, 2, 1017, 1027,
	7, 25, 2, 2, 1018, 1020, 7, 3, 2, 2, 1019, 1021, 5, 168, 85, 2, 1020, 1019,
	3, 2, 2, 2, 1021, 1022, 3, 2, 2, 2, 1022, 1020, 3, 2, 2, 2, 1022, 1023,
	3, 2, 2, 2, 1023, 1024, 3, 2, 2, 2, 1024, 1025, 7, 4, 2, 2, 1025, 1027,
	3, 2, 2, 2, 1026, 1017, 3, 2, 2, 2, 1026, 1018, 3, 2, 2, 2, 1027, 171,
	3, 2, 2, 2, 1028, 1029, 7, 31, 2, 2, 1029, 1031, 5, 6, 4, 2, 1030, 1032,
	5, 136, 69, 2, 1031, 1030, 3, 2, 2, 2, 1031, 1032, 3, 2, 2, 2, 1032, 1034,
	3, 2, 2, 2, 1033, 1035, 5, 22, 12, 2, 1034, 1033, 3, 2, 2, 2, 1034, 1035,
	3, 2, 2, 2, 1035, 1036, 3, 2, 2, 2, 1036, 1046, 7, 45, 2, 2, 1037, 1047,
	7, 25, 2, 2, 1038, 1040, 7, 3, 2, 2, 1039, 1041, 5, 138, 70, 2, 1040, 1039,
	3, 2, 2, 2, 1041, 1042, 3, 2, 2, 2, 1042, 1040, 3, 2, 2, 2, 1042, 1043,
	3, 2, 2, 2, 1043, 1044, 3, 2, 2, 2, 1044, 1045, 7, 4, 2, 2, 1045, 1047,
	3, 2, 2, 2, 1046, 1037, 3, 2, 2, 2, 1046, 1038, 3, 2, 2, 2, 1047, 173,
	3, 2, 2, 2, 1048, 1049, 5, 68, 35, 2, 1049, 1050, 7, 36, 2, 2, 1050, 1052,
	5, 6, 4, 2, 1051, 1053, 5, 22, 12, 2, 1052, 1051, 3, 2, 2, 2, 1052, 1053,
	3, 2, 2, 2, 1053, 1054, 3, 2, 2, 2, 1054, 1064, 7, 45, 2, 2, 1055, 1065,
	7, 25, 2, 2, 1056, 1058, 7, 3, 2, 2, 1057, 1059, 5, 138, 70, 2, 1058, 1057,
	3, 2, 2, 2, 1059, 1060, 3, 2, 2, 2, 1060, 1058, 3, 2, 2, 2, 1060, 1061,
	3, 2, 2, 2, 1061, 1062, 3, 2, 2, 2, 1062, 1063, 7, 4, 2, 2, 1063, 1065,
	3, 2, 2, 2, 1064, 1055, 3, 2, 2, 2, 1064, 1056, 3, 2, 2, 2, 1065, 175,
	3, 2, 2, 2, 1066, 1069, 5, 36, 19, 2, 1067, 1069, 5, 26, 14, 2, 1068, 1066,
	3, 2, 2, 2, 1068, 1067, 3, 2, 2, 2, 1069, 177, 3, 2, 2, 2, 1070, 1071,
	9, 8, 2, 2, 1071, 179, 3, 2, 2, 2, 1072, 1074, 9, 9, 2, 2, 1073, 1075,
	7, 91, 2, 2, 1074, 1073, 3, 2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075, 1076,
	3, 2, 2, 2, 1076, 1077, 7, 145, 2, 2, 1077, 181, 3, 2, 2, 2, 1078, 1079,
	5, 298, 150, 2, 1079, 183, 3, 2, 2, 2, 1080, 1085, 5, 182, 92, 2, 1081,
	1082, 7, 97, 2, 2, 1082, 1084, 5, 182, 92, 2, 1083, 1081, 3, 2, 2, 2, 1084,
	1087, 3, 2, 2, 2, 1085, 1083, 3, 2, 2, 2, 1085, 1086, 3, 2, 2, 2, 1086,
	185, 3, 2, 2, 2, 1087, 1085, 3, 2, 2, 2, 1088, 1089, 9, 10, 2, 2, 1089,
	1091, 7, 95, 2, 2, 1090, 1092, 5, 184, 93, 2, 1091, 1090, 3, 2, 2, 2, 1091,
	1092, 3, 2, 2, 2, 1092, 1093, 3, 2, 2, 2, 1093, 1094, 7, 96, 2, 2, 1094,
	187, 3, 2, 2, 2, 1095, 1097, 5, 298, 150, 2, 1096, 1098, 9, 11, 2, 2, 1097,
	1096, 3, 2, 2, 2, 1097, 1098, 3, 2, 2, 2, 1098, 189, 3, 2, 2, 2, 1099,
	1104, 5, 188, 95, 2, 1100, 1101, 7, 97, 2, 2, 1101, 1103, 5, 188, 95, 2,
	1102, 1100, 3, 2, 2, 2, 1103, 1106, 3, 2, 2, 2, 1104, 1102, 3, 2, 2, 2,
	1104, 1105, 3, 2, 2, 2, 1105, 191, 3, 2, 2, 2, 1106, 1104, 3, 2, 2, 2,
	1107, 1112, 7, 128, 2, 2, 1108, 1109, 7, 85, 2, 2, 1109, 1110, 5, 176,
	89, 2, 1110, 1111, 7, 86, 2, 2, 1111, 1113, 3, 2, 2, 2, 1112, 1108, 3,
	2, 2, 2, 1112, 1113, 3, 2, 2, 2, 1113, 1114, 3, 2, 2, 2, 1114, 1115, 7,
	95, 2, 2, 1115, 1116, 5, 190, 96, 2, 1116, 1117, 7, 114, 2, 2, 1117, 1118,
	7, 145, 2, 2, 1118, 1119, 7, 96, 2, 2, 1119, 193, 3, 2, 2, 2, 1120, 1121,
	7, 129, 2, 2, 1121, 1123, 7, 95, 2, 2, 1122, 1124, 5, 196, 99, 2, 1123,
	1122, 3, 2, 2, 2, 1123, 1124, 3, 2, 2, 2, 1124, 1125, 3, 2, 2, 2, 1125,
	1126, 5, 184, 93, 2, 1126, 1127, 7, 96, 2, 2, 1127, 195, 3, 2, 2, 2, 1128,
	1129, 7, 145, 2, 2, 1129, 1130, 7, 94, 2, 2, 1130, 197, 3, 2, 2, 2, 1131,
	1134, 7, 122, 2, 2, 1132, 1134, 5, 298, 150, 2, 1133, 1131, 3, 2, 2, 2,
	1133, 1132, 3, 2, 2, 2, 1134, 199, 3, 2, 2, 2, 1135, 1136, 7, 136, 2, 2,
	1136, 1137, 5, 198, 100, 2, 1137, 1138, 7, 110, 2, 2, 1138, 1140, 7, 95,
	2, 2, 1139, 1141, 5, 196, 99, 2, 1140, 1139, 3, 2, 2, 2, 1140, 1141, 3,
	2, 2, 2, 1141, 1142, 3, 2, 2, 2, 1142, 1143, 5, 190, 96, 2, 1143, 1144,
	7, 96, 2, 2, 1144, 201, 3, 2, 2, 2, 1145, 1146, 9, 12, 2, 2, 1146, 203,
	3, 2, 2, 2, 1147, 1148, 5, 202, 102, 2, 1148, 1150, 7, 95, 2, 2, 1149,
	1151, 5, 196, 99, 2, 1150, 1149, 3, 2, 2, 2, 1150, 1151, 3, 2, 2, 2, 1151,
	1152, 3, 2, 2, 2, 1152, 1153, 5, 298, 150, 2, 1153, 1154, 7, 96, 2, 2,
	1154, 205, 3, 2, 2, 2, 1155, 1156, 7, 130, 2, 2, 1156, 1157, 7, 95, 2,
	2, 1157, 1158, 5, 298, 150, 2, 1158, 1159, 7, 96, 2, 2, 1159, 207, 3, 2,
	2, 2, 1160, 1161, 7, 131, 2, 2, 1161, 209, 3, 2, 2, 2, 1162, 1163, 7, 132,
	2, 2, 1163, 211, 3, 2, 2, 2, 1164, 1165, 7, 134, 2, 2, 1165, 213, 3, 2,
	2, 2, 1166, 1168, 7, 146, 2, 2, 1167, 1166, 3, 2, 2, 2, 1167, 1168, 3,
	2, 2, 2, 1168, 1169, 3, 2, 2, 2, 1169, 1170, 7, 145, 2, 2, 1170, 215, 3,
	2, 2, 2, 1171, 1173, 7, 103, 2, 2, 1172, 1171, 3, 2, 2, 2, 1172, 1173,
	3, 2, 2, 2, 1173, 1174, 3, 2, 2, 2, 1174, 1176, 7, 80, 2, 2, 1175, 1177,
	9, 13, 2, 2, 1176, 1175, 3, 2, 2, 2, 1176, 1177, 3, 2, 2, 2, 1177, 1178,
	3, 2, 2, 2, 1178, 1181, 5, 214, 108, 2, 1179, 1180, 7, 115, 2, 2, 1180,
	1182, 7, 145, 2, 2, 1181, 1179, 3, 2, 2, 2, 1181, 1182, 3, 2, 2, 2, 1182,
	217, 3, 2, 2, 2, 1183, 1188, 5, 180, 91, 2, 1184, 1188, 5, 216, 109, 2,
	1185, 1188, 5, 240, 121, 2, 1186, 1188, 7, 145, 2, 2, 1187, 1183, 3, 2,
	2, 2, 1187, 1184, 3, 2, 2, 2, 1187, 1185, 3, 2, 2, 2, 1187, 1186, 3, 2,
	2, 2, 1188, 219, 3, 2, 2, 2, 1189, 1190, 7, 83, 2, 2, 1190, 1195, 7, 145,
	2, 2, 1191, 1192, 7, 97, 2, 2, 1192, 1194, 7, 145, 2, 2, 1193, 1191, 3,
	2, 2, 2, 1194, 1197, 3, 2, 2, 2, 1195, 1193, 3, 2, 2, 2, 1195, 1196, 3,
	2, 2, 2, 1196, 1198, 3, 2, 2, 2, 1197, 1195, 3, 2, 2, 2, 1198, 1199, 7,
	84, 2, 2, 1199, 221, 3, 2, 2, 2, 1200, 1202, 7, 105, 2, 2, 1201, 1200,
	3, 2, 2, 2, 1201, 1202, 3, 2, 2, 2, 1202, 1203, 3, 2, 2, 2, 1203, 1205,
	7, 104, 2, 2, 1204, 1206, 5, 220, 111, 2, 1205, 1204, 3, 2, 2, 2, 1205,
	1206, 3, 2, 2, 2, 1206, 1207, 3, 2, 2, 2, 1207, 1208, 7, 86, 2, 2, 1208,
	1209, 5, 218, 110, 2, 1209, 223, 3, 2, 2, 2, 1210, 1222, 5, 180, 91, 2,
	1211, 1222, 5, 192, 97, 2, 1212, 1222, 5, 194, 98, 2, 1213, 1222, 5, 204,
	103, 2, 1214, 1222, 5, 206, 104, 2, 1215, 1222, 5, 212, 107, 2, 1216, 1222,
	5, 208, 105, 2, 1217, 1222, 5, 210, 106, 2, 1218, 1222, 5, 200, 101, 2,
	1219, 1222, 5, 216, 109, 2, 1220, 1222, 5, 222, 112, 2, 1221, 1210, 3,
	2, 2, 2, 1221, 1211, 3, 2, 2, 2, 1221, 1212, 3, 2, 2, 2, 1221, 1213, 3,
	2, 2, 2, 1221, 1214, 3, 2, 2, 2, 1221, 1215, 3, 2, 2, 2, 1221, 1216, 3,
	2, 2, 2, 1221, 1217, 3, 2, 2, 2, 1221, 1218, 3, 2, 2, 2, 1221, 1219, 3,
	2, 2, 2, 1221, 1220, 3, 2, 2, 2, 1222, 225, 3, 2, 2, 2, 1223, 1224, 5,
	298, 150, 2, 1224, 227, 3, 2, 2, 2, 1225, 1230, 5, 226, 114, 2, 1226, 1227,
	7, 97, 2, 2, 1227, 1229, 5, 226, 114, 2, 1228, 1226, 3, 2, 2, 2, 1229,
	1232, 3, 2, 2, 2, 1230, 1228, 3, 2, 2, 2, 1230, 1231, 3, 2, 2, 2, 1231,
	229, 3, 2, 2, 2, 1232, 1230, 3, 2, 2, 2, 1233, 1234, 7, 88, 2, 2, 1234,
	1235, 5, 228, 115, 2, 1235, 1236, 7, 89, 2, 2, 1236, 231, 3, 2, 2, 2, 1237,
	1238, 7, 87, 2, 2, 1238, 233, 3, 2, 2, 2, 1239, 1250, 7, 146, 2, 2, 1240,
	1251, 5, 192, 97, 2, 1241, 1251, 5, 194, 98, 2, 1242, 1251, 5, 204, 103,
	2, 1243, 1251, 5, 206, 104, 2, 1244, 1251, 5, 212, 107, 2, 1245, 1251,
	5, 208, 105, 2, 1246, 1251, 5, 210, 106, 2, 1247, 1251, 5, 200, 101, 2,
	1248, 1251, 5, 216, 109, 2, 1249, 1251, 5, 222, 112, 2, 1250, 1240, 3,
	2, 2, 2, 1250, 1241, 3, 2, 2, 2, 1250, 1242, 3, 2, 2, 2, 1250, 1243, 3,
	2, 2, 2, 1250, 1244, 3, 2, 2, 2, 1250, 1245, 3, 2, 2, 2, 1250, 1246, 3,
	2, 2, 2, 1250, 1247, 3, 2, 2, 2, 1250, 1248, 3, 2, 2, 2, 1250, 1249, 3,
	2, 2, 2, 1251, 235, 3, 2, 2, 2, 1252, 1257, 5, 234, 118, 2, 1253, 1257,
	5, 216, 109, 2, 1254, 1257, 5, 222, 112, 2, 1255, 1257, 5, 180, 91, 2,
	1256, 1252, 3, 2, 2, 2, 1256, 1253, 3, 2, 2, 2, 1256, 1254, 3, 2, 2, 2,
	1256, 1255, 3, 2, 2, 2, 1257, 237, 3, 2, 2, 2, 1258, 1259, 9, 14, 2, 2,
	1259, 239, 3, 2, 2, 2, 1260, 1261, 7, 95, 2, 2, 1261, 1262, 5, 298, 150,
	2, 1262, 1263, 7, 96, 2, 2, 1263, 241, 3, 2, 2, 2, 1264, 1265, 7, 83, 2,
	2, 1265, 1266, 5, 228, 115, 2, 1266, 1267, 7, 84, 2, 2, 1267, 243, 3, 2,
	2, 2, 1268, 1277, 5, 186, 94, 2, 1269, 1277, 5, 230, 116, 2, 1270, 1277,
	5, 242, 122, 2, 1271, 1277, 5, 232, 117, 2, 1272, 1277, 5, 240, 121, 2,
	1273, 1277, 5, 178, 90, 2, 1274, 1277, 5, 236, 119, 2, 1275, 1277, 5, 238,
	120, 2, 1276, 1268, 3, 2, 2, 2, 1276, 1269, 3, 2, 2, 2, 1276, 1270, 3,
	2, 2, 2, 1276, 1271, 3, 2, 2, 2, 1276, 1272, 3, 2, 2, 2, 1276, 1273, 3,
	2, 2, 2, 1276, 1274, 3, 2, 2, 2, 1276, 1275, 3, 2, 2, 2, 1277, 245, 3,
	2, 2, 2, 1278, 1282, 5, 244, 123, 2, 1279, 1281, 5, 224, 113, 2, 1280,
	1279, 3, 2, 2, 2, 1281, 1284, 3, 2, 2, 2, 1282, 1280, 3, 2, 2, 2, 1282,
	1283, 3, 2, 2, 2, 1283, 247, 3, 2, 2, 2, 1284, 1282, 3, 2, 2, 2, 1285,
	1286, 7, 92, 2, 2, 1286, 1287, 5, 252, 127, 2, 1287, 249, 3, 2, 2, 2, 1288,
	1290, 5, 246, 124, 2, 1289, 1291, 5, 248, 125, 2, 1290, 1289, 3, 2, 2,
	2, 1290, 1291, 3, 2, 2, 2, 1291, 251, 3, 2, 2, 2, 1292, 1294, 9, 15, 2,
	2, 1293, 1292, 3, 2, 2, 2, 1293, 1294, 3, 2, 2, 2, 1294, 1295, 3, 2, 2,
	2, 1295, 1296, 5, 250, 126, 2, 1296, 253, 3, 2, 2, 2, 1297, 1298, 9, 16,
	2, 2, 1298, 1299, 5, 252, 127, 2, 1299, 255, 3, 2, 2, 2, 1300, 1304, 5,
	252, 127, 2, 1301, 1303, 5, 254, 128, 2, 1302, 1301, 3, 2, 2, 2, 1303,
	1306, 3, 2, 2, 2, 1304, 1302, 3, 2, 2, 2, 1304, 1305, 3, 2, 2, 2, 1305,
	257, 3, 2, 2, 2, 1306, 1304, 3, 2, 2, 2, 1307, 1308, 9, 17, 2, 2, 1308,
	1309, 5, 256, 129, 2, 1309, 259, 3, 2, 2, 2, 1310, 1314, 5, 256, 129, 2,
	1311, 1313, 5, 258, 130, 2, 1312, 1311, 3, 2, 2, 2, 1313, 1316, 3, 2, 2,
	2, 1314, 1312, 3, 2, 2, 2, 1314, 1315, 3, 2, 2, 2, 1315, 261, 3, 2, 2,
	2, 1316, 1314, 3, 2, 2, 2, 1317, 1318, 9, 18, 2, 2, 1318, 263, 3, 2, 2,
	2, 1319, 1325, 5, 260, 131, 2, 1320, 1321, 5, 262, 132, 2, 1321, 1322,
	5, 260, 131, 2, 1322, 1324, 3, 2, 2, 2, 1323, 1320, 3, 2, 2, 2, 1324, 1327,
	3, 2, 2, 2, 1325, 1323, 3, 2, 2, 2, 1325, 1326, 3, 2, 2, 2, 1326, 265,
	3, 2, 2, 2, 1327, 1325, 3, 2, 2, 2, 1328, 1333, 5, 264, 133, 2, 1329, 1330,
	9, 19, 2, 2, 1330, 1332, 5, 264, 133, 2, 1331, 1329, 3, 2, 2, 2, 1332,
	1335, 3, 2, 2, 2, 1333, 1331, 3, 2, 2, 2, 1333, 1334, 3, 2, 2, 2, 1334,
	267, 3, 2, 2, 2, 1335, 1333, 3, 2, 2, 2, 1336, 1341, 5, 266, 134, 2, 1337,
	1338, 7, 106, 2, 2, 1338, 1340, 5, 266, 134, 2, 1339, 1337, 3, 2, 2, 2,
	1340, 1343, 3, 2, 2, 2, 1341, 1339, 3, 2, 2, 2, 1341, 1342, 3, 2, 2, 2,
	1342, 269, 3, 2, 2, 2, 1343, 1341, 3, 2, 2, 2, 1344, 1349, 5, 268, 135,
	2, 1345, 1346, 7, 112, 2, 2, 1346, 1348, 5, 268, 135, 2, 1347, 1345, 3,
	2, 2, 2, 1348, 1351, 3, 2, 2, 2, 1349, 1347, 3, 2, 2, 2, 1349, 1350, 3,
	2, 2, 2, 1350, 271, 3, 2, 2, 2, 1351, 1349, 3, 2, 2, 2, 1352, 1357, 5,
	270, 136, 2, 1353, 1354, 7, 108, 2, 2, 1354, 1356, 5, 270, 136, 2, 1355,
	1353, 3, 2, 2, 2, 1356, 1359, 3, 2, 2, 2, 1357, 1355, 3, 2, 2, 2, 1357,
	1358, 3, 2, 2, 2, 1358, 273, 3, 2, 2, 2, 1359, 1357, 3, 2, 2, 2, 1360,
	1365, 5, 272, 137, 2, 1361, 1362, 7, 107, 2, 2, 1362, 1364, 5, 272, 137,
	2, 1363, 1361, 3, 2, 2, 2, 1364, 1367, 3, 2, 2, 2, 1365, 1363, 3, 2, 2,
	2, 1365, 1366, 3, 2, 2, 2, 1366, 275, 3, 2, 2, 2, 1367, 1365, 3, 2, 2,
	2, 1368, 1373, 5, 274, 138, 2, 1369, 1370, 7, 123, 2, 2, 1370, 1372, 5,
	274, 138, 2, 1371, 1369, 3, 2, 2, 2, 1372, 1375, 3, 2, 2, 2, 1373, 1371,
	3, 2, 2, 2, 1373, 1374, 3, 2, 2, 2, 1374, 277, 3, 2, 2, 2, 1375, 1373,
	3, 2, 2, 2, 1376, 1381, 5, 276, 139, 2, 1377, 1378, 7, 93, 2, 2, 1378,
	1380, 5, 276, 139, 2, 1379, 1377, 3, 2, 2, 2, 1380, 1383, 3, 2, 2, 2, 1381,
	1379, 3, 2, 2, 2, 1381, 1382, 3, 2, 2, 2, 1382, 279, 3, 2, 2, 2, 1383,
	1381, 3, 2, 2, 2, 1384, 1386, 5, 298, 150, 2, 1385, 1387, 7, 103, 2, 2,
	1386, 1385, 3, 2, 2, 2, 1386, 1387, 3, 2, 2, 2, 1387, 1388, 3, 2, 2, 2,
	1388, 1389, 7, 117, 2, 2, 1389, 1390, 5, 298, 150, 2, 1390, 1391, 7, 118,
	2, 2, 1391, 1392, 5, 298, 150, 2, 1392, 281, 3, 2, 2, 2, 1393, 1394, 5,
	298, 150, 2, 1394, 1395, 8, 142, 1, 2, 1395, 283, 3, 2, 2, 2, 1396, 1397,
	5, 298, 150, 2, 1397, 285, 3, 2, 2, 2, 1398, 1403, 5, 284, 143, 2, 1399,
	1400, 7, 97, 2, 2, 1400, 1402, 5, 284, 143, 2, 1401, 1399, 3, 2, 2, 2,
	1402, 1405, 3, 2, 2, 2, 1403, 1401, 3, 2, 2, 2, 1403, 1404, 3, 2, 2, 2,
	1404, 287, 3, 2, 2, 2, 1405, 1403, 3, 2, 2, 2, 1406, 1407, 5, 286, 144,
	2, 1407, 1408, 7, 79, 2, 2, 1408, 1411, 5, 282, 142, 2, 1409, 1412, 6,
	145, 2, 3, 1410, 1412, 7, 149, 2, 2, 1411, 1409, 3, 2, 2, 2, 1411, 1410,
	3, 2, 2, 2, 1412, 289, 3, 2, 2, 2, 1413, 1414, 7, 118, 2, 2, 1414, 1417,
	5, 298, 150, 2, 1415, 1418, 6, 146, 3, 3, 1416, 1418, 7, 149, 2, 2, 1417,
	1415, 3, 2, 2, 2, 1417, 1416, 3, 2, 2, 2, 1418, 291, 3, 2, 2, 2, 1419,
	1420, 5, 298, 150, 2, 1420, 1421, 7, 81, 2, 2, 1421, 293, 3, 2, 2, 2, 1422,
	1424, 5, 292, 147, 2, 1423, 1422, 3, 2, 2, 2, 1423, 1424, 3, 2, 2, 2, 1424,
	1425, 3, 2, 2, 2, 1425, 1426, 7, 94, 2, 2, 1426, 1427, 7, 149, 2, 2, 1427,
	1429, 7, 3, 2, 2, 1428, 1430, 5, 288, 145, 2, 1429, 1428, 3, 2, 2, 2, 1430,
	1431, 3, 2, 2, 2, 1431, 1429, 3, 2, 2, 2, 1431, 1432, 3, 2, 2, 2, 1432,
	1434, 3, 2, 2, 2, 1433, 1435, 5, 290, 146, 2, 1434, 1433, 3, 2, 2, 2, 1434,
	1435, 3, 2, 2, 2, 1435, 1436, 3, 2, 2, 2, 1436, 1437, 7, 4, 2, 2, 1437,
	295, 3, 2, 2, 2, 1438, 1443, 7, 116, 2, 2, 1439, 1444, 5, 280, 141, 2,
	1440, 1441, 5, 294, 148, 2, 1441, 1442, 8, 149, 1, 2, 1442, 1444, 3, 2,
	2, 2, 1443, 1439, 3, 2, 2, 2, 1443, 1440, 3, 2, 2, 2, 1444, 297, 3, 2,
	2, 2, 1445, 1446, 5, 296, 149, 2, 1446, 1447, 8, 150, 1, 2, 1447, 1450,
	3, 2, 2, 2, 1448, 1450, 5, 278, 140, 2, 1449, 1445, 3, 2, 2, 2, 1449, 1448,
	3, 2, 2, 2, 1450, 299, 3, 2, 2, 2, 1451, 1458, 7, 98, 2, 2, 1452, 1453,
	5, 298, 150, 2, 1453, 1454, 8, 151, 1, 2, 1454, 1459, 3, 2, 2, 2, 1455,
	1456, 5, 330, 166, 2, 1456, 1457, 8, 151, 1, 2, 1457, 1459, 3, 2, 2, 2,
	1458, 1452, 3, 2, 2, 2, 1458, 1455, 3, 2, 2, 2, 1459, 301, 3, 2, 2, 2,
	1460, 1461, 7, 145, 2, 2, 1461, 1462, 5, 300, 151, 2, 1462, 1463, 8, 152,
	1, 2, 1463, 303, 3, 2, 2, 2, 1464, 1465, 7, 119, 2, 2, 1465, 1466, 7, 145,
	2, 2, 1466, 1467, 5, 300, 151, 2, 1467, 1468, 8, 153, 1, 2, 1468, 305,
	3, 2, 2, 2, 1469, 1470, 7, 91, 2, 2, 1470, 1471, 7, 145, 2, 2, 1471, 1472,
	5, 300, 151, 2, 1472, 1473, 8, 154, 1, 2, 1473, 307, 3, 2, 2, 2, 1474,
	1475, 7, 144, 2, 2, 1475, 309, 3, 2, 2, 2, 1476, 1477, 5, 308, 155, 2,
	1477, 311, 3, 2, 2, 2, 1478, 1488, 7, 151, 2, 2, 1479, 1483, 7, 138, 2,
	2, 1480, 1482, 5, 298, 150, 2, 1481, 1480, 3, 2, 2, 2, 1482, 1485, 3, 2,
	2, 2, 1483, 1481, 3, 2, 2, 2, 1483, 1484, 3, 2, 2, 2, 1484, 1486, 3, 2,
	2, 2, 1485, 1483, 3, 2, 2, 2, 1486, 1488, 7, 139, 2, 2, 1487, 1478, 3,
	2, 2, 2, 1487, 1479, 3, 2, 2, 2, 1488, 313, 3, 2, 2, 2, 1489, 1491, 7,
	139, 2, 2, 1490, 1492, 7, 152, 2, 2, 1491, 1490, 3, 2, 2, 2, 1491, 1492,
	3, 2, 2, 2, 1492, 1496, 3, 2, 2, 2, 1493, 1495, 5, 312, 157, 2, 1494, 1493,
	3, 2, 2, 2, 1495, 1498, 3, 2, 2, 2, 1496, 1494, 3, 2, 2, 2, 1496, 1497,
	3, 2, 2, 2, 1497, 1499, 3, 2, 2, 2, 1498, 1496, 3, 2, 2, 2, 1499, 1500,
	9, 20, 2, 2, 1500, 315, 3, 2, 2, 2, 1501, 1502, 5, 304, 153, 2, 1502, 1503,
	8, 159, 1, 2, 1503, 1511, 3, 2, 2, 2, 1504, 1505, 5, 306, 154, 2, 1505,
	1506, 8, 159, 1, 2, 1506, 1511, 3, 2, 2, 2, 1507, 1508, 5, 302, 152, 2,
	1508, 1509, 8, 159, 1, 2, 1509, 1511, 3, 2, 2, 2, 1510, 1501, 3, 2, 2,
	2, 1510, 1504, 3, 2, 2, 2, 1510, 1507, 3, 2, 2, 2, 1511, 1514, 3, 2, 2,
	2, 1512, 1515, 6, 159, 4, 3, 1513, 1515, 7, 149, 2, 2, 1514, 1512, 3, 2,
	2, 2, 1514, 1513, 3, 2, 2, 2, 1515, 317, 3, 2, 2, 2, 1516, 1517, 5, 186,
	94, 2, 1517, 1518, 7, 146, 2, 2, 1518, 1519, 7, 113, 2, 2, 1519, 1520,
	7, 149, 2, 2, 1520, 319, 3, 2, 2, 2, 1521, 1525, 5, 310, 156, 2, 1522,
	1525, 5, 316, 159, 2, 1523, 1525, 5, 318, 160, 2, 1524, 1521, 3, 2, 2,
	2, 1524, 1522, 3, 2, 2, 2, 1524, 1523, 3, 2, 2, 2, 1525, 321, 3, 2, 2,
	2, 1526, 1530, 5, 28, 15, 2, 1527, 1530, 5, 32, 17, 2, 1528, 1530, 5, 176,
	89, 2, 1529, 1526, 3, 2, 2, 2, 1529, 1527, 3, 2, 2, 2, 1529, 1528, 3, 2,
	2, 2, 1530, 323, 3, 2, 2, 2, 1531, 1532, 5, 176, 89, 2, 1532, 325, 3, 2,
	2, 2, 1533, 1534, 7, 145, 2, 2, 1534, 327, 3, 2, 2, 2, 1535, 1536, 5, 298,
	150, 2, 1536, 329, 3, 2, 2, 2, 1537, 1539, 5, 328, 165, 2, 1538, 1537,
	3, 2, 2, 2, 1538, 1539, 3, 2, 2, 2, 1539, 1540, 3, 2, 2, 2, 1540, 1545,
	7, 80, 2, 2, 1541, 1542, 7, 85, 2, 2, 1542, 1543, 5, 322, 162, 2, 1543,
	1544, 7, 86, 2, 2, 1544, 1546, 3, 2, 2, 2, 1545, 1541, 3, 2, 2, 2, 1545,
	1546, 3, 2, 2, 2, 1546, 1547, 3, 2, 2, 2, 1547, 1549, 7, 95, 2, 2, 1548,
	1550, 5, 326, 164, 2, 1549, 1548, 3, 2, 2, 2, 1549, 1550, 3, 2, 2, 2, 1550,
	1551, 3, 2, 2, 2, 1551, 1552, 7, 94, 2, 2, 1552, 1553, 7, 149, 2, 2, 1553,
	1556, 7, 3, 2, 2, 1554, 1557, 5, 320, 161, 2, 1555, 1557, 5, 314, 158,
	2, 1556, 1554, 3, 2, 2, 2, 1556, 1555, 3, 2, 2, 2, 1557, 1558, 3, 2, 2,
	2, 1558, 1556, 3, 2, 2, 2, 1558, 1559, 3, 2, 2, 2, 1559, 1560, 3, 2, 2,
	2, 1560, 1561, 7, 4, 2, 2, 1561, 1562, 7, 96, 2, 2, 1562, 1563, 7, 149,
	2, 2, 1563, 331, 3, 2, 2, 2, 1564, 1565, 7, 3, 2, 2, 1565, 1566, 5, 330,
	166, 2, 1566, 1567, 7, 4, 2, 2, 1567, 333, 3, 2, 2, 2, 1568, 1569, 5, 6,
	4, 2, 1569, 1570, 7, 34, 2, 2, 1570, 1571, 5, 176, 89, 2, 1571, 335, 3,
	2, 2, 2, 1572, 1577, 5, 334, 168, 2, 1573, 1574, 7, 41, 2, 2, 1574, 1576,
	5, 334, 168, 2, 1575, 1573, 3, 2, 2, 2, 1576, 1579, 3, 2, 2, 2, 1577, 1575,
	3, 2, 2, 2, 1577, 1578, 3, 2, 2, 2, 1578, 337, 3, 2, 2, 2, 1579, 1577,
	3, 2, 2, 2, 1580, 1581, 7, 39, 2, 2, 1581, 339, 3, 2, 2, 2, 1582, 1583,
	7, 13, 2, 2, 1583, 1584, 5, 6, 4, 2, 1584, 1585, 7, 54, 2, 2, 1585, 1586,
	5, 336, 169, 2, 1586, 1589, 7, 55, 2, 2, 1587, 1588, 7, 36, 2, 2, 1588,
	1590, 5, 324, 163, 2, 1589, 1587, 3, 2, 2, 2, 1589, 1590, 3, 2, 2, 2, 1590,
	1599, 3, 2, 2, 2, 1591, 1593, 5, 22, 12, 2, 1592, 1591, 3, 2, 2, 2, 1592,
	1593, 3, 2, 2, 2, 1593, 1594, 3, 2, 2, 2, 1594, 1595, 7, 45, 2, 2, 1595,
	1600, 5, 332, 167, 2, 1596, 1597, 5, 338, 170, 2, 1597, 1598, 8, 171, 1,
	2, 1598, 1600, 3, 2, 2, 2, 1599, 1592, 3, 2, 2, 2, 1599, 1596, 3, 2, 2,
	2, 1600, 341, 3, 2, 2, 2, 1601, 1602, 7, 10, 2, 2, 1602, 1604, 5, 6, 4,
	2, 1603, 1605, 5, 22, 12, 2, 1604, 1603, 3, 2, 2, 2, 1604, 1605, 3, 2,
	2, 2, 1605, 1606, 3, 2, 2, 2, 1606, 1630, 7, 45, 2, 2, 1607, 1609, 5, 42,
	22, 2, 1608, 1607, 3, 2, 2, 2, 1609, 1612, 3, 2, 2, 2, 1610, 1608, 3, 2,
	2, 2, 1610, 1611, 3, 2, 2, 2, 1611, 1615, 3, 2, 2, 2, 1612, 1610, 3, 2,
	2, 2, 1613, 1616, 5, 26, 14, 2, 1614, 1616, 5, 36, 19, 2, 1615, 1613, 3,
	2, 2, 2, 1615, 1614, 3, 2, 2, 2, 1616, 1631, 3, 2, 2, 2, 1617, 1621, 7,
	3, 2, 2, 1618, 1620, 5, 42, 22, 2, 1619, 1618, 3, 2, 2, 2, 1620, 1623,
	3, 2, 2, 2, 1621, 1619, 3, 2, 2, 2, 1621, 1622, 3, 2, 2, 2, 1622, 1626,
	3, 2, 2, 2, 1623, 1621, 3, 2, 2, 2, 1624, 1627, 5, 26, 14, 2, 1625, 1627,
	5, 36, 19, 2, 1626, 1624, 3, 2, 2, 2, 1626, 1625, 3, 2, 2, 2, 1627, 1628,
	3, 2, 2, 2, 1628, 1629, 7, 4, 2, 2, 1629, 1631, 3, 2, 2, 2, 1630, 1610,
	3, 2, 2, 2, 1630, 1617, 3, 2, 2, 2, 1631, 343, 3, 2, 2, 2, 1632, 1633,
	7, 66, 2, 2, 1633, 1634, 7, 45, 2, 2, 1634, 1635, 7, 61, 2, 2, 1635, 345,
	3, 2, 2, 2, 1636, 1639, 7, 3, 2, 2, 1637, 1640, 5, 344, 173, 2, 1638, 1640,
	7, 25, 2, 2, 1639, 1637, 3, 2, 2, 2, 1639, 1638, 3, 2, 2, 2, 1640, 1641,
	3, 2, 2, 2, 1641, 1639, 3, 2, 2, 2, 1641, 1642, 3, 2, 2, 2, 1642, 1643,
	3, 2, 2, 2, 1643, 1644, 7, 4, 2, 2, 1644, 347, 3, 2, 2, 2, 1645, 1646,
	7, 11, 2, 2, 1646, 1648, 7, 66, 2, 2, 1647, 1649, 5, 22, 12, 2, 1648, 1647,
	3, 2, 2, 2, 1648, 1649, 3, 2, 2, 2, 1649, 1650, 3, 2, 2, 2, 1650, 1653,
	7, 45, 2, 2, 1651, 1654, 7, 25, 2, 2, 1652, 1654, 5, 346, 174, 2, 1653,
	1651, 3, 2, 2, 2, 1653, 1652, 3, 2, 2, 2, 1654, 349, 3, 2, 2, 2, 1655,
	1672, 7, 3, 2, 2, 1656, 1673, 5, 342, 172, 2, 1657, 1673, 5, 42, 22, 2,
	1658, 1673, 5, 170, 86, 2, 1659, 1673, 5, 348, 175, 2, 1660, 1673, 5, 172,
	87, 2, 1661, 1673, 5, 78, 40, 2, 1662, 1673, 5, 130, 66, 2, 1663, 1673,
	5, 146, 74, 2, 1664, 1673, 5, 144, 73, 2, 1665, 1673, 5, 174, 88, 2, 1666,
	1673, 7, 64, 2, 2, 1667, 1673, 5, 62, 32, 2, 1668, 1669, 5, 340, 171, 2,
	1669, 1670, 8, 176, 1, 2, 1670, 1673, 3, 2, 2, 2, 1671, 1673, 5, 60, 31,
	2, 1672, 1656, 3, 2, 2, 2, 1672, 1657, 3, 2, 2, 2, 1672, 1658, 3, 2, 2,
	2, 1672, 1659, 3, 2, 2, 2, 1672, 1660, 3, 2, 2, 2, 1672, 1661, 3, 2, 2,
	2, 1672, 1662, 3, 2, 2, 2, 1672, 1663, 3, 2, 2, 2, 1672, 1664, 3, 2, 2,
	2, 1672, 1665, 3, 2, 2, 2, 1672, 1666, 3, 2, 2, 2, 1672, 1667, 3, 2, 2,
	2, 1672, 1668, 3, 2, 2, 2, 1672, 1671, 3, 2, 2, 2, 1673, 1674, 3, 2, 2,
	2, 1674, 1672, 3, 2, 2, 2, 1674, 1675, 3, 2, 2, 2, 1675, 1678, 3, 2, 2,
	2, 1676, 1679, 6, 176, 5, 3, 1677, 1679, 7, 4, 2, 2, 1678, 1676, 3, 2,
	2, 2, 1678, 1677, 3, 2, 2, 2, 1679, 351, 3, 2, 2, 2, 1680, 1682, 7, 64,
	2, 2, 1681, 1680, 3, 2, 2, 2, 1682, 1685, 3, 2, 2, 2, 1683, 1681, 3, 2,
	2, 2, 1683, 1684, 3, 2, 2, 2, 1684, 1686, 3, 2, 2, 2, 1685, 1683, 3, 2,
	2, 2, 1686, 1687, 5, 70, 36, 2, 1687, 1688, 7, 45, 2, 2, 1688, 1689, 5,
	350, 176, 2, 1689, 353, 3, 2, 2, 2, 1690, 1691, 7, 40, 2, 2, 1691, 1692,
	7, 66, 2, 2, 1692, 355, 3, 2, 2, 2, 1693, 1694, 7, 14, 2, 2, 1694, 1704,
	7, 150, 2, 2, 1695, 1696, 7, 15, 2, 2, 1696, 1701, 7, 66, 2, 2, 1697, 1698,
	7, 46, 2, 2, 1698, 1700, 7, 66, 2, 2, 1699, 1697, 3, 2, 2, 2, 1700, 1703,
	3, 2, 2, 2, 1701, 1699, 3, 2, 2, 2, 1701, 1702, 3, 2, 2, 2, 1702, 1705,
	3, 2, 2, 2, 1703, 1701, 3, 2, 2, 2, 1704, 1695, 3, 2, 2, 2, 1704, 1705,
	3, 2, 2, 2, 1705, 1709, 3, 2, 2, 2, 1706, 1708, 7, 67, 2, 2, 1707, 1706,
	3, 2, 2, 2, 1708, 1711, 3, 2, 2, 2, 1709, 1707, 3, 2, 2, 2, 1709, 1710,
	3, 2, 2, 2, 1710, 1713, 3, 2, 2, 2, 1711, 1709, 3, 2, 2, 2, 1712, 1714,
	5, 354, 178, 2, 1713, 1712, 3, 2, 2, 2, 1713, 1714, 3, 2, 2, 2, 1714, 1722,
	3, 2, 2, 2, 1715, 1717, 7, 64, 2, 2, 1716, 1715, 3, 2, 2, 2, 1717, 1720,
	3, 2, 2, 2, 1718, 1716, 3, 2, 2, 2, 1718, 1719, 3, 2, 2, 2, 1719, 1723,
	3, 2, 2, 2, 1720, 1718, 3, 2, 2, 2, 1721, 1723, 7, 63, 2, 2, 1722, 1718,
	3, 2, 2, 2, 1722, 1721, 3, 2, 2, 2, 1723, 357, 3, 2, 2, 2, 1724, 1726,
	5, 356, 179, 2, 1725, 1724, 3, 2, 2, 2, 1726, 1727, 3, 2, 2, 2, 1727, 1725,
	3, 2, 2, 2, 1727, 1728, 3, 2, 2, 2, 1728, 359, 3, 2, 2, 2, 1729, 1731,
	5, 358, 180, 2, 1730, 1729, 3, 2, 2, 2, 1730, 1731, 3, 2, 2, 2, 1731, 1733,
	3, 2, 2, 2, 1732, 1734, 5, 352, 177, 2, 1733, 1732, 3, 2, 2, 2, 1734, 1735,
	3, 2, 2, 2, 1735, 1733, 3, 2, 2, 2, 1735, 1736, 3, 2, 2, 2, 1736, 1737,
	3, 2, 2, 2, 1737, 1738, 7, 2, 2, 3, 1738, 361, 3, 2, 2, 2, 197, 368, 375,
	386, 399, 410, 420, 424, 432, 442, 446, 451, 455, 460, 464, 471, 478, 489,
	497, 499, 502, 505, 509, 515, 523, 529, 534, 537, 539, 549, 551, 556, 561,
	566, 576, 582, 591, 593, 596, 607, 612, 615, 624, 628, 635, 640, 649, 662,
	665, 673, 687, 690, 693, 701, 710, 716, 718, 725, 737, 739, 745, 747, 755,
	764, 768, 777, 784, 791, 800, 810, 823, 830, 833, 840, 850, 859, 862, 869,
	876, 892, 895, 899, 902, 905, 912, 921, 924, 927, 935, 939, 941, 945, 951,
	953, 961, 969, 981, 987, 990, 1011, 1022, 1026, 1031, 1034, 1042, 1046,
	1052, 1060, 1064, 1068, 1074, 1085, 1091, 1097, 1104, 1112, 1123, 1133,
	1140, 1150, 1167, 1172, 1176, 1181, 1187, 1195, 1201, 1205, 1221, 1230,
	1250, 1256, 1276, 1282, 1290, 1293, 1304, 1314, 1325, 1333, 1341, 1349,
	1357, 1365, 1373, 1381, 1386, 1403, 1411, 1417, 1423, 1431, 1434, 1443,
	1449, 1458, 1483, 1487, 1491, 1496, 1510, 1514, 1524, 1529, 1538, 1545,
	1549, 1556, 1558, 1577, 1589, 1592, 1599, 1604, 1610, 1615, 1621, 1626,
	1630, 1639, 1641, 1648, 1653, 1672, 1674, 1678, 1683, 1701, 1704, 1709,
	1713, 1718, 1722, 1727, 1730, 1735,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "'!wrap'", "'!table'", "'!type'", "'!alias'", "'!enum'",
	"'!union'", "'!view'", "", "", "", "", "", "", "", "", "", "", "", "",
	"'..'", "", "", "", "", "'<->'", "", "", "", "", "", "'.. * <- *'", "",
	"", "", "", "", "'//'", "", "", "", "", "'@'", "", "", "", "", "", "",
	"", "", "'#'", "'|'", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "'=>'", "'->'", "'=='", "", "", "", "'<'",
	"'>'", "'{:}'", "", "", "'?.'", "", "'**'", "", "", "", "", "", "", "",
	"", "'%'", "'-'", "", "", "", "", "'||'", "'&&'", "", "'by'", "'and'",
	"", "'*'", "'as'", "'via'", "'if'", "'then'", "'else'", "'let'", "'true'",
	"'false'", "'null'", "", "", "", "'asc'", "'desc'", "'rank'", "", "'any'",
	"", "'snapshot'", "'where'", "'count'", "'flatten'", "'first'",
}
var symbolicNames = []string{
	"", "INDENT", "DEDENT", "NativeDataTypes", "HTTP_VERBS", "WRAP", "TABLE",
	"TYPE", "ALIAS", "ENUM", "UNION", "VIEW", "IMPORT", "AS", "RETURN", "IF",
	"FOR_EACH", "FOR", "UNTIL", "ELSE", "LOOP", "ALT", "WHILE", "WHATEVER",
	"DOTDOT", "SEQUENCE_OF", "SET_OF", "ONE_OF", "MIXIN", "DISTANCE", "DOT_ARROW",
	"NAME_SEP", "LESS_COLON", "ARROW_LEFT", "ARROW_RIGHT", "COLLECTOR", "PLUS",
	"ABSTRACT", "TILDE", "COMMA", "EQ", "EXTERNAL_IMPORT", "FORWARD_SLASH",
	"COLON", "DOT", "QN", "AT", "AMP", "SQ_OPEN", "SQ_CLOSE", "CURLY_OPEN",
	"CURLY_CLOSE", "OPEN_PAREN", "CLOSE_PAREN", "EMPTY_COMMENT", "HASH", "PIPE",
	"EMPTY_LINE", "INDENTED_COMMENT", "DIGITS", "QSTRING", "NEWLINE", "SYSL_COMMENT",
	"TEXT_LINE", "Name", "WS", "ErrorChar", "PREDICATE_VALUE", "SKIP_WS_ARG",
	"TEXT_VALUE", "NEWLINE_2", "TEXT", "POP_WS", "VAR_NAME", "E_NativeDataTypes",
	"E_INDENTED_COMMENT", "E_WHATEVER", "E_EQ_RIGHT", "E_ARROW_RIGHT", "E_DOUBLE_EQ",
	"E_REL", "E_SQ_OPEN", "E_SQ_CLOSE", "E_ANGLE_OPEN", "E_ANGLE_CLOSE", "E_EMPTY_TUPLE",
	"E_CURLY_OPEN", "E_CURLY_CLOSE", "E_NULLSAFE_DOT", "E_TABLE_OF", "E_POW",
	"E_COALESCE", "E_COLON", "E_OPEN_PAREN", "E_CLOSE_PAREN", "E_COMMA", "E_EQ",
	"E_PLUS", "E_DIVIDE", "E_MOD", "E_MINUS", "E_QN", "E_TILDE", "E_NOT", "E_XOR",
	"E_LOGIC_OR", "E_DOUBLE_AMP", "E_AMP", "E_BY", "E_AND", "E_BITOR", "E_STAR",
	"E_AS", "E_VIA", "E_IF", "E_THEN", "E_ELSE", "E_LET", "E_TRUE", "E_FALSE",
	"E_NULL", "E_BUTNOT", "E_SEQUENCE_OF", "E_SET_OF", "E_ASC", "E_DESC", "E_RELOPS_RANK",
	"E_RELOPS_AGG", "E_RELOPS_ANY", "E_RELOPS_SINGLE_NULL", "E_RELOPS_SNAPSHOT",
	"E_RELOPS_WHERE", "E_RELOPS_COUNT", "E_RELOPS_FLATTEN", "E_RELOPS_FIRST",
	"E_FUNC", "E_RAW_TEXT_END", "E_RAW_TEXT_START", "E_STRING_DBL", "E_STRING_SINGLE",
	"E_DECIMAL", "E_DIGITS", "E_DOT_NAME_NL", "E_Name", "E_DOT", "E_WS", "E_EMPTY_LINE",
	"E_NL", "IMPORT_PATH", "TMPL_TEXT", "TMPL_DEBUG", "TMPL_NL",
}

var ruleNames = []string{
	"modifier", "size_spec", "name_str", "reference", "doc_string", "quoted_string",
	"array_of_strings", "array_of_arrays", "nvp", "entry", "attribs_or_modifiers",
	"user_defined_type", "types", "set_of", "set_type", "sequence_of", "sequence_type",
	"collection_type", "multi_line_docstring", "annotation_value", "annotation",
	"annotations", "field_type", "array_size", "inplace_tuple", "field", "inplace_table",
	"table_stmts", "table_def", "table", "union", "package_name", "sub_package",
	"app_name", "name_with_attribs", "model_name", "inplace_table_def", "table_refs",
	"facade", "var_in_curly", "query_var", "query_param", "http_path_part",
	"http_path_var_with_type", "http_path_static", "http_path_suffix", "http_path",
	"endpoint_name", "ret_stmt", "target", "target_endpoint", "call_arg", "call_args",
	"call_stmt", "if_stmt", "else_stmt", "if_else", "for_stmt", "http_method_comment",
	"group_stmt", "one_of_case_label", "one_of_cases", "one_of_stmt", "text_stmt",
	"mixin", "param", "param_list", "params", "statements", "method_def", "shortcut",
	"simple_endpoint", "rest_endpoint", "collector_query_var", "collector_query_param",
	"collector_call_stmt", "collector_http_stmt_part", "collector_http_stmt_suffix",
	"collector_http_stmt", "publisher", "subscriber", "collector_pubsub_call",
	"collector_action_stmt", "collector_stmts", "collector", "event", "subscribe",
	"view_type_spec", "literal", "expr_table_of_op", "func_arg", "func_args",
	"expr_func", "rank_expr", "rank_expr_list", "expr_rank_func", "expr_agg_func",
	"e_scope_var", "first_func_target", "expr_first_func", "e_single_arg_func",
	"expr_single_arg_func", "expr_any_func", "expr_single_or_null", "expr_snapshot",
	"expr_count", "expr_navigate_attr", "expr_navigate", "matching_rhs", "squiggly_args",
	"expr_matching", "relop", "list_item", "expr_list", "expr_set", "empty_tuple",
	"atom_dot_relop", "atomT_implied_dot", "atomT_name", "atomT_paren", "expr_atom_list",
	"atomT", "atom", "powerT", "power", "unaryTerm", "termT", "term", "binexprT",
	"binexpr", "e_compare_ops", "expr_rel", "expr_bitand", "expr_bitxor", "expr_bitor",
	"expr_and", "expr_or", "expr_but_not", "expr_coalesce", "if_one_liner",
	"else_block_stmt", "control_item", "if_controls", "cond_block", "final_else",
	"ifvar", "if_multiple_lines", "expr_if_else", "expr", "expr_assign", "expr_simple_assign",
	"expr_let_statement", "expr_table_of_statement", "expr_dot_assign", "expr_statement_no_nl",
	"template_expression", "template_statement", "expr_statement", "expr_inject_stmt",
	"expr_stmt", "transform_return_type", "view_return_type", "transform_scope_var",
	"transform_arg", "transform", "expr_block", "view_param", "view_params",
	"abstract_view", "view", "alias", "enumeration", "enum_stmts", "enum",
	"app_decl", "application", "import_mode", "import_stmt", "imports_decl",
	"sysl_file",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SyslParser struct {
	*antlr.BaseParser
}

func NewSyslParser(input antlr.TokenStream) *SyslParser {
	this := new(SyslParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SyslParser.g4"

	return this
}

// SyslParser tokens.
const (
	SyslParserEOF                  = antlr.TokenEOF
	SyslParserINDENT               = 1
	SyslParserDEDENT               = 2
	SyslParserNativeDataTypes      = 3
	SyslParserHTTP_VERBS           = 4
	SyslParserWRAP                 = 5
	SyslParserTABLE                = 6
	SyslParserTYPE                 = 7
	SyslParserALIAS                = 8
	SyslParserENUM                 = 9
	SyslParserUNION                = 10
	SyslParserVIEW                 = 11
	SyslParserIMPORT               = 12
	SyslParserAS                   = 13
	SyslParserRETURN               = 14
	SyslParserIF                   = 15
	SyslParserFOR_EACH             = 16
	SyslParserFOR                  = 17
	SyslParserUNTIL                = 18
	SyslParserELSE                 = 19
	SyslParserLOOP                 = 20
	SyslParserALT                  = 21
	SyslParserWHILE                = 22
	SyslParserWHATEVER             = 23
	SyslParserDOTDOT               = 24
	SyslParserSEQUENCE_OF          = 25
	SyslParserSET_OF               = 26
	SyslParserONE_OF               = 27
	SyslParserMIXIN                = 28
	SyslParserDISTANCE             = 29
	SyslParserDOT_ARROW            = 30
	SyslParserNAME_SEP             = 31
	SyslParserLESS_COLON           = 32
	SyslParserARROW_LEFT           = 33
	SyslParserARROW_RIGHT          = 34
	SyslParserCOLLECTOR            = 35
	SyslParserPLUS                 = 36
	SyslParserABSTRACT             = 37
	SyslParserTILDE                = 38
	SyslParserCOMMA                = 39
	SyslParserEQ                   = 40
	SyslParserEXTERNAL_IMPORT      = 41
	SyslParserFORWARD_SLASH        = 42
	SyslParserCOLON                = 43
	SyslParserDOT                  = 44
	SyslParserQN                   = 45
	SyslParserAT                   = 46
	SyslParserAMP                  = 47
	SyslParserSQ_OPEN              = 48
	SyslParserSQ_CLOSE             = 49
	SyslParserCURLY_OPEN           = 50
	SyslParserCURLY_CLOSE          = 51
	SyslParserOPEN_PAREN           = 52
	SyslParserCLOSE_PAREN          = 53
	SyslParserEMPTY_COMMENT        = 54
	SyslParserHASH                 = 55
	SyslParserPIPE                 = 56
	SyslParserEMPTY_LINE           = 57
	SyslParserINDENTED_COMMENT     = 58
	SyslParserDIGITS               = 59
	SyslParserQSTRING              = 60
	SyslParserNEWLINE              = 61
	SyslParserSYSL_COMMENT         = 62
	SyslParserTEXT_LINE            = 63
	SyslParserName                 = 64
	SyslParserWS                   = 65
	SyslParserErrorChar            = 66
	SyslParserPREDICATE_VALUE      = 67
	SyslParserSKIP_WS_ARG          = 68
	SyslParserTEXT_VALUE           = 69
	SyslParserNEWLINE_2            = 70
	SyslParserTEXT                 = 71
	SyslParserPOP_WS               = 72
	SyslParserVAR_NAME             = 73
	SyslParserE_NativeDataTypes    = 74
	SyslParserE_INDENTED_COMMENT   = 75
	SyslParserE_WHATEVER           = 76
	SyslParserE_EQ_RIGHT           = 77
	SyslParserE_ARROW_RIGHT        = 78
	SyslParserE_DOUBLE_EQ          = 79
	SyslParserE_REL                = 80
	SyslParserE_SQ_OPEN            = 81
	SyslParserE_SQ_CLOSE           = 82
	SyslParserE_ANGLE_OPEN         = 83
	SyslParserE_ANGLE_CLOSE        = 84
	SyslParserE_EMPTY_TUPLE        = 85
	SyslParserE_CURLY_OPEN         = 86
	SyslParserE_CURLY_CLOSE        = 87
	SyslParserE_NULLSAFE_DOT       = 88
	SyslParserE_TABLE_OF           = 89
	SyslParserE_POW                = 90
	SyslParserE_COALESCE           = 91
	SyslParserE_COLON              = 92
	SyslParserE_OPEN_PAREN         = 93
	SyslParserE_CLOSE_PAREN        = 94
	SyslParserE_COMMA              = 95
	SyslParserE_EQ                 = 96
	SyslParserE_PLUS               = 97
	SyslParserE_DIVIDE             = 98
	SyslParserE_MOD                = 99
	SyslParserE_MINUS              = 100
	SyslParserE_QN                 = 101
	SyslParserE_TILDE              = 102
	SyslParserE_NOT                = 103
	SyslParserE_XOR                = 104
	SyslParserE_LOGIC_OR           = 105
	SyslParserE_DOUBLE_AMP         = 106
	SyslParserE_AMP                = 107
	SyslParserE_BY                 = 108
	SyslParserE_AND                = 109
	SyslParserE_BITOR              = 110
	SyslParserE_STAR               = 111
	SyslParserE_AS                 = 112
	SyslParserE_VIA                = 113
	SyslParserE_IF                 = 114
	SyslParserE_THEN               = 115
	SyslParserE_ELSE               = 116
	SyslParserE_LET                = 117
	SyslParserE_TRUE               = 118
	SyslParserE_FALSE              = 119
	SyslParserE_NULL               = 120
	SyslParserE_BUTNOT             = 121
	SyslParserE_SEQUENCE_OF        = 122
	SyslParserE_SET_OF             = 123
	SyslParserE_ASC                = 124
	SyslParserE_DESC               = 125
	SyslParserE_RELOPS_RANK        = 126
	SyslParserE_RELOPS_AGG         = 127
	SyslParserE_RELOPS_ANY         = 128
	SyslParserE_RELOPS_SINGLE_NULL = 129
	SyslParserE_RELOPS_SNAPSHOT    = 130
	SyslParserE_RELOPS_WHERE       = 131
	SyslParserE_RELOPS_COUNT       = 132
	SyslParserE_RELOPS_FLATTEN     = 133
	SyslParserE_RELOPS_FIRST       = 134
	SyslParserE_FUNC               = 135
	SyslParserE_RAW_TEXT_END       = 136
	SyslParserE_RAW_TEXT_START     = 137
	SyslParserE_STRING_DBL         = 138
	SyslParserE_STRING_SINGLE      = 139
	SyslParserE_DECIMAL            = 140
	SyslParserE_DIGITS             = 141
	SyslParserE_DOT_NAME_NL        = 142
	SyslParserE_Name               = 143
	SyslParserE_DOT                = 144
	SyslParserE_WS                 = 145
	SyslParserE_EMPTY_LINE         = 146
	SyslParserE_NL                 = 147
	SyslParserIMPORT_PATH          = 148
	SyslParserTMPL_TEXT            = 149
	SyslParserTMPL_DEBUG           = 150
	SyslParserTMPL_NL              = 151
)

// SyslParser rules.
const (
	SyslParserRULE_modifier                   = 0
	SyslParserRULE_size_spec                  = 1
	SyslParserRULE_name_str                   = 2
	SyslParserRULE_reference                  = 3
	SyslParserRULE_doc_string                 = 4
	SyslParserRULE_quoted_string              = 5
	SyslParserRULE_array_of_strings           = 6
	SyslParserRULE_array_of_arrays            = 7
	SyslParserRULE_nvp                        = 8
	SyslParserRULE_entry                      = 9
	SyslParserRULE_attribs_or_modifiers       = 10
	SyslParserRULE_user_defined_type          = 11
	SyslParserRULE_types                      = 12
	SyslParserRULE_set_of                     = 13
	SyslParserRULE_set_type                   = 14
	SyslParserRULE_sequence_of                = 15
	SyslParserRULE_sequence_type              = 16
	SyslParserRULE_collection_type            = 17
	SyslParserRULE_multi_line_docstring       = 18
	SyslParserRULE_annotation_value           = 19
	SyslParserRULE_annotation                 = 20
	SyslParserRULE_annotations                = 21
	SyslParserRULE_field_type                 = 22
	SyslParserRULE_array_size                 = 23
	SyslParserRULE_inplace_tuple              = 24
	SyslParserRULE_field                      = 25
	SyslParserRULE_inplace_table              = 26
	SyslParserRULE_table_stmts                = 27
	SyslParserRULE_table_def                  = 28
	SyslParserRULE_table                      = 29
	SyslParserRULE_union                      = 30
	SyslParserRULE_package_name               = 31
	SyslParserRULE_sub_package                = 32
	SyslParserRULE_app_name                   = 33
	SyslParserRULE_name_with_attribs          = 34
	SyslParserRULE_model_name                 = 35
	SyslParserRULE_inplace_table_def          = 36
	SyslParserRULE_table_refs                 = 37
	SyslParserRULE_facade                     = 38
	SyslParserRULE_var_in_curly               = 39
	SyslParserRULE_query_var                  = 40
	SyslParserRULE_query_param                = 41
	SyslParserRULE_http_path_part             = 42
	SyslParserRULE_http_path_var_with_type    = 43
	SyslParserRULE_http_path_static           = 44
	SyslParserRULE_http_path_suffix           = 45
	SyslParserRULE_http_path                  = 46
	SyslParserRULE_endpoint_name              = 47
	SyslParserRULE_ret_stmt                   = 48
	SyslParserRULE_target                     = 49
	SyslParserRULE_target_endpoint            = 50
	SyslParserRULE_call_arg                   = 51
	SyslParserRULE_call_args                  = 52
	SyslParserRULE_call_stmt                  = 53
	SyslParserRULE_if_stmt                    = 54
	SyslParserRULE_else_stmt                  = 55
	SyslParserRULE_if_else                    = 56
	SyslParserRULE_for_stmt                   = 57
	SyslParserRULE_http_method_comment        = 58
	SyslParserRULE_group_stmt                 = 59
	SyslParserRULE_one_of_case_label          = 60
	SyslParserRULE_one_of_cases               = 61
	SyslParserRULE_one_of_stmt                = 62
	SyslParserRULE_text_stmt                  = 63
	SyslParserRULE_mixin                      = 64
	SyslParserRULE_param                      = 65
	SyslParserRULE_param_list                 = 66
	SyslParserRULE_params                     = 67
	SyslParserRULE_statements                 = 68
	SyslParserRULE_method_def                 = 69
	SyslParserRULE_shortcut                   = 70
	SyslParserRULE_simple_endpoint            = 71
	SyslParserRULE_rest_endpoint              = 72
	SyslParserRULE_collector_query_var        = 73
	SyslParserRULE_collector_query_param      = 74
	SyslParserRULE_collector_call_stmt        = 75
	SyslParserRULE_collector_http_stmt_part   = 76
	SyslParserRULE_collector_http_stmt_suffix = 77
	SyslParserRULE_collector_http_stmt        = 78
	SyslParserRULE_publisher                  = 79
	SyslParserRULE_subscriber                 = 80
	SyslParserRULE_collector_pubsub_call      = 81
	SyslParserRULE_collector_action_stmt      = 82
	SyslParserRULE_collector_stmts            = 83
	SyslParserRULE_collector                  = 84
	SyslParserRULE_event                      = 85
	SyslParserRULE_subscribe                  = 86
	SyslParserRULE_view_type_spec             = 87
	SyslParserRULE_literal                    = 88
	SyslParserRULE_expr_table_of_op           = 89
	SyslParserRULE_func_arg                   = 90
	SyslParserRULE_func_args                  = 91
	SyslParserRULE_expr_func                  = 92
	SyslParserRULE_rank_expr                  = 93
	SyslParserRULE_rank_expr_list             = 94
	SyslParserRULE_expr_rank_func             = 95
	SyslParserRULE_expr_agg_func              = 96
	SyslParserRULE_e_scope_var                = 97
	SyslParserRULE_first_func_target          = 98
	SyslParserRULE_expr_first_func            = 99
	SyslParserRULE_e_single_arg_func          = 100
	SyslParserRULE_expr_single_arg_func       = 101
	SyslParserRULE_expr_any_func              = 102
	SyslParserRULE_expr_single_or_null        = 103
	SyslParserRULE_expr_snapshot              = 104
	SyslParserRULE_expr_count                 = 105
	SyslParserRULE_expr_navigate_attr         = 106
	SyslParserRULE_expr_navigate              = 107
	SyslParserRULE_matching_rhs               = 108
	SyslParserRULE_squiggly_args              = 109
	SyslParserRULE_expr_matching              = 110
	SyslParserRULE_relop                      = 111
	SyslParserRULE_list_item                  = 112
	SyslParserRULE_expr_list                  = 113
	SyslParserRULE_expr_set                   = 114
	SyslParserRULE_empty_tuple                = 115
	SyslParserRULE_atom_dot_relop             = 116
	SyslParserRULE_atomT_implied_dot          = 117
	SyslParserRULE_atomT_name                 = 118
	SyslParserRULE_atomT_paren                = 119
	SyslParserRULE_expr_atom_list             = 120
	SyslParserRULE_atomT                      = 121
	SyslParserRULE_atom                       = 122
	SyslParserRULE_powerT                     = 123
	SyslParserRULE_power                      = 124
	SyslParserRULE_unaryTerm                  = 125
	SyslParserRULE_termT                      = 126
	SyslParserRULE_term                       = 127
	SyslParserRULE_binexprT                   = 128
	SyslParserRULE_binexpr                    = 129
	SyslParserRULE_e_compare_ops              = 130
	SyslParserRULE_expr_rel                   = 131
	SyslParserRULE_expr_bitand                = 132
	SyslParserRULE_expr_bitxor                = 133
	SyslParserRULE_expr_bitor                 = 134
	SyslParserRULE_expr_and                   = 135
	SyslParserRULE_expr_or                    = 136
	SyslParserRULE_expr_but_not               = 137
	SyslParserRULE_expr_coalesce              = 138
	SyslParserRULE_if_one_liner               = 139
	SyslParserRULE_else_block_stmt            = 140
	SyslParserRULE_control_item               = 141
	SyslParserRULE_if_controls                = 142
	SyslParserRULE_cond_block                 = 143
	SyslParserRULE_final_else                 = 144
	SyslParserRULE_ifvar                      = 145
	SyslParserRULE_if_multiple_lines          = 146
	SyslParserRULE_expr_if_else               = 147
	SyslParserRULE_expr                       = 148
	SyslParserRULE_expr_assign                = 149
	SyslParserRULE_expr_simple_assign         = 150
	SyslParserRULE_expr_let_statement         = 151
	SyslParserRULE_expr_table_of_statement    = 152
	SyslParserRULE_expr_dot_assign            = 153
	SyslParserRULE_expr_statement_no_nl       = 154
	SyslParserRULE_template_expression        = 155
	SyslParserRULE_template_statement         = 156
	SyslParserRULE_expr_statement             = 157
	SyslParserRULE_expr_inject_stmt           = 158
	SyslParserRULE_expr_stmt                  = 159
	SyslParserRULE_transform_return_type      = 160
	SyslParserRULE_view_return_type           = 161
	SyslParserRULE_transform_scope_var        = 162
	SyslParserRULE_transform_arg              = 163
	SyslParserRULE_transform                  = 164
	SyslParserRULE_expr_block                 = 165
	SyslParserRULE_view_param                 = 166
	SyslParserRULE_view_params                = 167
	SyslParserRULE_abstract_view              = 168
	SyslParserRULE_view                       = 169
	SyslParserRULE_alias                      = 170
	SyslParserRULE_enumeration                = 171
	SyslParserRULE_enum_stmts                 = 172
	SyslParserRULE_enum                       = 173
	SyslParserRULE_app_decl                   = 174
	SyslParserRULE_application                = 175
	SyslParserRULE_import_mode                = 176
	SyslParserRULE_import_stmt                = 177
	SyslParserRULE_imports_decl               = 178
	SyslParserRULE_sysl_file                  = 179
)

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserTILDE, 0)
}

func (s *ModifierContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *ModifierContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *ModifierContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserPLUS)
}

func (s *ModifierContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserPLUS, i)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *SyslParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SyslParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		p.Match(SyslParserTILDE)
	}
	{
		p.SetState(361)
		p.Match(SyslParserName)
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserPLUS {
		{
			p.SetState(362)
			p.Match(SyslParserPLUS)
		}
		{
			p.SetState(363)
			p.Match(SyslParserName)
		}

		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISize_specContext is an interface to support dynamic dispatch.
type ISize_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSize_specContext differentiates from other interfaces.
	IsSize_specContext()
}

type Size_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySize_specContext() *Size_specContext {
	var p = new(Size_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_size_spec
	return p
}

func (*Size_specContext) IsSize_specContext() {}

func NewSize_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Size_specContext {
	var p = new(Size_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_size_spec

	return p
}

func (s *Size_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Size_specContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Size_specContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Size_specContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Size_specContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Size_specContext) DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, 0)
}

func (s *Size_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Size_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Size_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSize_spec(s)
	}
}

func (s *Size_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSize_spec(s)
	}
}

func (p *SyslParser) Size_spec() (localctx ISize_specContext) {
	localctx = NewSize_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SyslParserRULE_size_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(370)
		p.Match(SyslParserDIGITS)
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDOT {
		{
			p.SetState(371)
			p.Match(SyslParserDOT)
		}
		{
			p.SetState(372)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(375)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IName_strContext is an interface to support dynamic dispatch.
type IName_strContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_strContext differentiates from other interfaces.
	IsName_strContext()
}

type Name_strContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_strContext() *Name_strContext {
	var p = new(Name_strContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_str
	return p
}

func (*Name_strContext) IsName_strContext() {}

func NewName_strContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_strContext {
	var p = new(Name_strContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_str

	return p
}

func (s *Name_strContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_strContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Name_strContext) TEXT_LINE() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, 0)
}

func (s *Name_strContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Name_strContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_strContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_strContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_str(s)
	}
}

func (s *Name_strContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_str(s)
	}
}

func (p *SyslParser) Name_str() (localctx IName_strContext) {
	localctx = NewName_strContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SyslParserRULE_name_str)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(377)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_reference
	return p
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *ReferenceContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *ReferenceContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ReferenceContext) AllE_DOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOT)
}

func (s *ReferenceContext) E_DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, i)
}

func (s *ReferenceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDOT)
}

func (s *ReferenceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, i)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterReference(s)
	}
}

func (s *ReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitReference(s)
	}
}

func (p *SyslParser) Reference() (localctx IReferenceContext) {
	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SyslParserRULE_reference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.App_name()
	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(380)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SyslParserDOT || _la == SyslParserE_DOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(381)
				p.Name_str()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(384)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
	}

	return localctx
}

// IDoc_stringContext is an interface to support dynamic dispatch.
type IDoc_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoc_stringContext differentiates from other interfaces.
	IsDoc_stringContext()
}

type Doc_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoc_stringContext() *Doc_stringContext {
	var p = new(Doc_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_doc_string
	return p
}

func (*Doc_stringContext) IsDoc_stringContext() {}

func NewDoc_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Doc_stringContext {
	var p = new(Doc_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_doc_string

	return p
}

func (s *Doc_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Doc_stringContext) PIPE() antlr.TerminalNode {
	return s.GetToken(SyslParserPIPE, 0)
}

func (s *Doc_stringContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Doc_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Doc_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Doc_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterDoc_string(s)
	}
}

func (s *Doc_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitDoc_string(s)
	}
}

func (p *SyslParser) Doc_string() (localctx IDoc_stringContext) {
	localctx = NewDoc_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SyslParserRULE_doc_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Match(SyslParserPIPE)
	}
	{
		p.SetState(387)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// IQuoted_stringContext is an interface to support dynamic dispatch.
type IQuoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuoted_stringContext differentiates from other interfaces.
	IsQuoted_stringContext()
}

type Quoted_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_stringContext() *Quoted_stringContext {
	var p = new(Quoted_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_quoted_string
	return p
}

func (*Quoted_stringContext) IsQuoted_stringContext() {}

func NewQuoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_stringContext {
	var p = new(Quoted_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_quoted_string

	return p
}

func (s *Quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_stringContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuoted_string(s)
	}
}

func (s *Quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuoted_string(s)
	}
}

func (p *SyslParser) Quoted_string() (localctx IQuoted_stringContext) {
	localctx = NewQuoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SyslParserRULE_quoted_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(SyslParserQSTRING)
	}

	return localctx
}

// IArray_of_stringsContext is an interface to support dynamic dispatch.
type IArray_of_stringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_stringsContext differentiates from other interfaces.
	IsArray_of_stringsContext()
}

type Array_of_stringsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_stringsContext() *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_strings
	return p
}

func (*Array_of_stringsContext) IsArray_of_stringsContext() {}

func NewArray_of_stringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_strings

	return p
}

func (s *Array_of_stringsContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_stringsContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_stringsContext) AllQuoted_string() []IQuoted_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem())
	var tst = make([]IQuoted_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuoted_stringContext)
		}
	}

	return tst
}

func (s *Array_of_stringsContext) Quoted_string(i int) IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Array_of_stringsContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_stringsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_stringsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_stringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_stringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_stringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_strings(s)
	}
}

func (s *Array_of_stringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_strings(s)
	}
}

func (p *SyslParser) Array_of_strings() (localctx IArray_of_stringsContext) {
	localctx = NewArray_of_stringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SyslParserRULE_array_of_strings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(392)
		p.Quoted_string()
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(393)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(394)
			p.Quoted_string()
		}

		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(400)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IArray_of_arraysContext is an interface to support dynamic dispatch.
type IArray_of_arraysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_arraysContext differentiates from other interfaces.
	IsArray_of_arraysContext()
}

type Array_of_arraysContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_arraysContext() *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_arrays
	return p
}

func (*Array_of_arraysContext) IsArray_of_arraysContext() {}

func NewArray_of_arraysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_arrays

	return p
}

func (s *Array_of_arraysContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_arraysContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_arraysContext) AllArray_of_strings() []IArray_of_stringsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem())
	var tst = make([]IArray_of_stringsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArray_of_stringsContext)
		}
	}

	return tst
}

func (s *Array_of_arraysContext) Array_of_strings(i int) IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Array_of_arraysContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_arraysContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_arraysContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_arraysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_arraysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_arraysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_arrays(s)
	}
}

func (s *Array_of_arraysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_arrays(s)
	}
}

func (p *SyslParser) Array_of_arrays() (localctx IArray_of_arraysContext) {
	localctx = NewArray_of_arraysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SyslParserRULE_array_of_arrays)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(403)
		p.Array_of_strings()
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(404)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(405)
			p.Array_of_strings()
		}

		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(411)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// INvpContext is an interface to support dynamic dispatch.
type INvpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNvpContext differentiates from other interfaces.
	IsNvpContext()
}

type NvpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNvpContext() *NvpContext {
	var p = new(NvpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_nvp
	return p
}

func (*NvpContext) IsNvpContext() {}

func NewNvpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NvpContext {
	var p = new(NvpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_nvp

	return p
}

func (s *NvpContext) GetParser() antlr.Parser { return s.parser }

func (s *NvpContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *NvpContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *NvpContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *NvpContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *NvpContext) Array_of_arrays() IArray_of_arraysContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_arraysContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_arraysContext)
}

func (s *NvpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NvpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NvpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterNvp(s)
	}
}

func (s *NvpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitNvp(s)
	}
}

func (p *SyslParser) Nvp() (localctx INvpContext) {
	localctx = NewNvpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SyslParserRULE_nvp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.Match(SyslParserName)
	}
	{
		p.SetState(414)
		p.Match(SyslParserEQ)
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(415)
			p.Quoted_string()
		}

	case 2:
		{
			p.SetState(416)
			p.Array_of_strings()
		}

	case 3:
		{
			p.SetState(417)
			p.Array_of_arrays()
		}

	}

	return localctx
}

// IEntryContext is an interface to support dynamic dispatch.
type IEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntryContext differentiates from other interfaces.
	IsEntryContext()
}

type EntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryContext() *EntryContext {
	var p = new(EntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_entry
	return p
}

func (*EntryContext) IsEntryContext() {}

func NewEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryContext {
	var p = new(EntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_entry

	return p
}

func (s *EntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryContext) Nvp() INvpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INvpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INvpContext)
}

func (s *EntryContext) Modifier() IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *EntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEntry(s)
	}
}

func (s *EntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEntry(s)
	}
}

func (p *SyslParser) Entry() (localctx IEntryContext) {
	localctx = NewEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SyslParserRULE_entry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(422)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(420)
			p.Nvp()
		}

	case SyslParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(421)
			p.Modifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribs_or_modifiersContext is an interface to support dynamic dispatch.
type IAttribs_or_modifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribs_or_modifiersContext differentiates from other interfaces.
	IsAttribs_or_modifiersContext()
}

type Attribs_or_modifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribs_or_modifiersContext() *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers
	return p
}

func (*Attribs_or_modifiersContext) IsAttribs_or_modifiersContext() {}

func NewAttribs_or_modifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers

	return p
}

func (s *Attribs_or_modifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribs_or_modifiersContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Attribs_or_modifiersContext) AllEntry() []IEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntryContext)(nil)).Elem())
	var tst = make([]IEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntryContext)
		}
	}

	return tst
}

func (s *Attribs_or_modifiersContext) Entry(i int) IEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntryContext)
}

func (s *Attribs_or_modifiersContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Attribs_or_modifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Attribs_or_modifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Attribs_or_modifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribs_or_modifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribs_or_modifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAttribs_or_modifiers(s)
	}
}

func (s *Attribs_or_modifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAttribs_or_modifiers(s)
	}
}

func (p *SyslParser) Attribs_or_modifiers() (localctx IAttribs_or_modifiersContext) {
	localctx = NewAttribs_or_modifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SyslParserRULE_attribs_or_modifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(425)
		p.Entry()
	}
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(426)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(427)
			p.Entry()
		}

		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(433)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IUser_defined_typeContext is an interface to support dynamic dispatch.
type IUser_defined_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUser_defined_typeContext differentiates from other interfaces.
	IsUser_defined_typeContext()
}

type User_defined_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_defined_typeContext() *User_defined_typeContext {
	var p = new(User_defined_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_user_defined_type
	return p
}

func (*User_defined_typeContext) IsUser_defined_typeContext() {}

func NewUser_defined_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_defined_typeContext {
	var p = new(User_defined_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_user_defined_type

	return p
}

func (s *User_defined_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *User_defined_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *User_defined_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_defined_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_defined_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUser_defined_type(s)
	}
}

func (s *User_defined_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUser_defined_type(s)
	}
}

func (p *SyslParser) User_defined_type() (localctx IUser_defined_typeContext) {
	localctx = NewUser_defined_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SyslParserRULE_user_defined_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(435)
		p.Name_str()
	}

	return localctx
}

// ITypesContext is an interface to support dynamic dispatch.
type ITypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypesContext differentiates from other interfaces.
	IsTypesContext()
}

type TypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesContext() *TypesContext {
	var p = new(TypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_types
	return p
}

func (*TypesContext) IsTypesContext() {}

func NewTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesContext {
	var p = new(TypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_types

	return p
}

func (s *TypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesContext) User_defined_type() IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *TypesContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *TypesContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *TypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTypes(s)
	}
}

func (s *TypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTypes(s)
	}
}

func (p *SyslParser) Types() (localctx ITypesContext) {
	localctx = NewTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SyslParserRULE_types)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(437)
			p.User_defined_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(438)
			p.Reference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(439)
			p.Match(SyslParserNativeDataTypes)
		}

	}

	return localctx
}

// ISet_ofContext is an interface to support dynamic dispatch.
type ISet_ofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_ofContext differentiates from other interfaces.
	IsSet_ofContext()
}

type Set_ofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_ofContext() *Set_ofContext {
	var p = new(Set_ofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_of
	return p
}

func (*Set_ofContext) IsSet_ofContext() {}

func NewSet_ofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_ofContext {
	var p = new(Set_ofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_of

	return p
}

func (s *Set_ofContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_ofContext) SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserSET_OF, 0)
}

func (s *Set_ofContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Set_ofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_ofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_ofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_of(s)
	}
}

func (s *Set_ofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_of(s)
	}
}

func (p *SyslParser) Set_of() (localctx ISet_ofContext) {
	localctx = NewSet_ofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SyslParserRULE_set_of)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(444)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(442)
			p.Match(SyslParserSET_OF)
		}

	case SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(443)
			p.Match(SyslParserE_SET_OF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISet_typeContext is an interface to support dynamic dispatch.
type ISet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_typeContext differentiates from other interfaces.
	IsSet_typeContext()
}

type Set_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_typeContext() *Set_typeContext {
	var p = new(Set_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_type
	return p
}

func (*Set_typeContext) IsSet_typeContext() {}

func NewSet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_typeContext {
	var p = new(Set_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_type

	return p
}

func (s *Set_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Set_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Set_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Set_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_type(s)
	}
}

func (s *Set_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_type(s)
	}
}

func (p *SyslParser) Set_type() (localctx ISet_typeContext) {
	localctx = NewSet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SyslParserRULE_set_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(446)
		p.Set_of()
	}
	{
		p.SetState(447)
		p.Types()
	}
	p.SetState(449)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(448)
			p.Size_spec()
		}

	}

	return localctx
}

// ISequence_ofContext is an interface to support dynamic dispatch.
type ISequence_ofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_ofContext differentiates from other interfaces.
	IsSequence_ofContext()
}

type Sequence_ofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_ofContext() *Sequence_ofContext {
	var p = new(Sequence_ofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sequence_of
	return p
}

func (*Sequence_ofContext) IsSequence_ofContext() {}

func NewSequence_ofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_ofContext {
	var p = new(Sequence_ofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sequence_of

	return p
}

func (s *Sequence_ofContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_ofContext) SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserSEQUENCE_OF, 0)
}

func (s *Sequence_ofContext) E_SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SEQUENCE_OF, 0)
}

func (s *Sequence_ofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_ofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_ofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSequence_of(s)
	}
}

func (s *Sequence_ofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSequence_of(s)
	}
}

func (p *SyslParser) Sequence_of() (localctx ISequence_ofContext) {
	localctx = NewSequence_ofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SyslParserRULE_sequence_of)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(453)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(451)
			p.Match(SyslParserSEQUENCE_OF)
		}

	case SyslParserE_SEQUENCE_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(452)
			p.Match(SyslParserE_SEQUENCE_OF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISequence_typeContext is an interface to support dynamic dispatch.
type ISequence_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_typeContext differentiates from other interfaces.
	IsSequence_typeContext()
}

type Sequence_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_typeContext() *Sequence_typeContext {
	var p = new(Sequence_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sequence_type
	return p
}

func (*Sequence_typeContext) IsSequence_typeContext() {}

func NewSequence_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_typeContext {
	var p = new(Sequence_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sequence_type

	return p
}

func (s *Sequence_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_typeContext) Sequence_of() ISequence_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_ofContext)
}

func (s *Sequence_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Sequence_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Sequence_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSequence_type(s)
	}
}

func (s *Sequence_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSequence_type(s)
	}
}

func (p *SyslParser) Sequence_type() (localctx ISequence_typeContext) {
	localctx = NewSequence_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SyslParserRULE_sequence_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(455)
		p.Sequence_of()
	}
	{
		p.SetState(456)
		p.Types()
	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(457)
			p.Size_spec()
		}

	}

	return localctx
}

// ICollection_typeContext is an interface to support dynamic dispatch.
type ICollection_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_typeContext differentiates from other interfaces.
	IsCollection_typeContext()
}

type Collection_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_typeContext() *Collection_typeContext {
	var p = new(Collection_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collection_type
	return p
}

func (*Collection_typeContext) IsCollection_typeContext() {}

func NewCollection_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_typeContext {
	var p = new(Collection_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collection_type

	return p
}

func (s *Collection_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_typeContext) Set_type() ISet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_typeContext)
}

func (s *Collection_typeContext) Sequence_type() ISequence_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_typeContext)
}

func (s *Collection_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollection_type(s)
	}
}

func (s *Collection_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollection_type(s)
	}
}

func (p *SyslParser) Collection_type() (localctx ICollection_typeContext) {
	localctx = NewCollection_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SyslParserRULE_collection_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(462)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(460)
			p.Set_type()
		}

	case SyslParserSEQUENCE_OF, SyslParserE_SEQUENCE_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(461)
			p.Sequence_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMulti_line_docstringContext is an interface to support dynamic dispatch.
type IMulti_line_docstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_line_docstringContext differentiates from other interfaces.
	IsMulti_line_docstringContext()
}

type Multi_line_docstringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_line_docstringContext() *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_multi_line_docstring
	return p
}

func (*Multi_line_docstringContext) IsMulti_line_docstringContext() {}

func NewMulti_line_docstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_multi_line_docstring

	return p
}

func (s *Multi_line_docstringContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_line_docstringContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Multi_line_docstringContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Multi_line_docstringContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Multi_line_docstringContext) AllDoc_string() []IDoc_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem())
	var tst = make([]IDoc_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDoc_stringContext)
		}
	}

	return tst
}

func (s *Multi_line_docstringContext) Doc_string(i int) IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Multi_line_docstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_line_docstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_line_docstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMulti_line_docstring(s)
	}
}

func (s *Multi_line_docstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMulti_line_docstring(s)
	}
}

func (p *SyslParser) Multi_line_docstring() (localctx IMulti_line_docstringContext) {
	localctx = NewMulti_line_docstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SyslParserRULE_multi_line_docstring)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(465)
		p.Match(SyslParserINDENT)
	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserPIPE {
		{
			p.SetState(466)
			p.Doc_string()
		}

		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(471)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IAnnotation_valueContext is an interface to support dynamic dispatch.
type IAnnotation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_valueContext differentiates from other interfaces.
	IsAnnotation_valueContext()
}

type Annotation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_valueContext() *Annotation_valueContext {
	var p = new(Annotation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation_value
	return p
}

func (*Annotation_valueContext) IsAnnotation_valueContext() {}

func NewAnnotation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_valueContext {
	var p = new(Annotation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation_value

	return p
}

func (s *Annotation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_valueContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Annotation_valueContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Annotation_valueContext) Multi_line_docstring() IMulti_line_docstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_line_docstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_line_docstringContext)
}

func (s *Annotation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation_value(s)
	}
}

func (s *Annotation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation_value(s)
	}
}

func (p *SyslParser) Annotation_value() (localctx IAnnotation_valueContext) {
	localctx = NewAnnotation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SyslParserRULE_annotation_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(476)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(473)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserSQ_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(474)
			p.Array_of_strings()
		}

	case SyslParserCOLON:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(475)
			p.Multi_line_docstring()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(SyslParserAT, 0)
}

func (s *AnnotationContext) VAR_NAME() antlr.TerminalNode {
	return s.GetToken(SyslParserVAR_NAME, 0)
}

func (s *AnnotationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *AnnotationContext) Annotation_value() IAnnotation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_valueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *SyslParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SyslParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.Match(SyslParserAT)
	}
	{
		p.SetState(479)
		p.Match(SyslParserVAR_NAME)
	}
	{
		p.SetState(480)
		p.Match(SyslParserEQ)
	}
	{
		p.SetState(481)
		p.Annotation_value()
	}

	return localctx
}

// IAnnotationsContext is an interface to support dynamic dispatch.
type IAnnotationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationsContext differentiates from other interfaces.
	IsAnnotationsContext()
}

type AnnotationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsContext() *AnnotationsContext {
	var p = new(AnnotationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotations
	return p
}

func (*AnnotationsContext) IsAnnotationsContext() {}

func NewAnnotationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsContext {
	var p = new(AnnotationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotations

	return p
}

func (s *AnnotationsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *AnnotationsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *AnnotationsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotationsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotations(s)
	}
}

func (s *AnnotationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotations(s)
	}
}

func (p *SyslParser) Annotations() (localctx IAnnotationsContext) {
	localctx = NewAnnotationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SyslParserRULE_annotations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(483)
		p.Match(SyslParserINDENT)
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserAT {
		{
			p.SetState(484)
			p.Annotation()
		}

		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(489)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IField_typeContext is an interface to support dynamic dispatch.
type IField_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_typeContext differentiates from other interfaces.
	IsField_typeContext()
}

type Field_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_typeContext() *Field_typeContext {
	var p = new(Field_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field_type
	return p
}

func (*Field_typeContext) IsField_typeContext() {}

func NewField_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_typeContext {
	var p = new(Field_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field_type

	return p
}

func (s *Field_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_typeContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *Field_typeContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Field_typeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Field_typeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Field_typeContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Field_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Field_typeContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *Field_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Field_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField_type(s)
	}
}

func (s *Field_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField_type(s)
	}
}

func (p *SyslParser) Field_type() (localctx IField_typeContext) {
	localctx = NewField_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SyslParserRULE_field_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(497)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
		{
			p.SetState(491)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(492)
			p.Types()
		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(493)
				p.Array_size()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(494)
				p.Size_spec()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(499)
			p.Match(SyslParserQN)
		}

	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(502)
			p.Attribs_or_modifiers()
		}

	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserCOLON {
		{
			p.SetState(505)
			p.Match(SyslParserCOLON)
		}
		{
			p.SetState(506)
			p.Annotations()
		}

	}

	return localctx
}

// IArray_sizeContext is an interface to support dynamic dispatch.
type IArray_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_sizeContext differentiates from other interfaces.
	IsArray_sizeContext()
}

type Array_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_sizeContext() *Array_sizeContext {
	var p = new(Array_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_size
	return p
}

func (*Array_sizeContext) IsArray_sizeContext() {}

func NewArray_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_sizeContext {
	var p = new(Array_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_size

	return p
}

func (s *Array_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_sizeContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Array_sizeContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Array_sizeContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Array_sizeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOTDOT, 0)
}

func (s *Array_sizeContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Array_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_size(s)
	}
}

func (s *Array_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_size(s)
	}
}

func (p *SyslParser) Array_size() (localctx IArray_sizeContext) {
	localctx = NewArray_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SyslParserRULE_array_size)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(510)
		p.Match(SyslParserDIGITS)
	}
	{
		p.SetState(511)
		p.Match(SyslParserDOTDOT)
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDIGITS {
		{
			p.SetState(512)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(515)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IInplace_tupleContext is an interface to support dynamic dispatch.
type IInplace_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tupleContext differentiates from other interfaces.
	IsInplace_tupleContext()
}

type Inplace_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tupleContext() *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_tuple
	return p
}

func (*Inplace_tupleContext) IsInplace_tupleContext() {}

func NewInplace_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_tuple

	return p
}

func (s *Inplace_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tupleContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_tupleContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_tupleContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Inplace_tupleContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Inplace_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_tuple(s)
	}
}

func (s *Inplace_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_tuple(s)
	}
}

func (p *SyslParser) Inplace_tuple() (localctx IInplace_tupleContext) {
	localctx = NewInplace_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SyslParserRULE_inplace_tuple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		p.Match(SyslParserINDENT)
	}
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
		{
			p.SetState(518)
			p.Field()
		}

		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(523)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field
	return p
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *FieldContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *FieldContext) Field_type() IField_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IField_typeContext)
}

func (s *FieldContext) Inplace_tuple() IInplace_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_tupleContext)
}

func (s *FieldContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *FieldContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField(s)
	}
}

func (p *SyslParser) Field() (localctx IFieldContext) {
	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SyslParserRULE_field)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(525)
		p.Name_str()
	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserLESS_COLON || _la == SyslParserOPEN_PAREN {
		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(526)
				p.Array_size()
			}

		}
		{
			p.SetState(529)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(532)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserTEXT_LINE, SyslParserName, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF, SyslParserE_Name:
			{
				p.SetState(530)
				p.Field_type()
			}

		case SyslParserINDENT:
			{
				p.SetState(531)
				p.Inplace_tuple()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(535)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(534)
				p.Match(SyslParserQSTRING)
			}

		}

	}

	return localctx
}

// IInplace_tableContext is an interface to support dynamic dispatch.
type IInplace_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tableContext differentiates from other interfaces.
	IsInplace_tableContext()
}

type Inplace_tableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tableContext() *Inplace_tableContext {
	var p = new(Inplace_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table
	return p
}

func (*Inplace_tableContext) IsInplace_tableContext() {}

func NewInplace_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tableContext {
	var p = new(Inplace_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table

	return p
}

func (s *Inplace_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tableContext) Table() ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *Inplace_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table(s)
	}
}

func (s *Inplace_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table(s)
	}
}

func (p *SyslParser) Inplace_table() (localctx IInplace_tableContext) {
	localctx = NewInplace_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SyslParserRULE_inplace_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.Table()
	}

	return localctx
}

// ITable_stmtsContext is an interface to support dynamic dispatch.
type ITable_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_stmtsContext differentiates from other interfaces.
	IsTable_stmtsContext()
}

type Table_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_stmtsContext() *Table_stmtsContext {
	var p = new(Table_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_stmts
	return p
}

func (*Table_stmtsContext) IsTable_stmtsContext() {}

func NewTable_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_stmtsContext {
	var p = new(Table_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_stmts

	return p
}

func (s *Table_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_stmtsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Table_stmtsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Table_stmtsContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *Table_stmtsContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *Table_stmtsContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Table_stmtsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *Table_stmtsContext) AllInplace_table() []IInplace_tableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem())
	var tst = make([]IInplace_tableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInplace_tableContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Inplace_table(i int) IInplace_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInplace_tableContext)
}

func (s *Table_stmtsContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *Table_stmtsContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *Table_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_stmts(s)
	}
}

func (s *Table_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_stmts(s)
	}
}

func (p *SyslParser) Table_stmts() (localctx ITable_stmtsContext) {
	localctx = NewTable_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SyslParserRULE_table_stmts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(SyslParserINDENT)
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserWHATEVER))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(542)
				p.Match(SyslParserSYSL_COMMENT)
			}

		case 2:
			{
				p.SetState(543)
				p.Field()
			}

		case 3:
			{
				p.SetState(544)
				p.Annotation()
			}

		case 4:
			{
				p.SetState(545)
				p.Inplace_table()
			}

		case 5:
			{
				p.SetState(546)
				p.Match(SyslParserWHATEVER)
			}

		}

		p.SetState(549)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(551)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ITable_defContext is an interface to support dynamic dispatch.
type ITable_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_defContext differentiates from other interfaces.
	IsTable_defContext()
}

type Table_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_defContext() *Table_defContext {
	var p = new(Table_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_def
	return p
}

func (*Table_defContext) IsTable_defContext() {}

func NewTable_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_defContext {
	var p = new(Table_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_def

	return p
}

func (s *Table_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Table_defContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Table_defContext) Table_stmts() ITable_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_stmtsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_stmtsContext)
}

func (s *Table_defContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Table_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_def(s)
	}
}

func (s *Table_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_def(s)
	}
}

func (p *SyslParser) Table_def() (localctx ITable_defContext) {
	localctx = NewTable_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SyslParserRULE_table_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(553)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(556)
		p.Match(SyslParserCOLON)
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(557)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(558)
			p.Table_stmts()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table
	return p
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *TableContext) Table_def() ITable_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_defContext)
}

func (s *TableContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *TableContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *TableContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *SyslParser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SyslParserRULE_table)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(564)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(561)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(566)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(567)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTABLE || _la == SyslParserTYPE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(568)
		p.Name_str()
	}
	{
		p.SetState(569)
		p.Table_def()
	}

	return localctx
}

// IUnionContext is an interface to support dynamic dispatch.
type IUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionContext differentiates from other interfaces.
	IsUnionContext()
}

type UnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionContext() *UnionContext {
	var p = new(UnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_union
	return p
}

func (*UnionContext) IsUnionContext() {}

func NewUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionContext {
	var p = new(UnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_union

	return p
}

func (s *UnionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *UnionContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *UnionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *UnionContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *UnionContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *UnionContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *UnionContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *UnionContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *UnionContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *UnionContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *UnionContext) AllUser_defined_type() []IUser_defined_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem())
	var tst = make([]IUser_defined_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUser_defined_typeContext)
		}
	}

	return tst
}

func (s *UnionContext) User_defined_type(i int) IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *UnionContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *UnionContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnion(s)
	}
}

func (s *UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnion(s)
	}
}

func (p *SyslParser) Union() (localctx IUnionContext) {
	localctx = NewUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SyslParserRULE_union)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(571)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(577)
		p.Match(SyslParserUNION)
	}
	{
		p.SetState(578)
		p.Name_str()
	}
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(579)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(582)
		p.Match(SyslParserCOLON)
	}
	p.SetState(594)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(583)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(584)
			p.Match(SyslParserINDENT)
		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserWHATEVER || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
			p.SetState(589)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserSYSL_COMMENT:
				{
					p.SetState(585)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(586)
					p.User_defined_type()
				}

			case SyslParserAT:
				{
					p.SetState(587)
					p.Annotation()
				}

			case SyslParserWHATEVER:
				{
					p.SetState(588)
					p.Match(SyslParserWHATEVER)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(591)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(593)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPackage_nameContext is an interface to support dynamic dispatch.
type IPackage_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_nameContext differentiates from other interfaces.
	IsPackage_nameContext()
}

type Package_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_nameContext() *Package_nameContext {
	var p = new(Package_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_package_name
	return p
}

func (*Package_nameContext) IsPackage_nameContext() {}

func NewPackage_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_nameContext {
	var p = new(Package_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_package_name

	return p
}

func (s *Package_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_nameContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Package_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPackage_name(s)
	}
}

func (s *Package_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPackage_name(s)
	}
}

func (p *SyslParser) Package_name() (localctx IPackage_nameContext) {
	localctx = NewPackage_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SyslParserRULE_package_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Name_str()
	}

	return localctx
}

// ISub_packageContext is an interface to support dynamic dispatch.
type ISub_packageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSub_packageContext differentiates from other interfaces.
	IsSub_packageContext()
}

type Sub_packageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySub_packageContext() *Sub_packageContext {
	var p = new(Sub_packageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sub_package
	return p
}

func (*Sub_packageContext) IsSub_packageContext() {}

func NewSub_packageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sub_packageContext {
	var p = new(Sub_packageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sub_package

	return p
}

func (s *Sub_packageContext) GetParser() antlr.Parser { return s.parser }

func (s *Sub_packageContext) NAME_SEP() antlr.TerminalNode {
	return s.GetToken(SyslParserNAME_SEP, 0)
}

func (s *Sub_packageContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *Sub_packageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sub_packageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sub_packageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSub_package(s)
	}
}

func (s *Sub_packageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSub_package(s)
	}
}

func (p *SyslParser) Sub_package() (localctx ISub_packageContext) {
	localctx = NewSub_packageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SyslParserRULE_sub_package)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.Match(SyslParserNAME_SEP)
	}
	{
		p.SetState(599)
		p.Package_name()
	}

	return localctx
}

// IApp_nameContext is an interface to support dynamic dispatch.
type IApp_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApp_nameContext differentiates from other interfaces.
	IsApp_nameContext()
}

type App_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApp_nameContext() *App_nameContext {
	var p = new(App_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_name
	return p
}

func (*App_nameContext) IsApp_nameContext() {}

func NewApp_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_nameContext {
	var p = new(App_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_name

	return p
}

func (s *App_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *App_nameContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *App_nameContext) AllSub_package() []ISub_packageContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISub_packageContext)(nil)).Elem())
	var tst = make([]ISub_packageContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISub_packageContext)
		}
	}

	return tst
}

func (s *App_nameContext) Sub_package(i int) ISub_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISub_packageContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISub_packageContext)
}

func (s *App_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_name(s)
	}
}

func (s *App_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_name(s)
	}
}

func (p *SyslParser) App_name() (localctx IApp_nameContext) {
	localctx = NewApp_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SyslParserRULE_app_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(601)
		p.Package_name()
	}
	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(602)
				p.Sub_package()
			}

		}
		p.SetState(607)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())
	}

	return localctx
}

// IName_with_attribsContext is an interface to support dynamic dispatch.
type IName_with_attribsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_with_attribsContext differentiates from other interfaces.
	IsName_with_attribsContext()
}

type Name_with_attribsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_with_attribsContext() *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_with_attribs
	return p
}

func (*Name_with_attribsContext) IsName_with_attribsContext() {}

func NewName_with_attribsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_with_attribs

	return p
}

func (s *Name_with_attribsContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_with_attribsContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Name_with_attribsContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Name_with_attribsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Name_with_attribsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_with_attribsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_with_attribsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_with_attribs(s)
	}
}

func (s *Name_with_attribsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_with_attribs(s)
	}
}

func (p *SyslParser) Name_with_attribs() (localctx IName_with_attribsContext) {
	localctx = NewName_with_attribsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SyslParserRULE_name_with_attribs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.App_name()
	}
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQSTRING {
		{
			p.SetState(609)
			p.Match(SyslParserQSTRING)
		}

	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(612)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IModel_nameContext is an interface to support dynamic dispatch.
type IModel_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_nameContext differentiates from other interfaces.
	IsModel_nameContext()
}

type Model_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_nameContext() *Model_nameContext {
	var p = new(Model_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_model_name
	return p
}

func (*Model_nameContext) IsModel_nameContext() {}

func NewModel_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_nameContext {
	var p = new(Model_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_model_name

	return p
}

func (s *Model_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_nameContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Model_nameContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Model_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModel_name(s)
	}
}

func (s *Model_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModel_name(s)
	}
}

func (p *SyslParser) Model_name() (localctx IModel_nameContext) {
	localctx = NewModel_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SyslParserRULE_model_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Match(SyslParserName)
	}
	{
		p.SetState(616)
		p.Match(SyslParserCOLON)
	}

	return localctx
}

// IInplace_table_defContext is an interface to support dynamic dispatch.
type IInplace_table_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_table_defContext differentiates from other interfaces.
	IsInplace_table_defContext()
}

type Inplace_table_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_table_defContext() *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table_def
	return p
}

func (*Inplace_table_defContext) IsInplace_table_defContext() {}

func NewInplace_table_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table_def

	return p
}

func (s *Inplace_table_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_table_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Inplace_table_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_table_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_table_defContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *Inplace_table_defContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *Inplace_table_defContext) AllAttribs_or_modifiers() []IAttribs_or_modifiersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem())
	var tst = make([]IAttribs_or_modifiersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribs_or_modifiersContext)
		}
	}

	return tst
}

func (s *Inplace_table_defContext) Attribs_or_modifiers(i int) IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Inplace_table_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_table_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_table_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table_def(s)
	}
}

func (s *Inplace_table_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table_def(s)
	}
}

func (p *SyslParser) Inplace_table_def() (localctx IInplace_table_defContext) {
	localctx = NewInplace_table_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SyslParserRULE_inplace_table_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(619)
		p.Match(SyslParserINDENT)
	}
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserName {
		{
			p.SetState(620)
			p.Match(SyslParserName)
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(621)
				p.Attribs_or_modifiers()
			}

		}

		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(628)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ITable_refsContext is an interface to support dynamic dispatch.
type ITable_refsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_refsContext differentiates from other interfaces.
	IsTable_refsContext()
}

type Table_refsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_refsContext() *Table_refsContext {
	var p = new(Table_refsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_refs
	return p
}

func (*Table_refsContext) IsTable_refsContext() {}

func NewTable_refsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_refsContext {
	var p = new(Table_refsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_refs

	return p
}

func (s *Table_refsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_refsContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Table_refsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *Table_refsContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *Table_refsContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *Table_refsContext) Inplace_table_def() IInplace_table_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_table_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_table_defContext)
}

func (s *Table_refsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_refsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_refsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_refs(s)
	}
}

func (s *Table_refsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_refs(s)
	}
}

func (p *SyslParser) Table_refs() (localctx ITable_refsContext) {
	localctx = NewTable_refsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SyslParserRULE_table_refs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(630)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(631)
		p.Match(SyslParserName)
	}
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserCOLON {
		{
			p.SetState(632)
			p.Inplace_table_def()
		}

	}

	return localctx
}

// IFacadeContext is an interface to support dynamic dispatch.
type IFacadeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFacadeContext differentiates from other interfaces.
	IsFacadeContext()
}

type FacadeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFacadeContext() *FacadeContext {
	var p = new(FacadeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_facade
	return p
}

func (*FacadeContext) IsFacadeContext() {}

func NewFacadeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FacadeContext {
	var p = new(FacadeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_facade

	return p
}

func (s *FacadeContext) GetParser() antlr.Parser { return s.parser }

func (s *FacadeContext) WRAP() antlr.TerminalNode {
	return s.GetToken(SyslParserWRAP, 0)
}

func (s *FacadeContext) Model_name() IModel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_nameContext)
}

func (s *FacadeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *FacadeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *FacadeContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *FacadeContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *FacadeContext) AllTable_refs() []ITable_refsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_refsContext)(nil)).Elem())
	var tst = make([]ITable_refsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_refsContext)
		}
	}

	return tst
}

func (s *FacadeContext) Table_refs(i int) ITable_refsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_refsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_refsContext)
}

func (s *FacadeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FacadeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FacadeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFacade(s)
	}
}

func (s *FacadeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFacade(s)
	}
}

func (p *SyslParser) Facade() (localctx IFacadeContext) {
	localctx = NewFacadeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SyslParserRULE_facade)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(635)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(641)
		p.Match(SyslParserWRAP)
	}
	{
		p.SetState(642)
		p.Model_name()
	}
	{
		p.SetState(643)
		p.Match(SyslParserINDENT)
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		{
			p.SetState(644)
			p.Table_refs()
		}

		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(649)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IVar_in_curlyContext is an interface to support dynamic dispatch.
type IVar_in_curlyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_in_curlyContext differentiates from other interfaces.
	IsVar_in_curlyContext()
}

type Var_in_curlyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_in_curlyContext() *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_var_in_curly
	return p
}

func (*Var_in_curlyContext) IsVar_in_curlyContext() {}

func NewVar_in_curlyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_var_in_curly

	return p
}

func (s *Var_in_curlyContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_in_curlyContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Var_in_curlyContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Var_in_curlyContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Var_in_curlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_in_curlyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_in_curlyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterVar_in_curly(s)
	}
}

func (s *Var_in_curlyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitVar_in_curly(s)
	}
}

func (p *SyslParser) Var_in_curly() (localctx IVar_in_curlyContext) {
	localctx = NewVar_in_curlyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SyslParserRULE_var_in_curly)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(652)
		p.Match(SyslParserName)
	}
	{
		p.SetState(653)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IQuery_varContext is an interface to support dynamic dispatch.
type IQuery_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_varContext differentiates from other interfaces.
	IsQuery_varContext()
}

type Query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_varContext() *Query_varContext {
	var p = new(Query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_var
	return p
}

func (*Query_varContext) IsQuery_varContext() {}

func NewQuery_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_varContext {
	var p = new(Query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_var

	return p
}

func (s *Query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_varContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Query_varContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Query_varContext) Var_in_curly() IVar_in_curlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_in_curlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_in_curlyContext)
}

func (s *Query_varContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_var(s)
	}
}

func (s *Query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_var(s)
	}
}

func (p *SyslParser) Query_var() (localctx IQuery_varContext) {
	localctx = NewQuery_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SyslParserRULE_query_var)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.Match(SyslParserName)
	}
	{
		p.SetState(656)
		p.Match(SyslParserEQ)
	}
	p.SetState(660)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(657)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(658)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(659)
			p.Var_in_curly()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(662)
			p.Match(SyslParserQN)
		}

	}

	return localctx
}

// IQuery_paramContext is an interface to support dynamic dispatch.
type IQuery_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_paramContext differentiates from other interfaces.
	IsQuery_paramContext()
}

type Query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_paramContext() *Query_paramContext {
	var p = new(Query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_param
	return p
}

func (*Query_paramContext) IsQuery_paramContext() {}

func NewQuery_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_paramContext {
	var p = new(Query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_param

	return p
}

func (s *Query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_paramContext) AllQuery_var() []IQuery_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuery_varContext)(nil)).Elem())
	var tst = make([]IQuery_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuery_varContext)
		}
	}

	return tst
}

func (s *Query_paramContext) Query_var(i int) IQuery_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuery_varContext)
}

func (s *Query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_param(s)
	}
}

func (s *Query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_param(s)
	}
}

func (p *SyslParser) Query_param() (localctx IQuery_paramContext) {
	localctx = NewQuery_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SyslParserRULE_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(665)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(666)
		p.Query_var()
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(667)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(668)
			p.Query_var()
		}

		p.SetState(673)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHttp_path_partContext is an interface to support dynamic dispatch.
type IHttp_path_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_partContext differentiates from other interfaces.
	IsHttp_path_partContext()
}

type Http_path_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_partContext() *Http_path_partContext {
	var p = new(Http_path_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_part
	return p
}

func (*Http_path_partContext) IsHttp_path_partContext() {}

func NewHttp_path_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_partContext {
	var p = new(Http_path_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_part

	return p
}

func (s *Http_path_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_partContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Http_path_partContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *Http_path_partContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *Http_path_partContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(SyslParserEQ)
}

func (s *Http_path_partContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, i)
}

func (s *Http_path_partContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Http_path_partContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Http_path_partContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, 0)
}

func (s *Http_path_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_part(s)
	}
}

func (s *Http_path_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_part(s)
	}
}

func (p *SyslParser) Http_path_part() (localctx IHttp_path_partContext) {
	localctx = NewHttp_path_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SyslParserRULE_http_path_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(691)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(674)
			p.Name_str()
		}
		p.SetState(688)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQN {
			{
				p.SetState(675)
				p.Match(SyslParserQN)
			}
			{
				p.SetState(676)
				p.Match(SyslParserName)
			}
			{
				p.SetState(677)
				p.Match(SyslParserEQ)
			}
			{
				p.SetState(678)
				p.Match(SyslParserName)
			}
			p.SetState(685)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SyslParserAMP {
				{
					p.SetState(679)
					p.Match(SyslParserAMP)
				}
				{
					p.SetState(680)
					p.Match(SyslParserName)
				}
				{
					p.SetState(681)
					p.Match(SyslParserEQ)
				}
				{
					p.SetState(682)
					p.Match(SyslParserName)
				}

				p.SetState(687)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	case SyslParserDIGITS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(690)
			p.Match(SyslParserDIGITS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_path_var_with_typeContext is an interface to support dynamic dispatch.
type IHttp_path_var_with_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_var_with_typeContext differentiates from other interfaces.
	IsHttp_path_var_with_typeContext()
}

type Http_path_var_with_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_var_with_typeContext() *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_var_with_type
	return p
}

func (*Http_path_var_with_typeContext) IsHttp_path_var_with_typeContext() {}

func NewHttp_path_var_with_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_var_with_type

	return p
}

func (s *Http_path_var_with_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_var_with_typeContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Http_path_var_with_typeContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_var_with_typeContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Http_path_var_with_typeContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Http_path_var_with_typeContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Http_path_var_with_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_var_with_typeContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *Http_path_var_with_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_var_with_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_var_with_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_var_with_type(s)
	}
}

func (s *Http_path_var_with_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_var_with_type(s)
	}
}

func (p *SyslParser) Http_path_var_with_type() (localctx IHttp_path_var_with_typeContext) {
	localctx = NewHttp_path_var_with_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SyslParserRULE_http_path_var_with_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(694)
		p.Http_path_part()
	}
	{
		p.SetState(695)
		p.Match(SyslParserLESS_COLON)
	}
	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(696)
			p.Match(SyslParserNativeDataTypes)
		}

	case 2:
		{
			p.SetState(697)
			p.Name_str()
		}

	case 3:
		{
			p.SetState(698)
			p.Reference()
		}

	}
	{
		p.SetState(701)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IHttp_path_staticContext is an interface to support dynamic dispatch.
type IHttp_path_staticContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_staticContext differentiates from other interfaces.
	IsHttp_path_staticContext()
}

type Http_path_staticContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_staticContext() *Http_path_staticContext {
	var p = new(Http_path_staticContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_static
	return p
}

func (*Http_path_staticContext) IsHttp_path_staticContext() {}

func NewHttp_path_staticContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_staticContext {
	var p = new(Http_path_staticContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_static

	return p
}

func (s *Http_path_staticContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_staticContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_staticContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_staticContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_staticContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_static(s)
	}
}

func (s *Http_path_staticContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_static(s)
	}
}

func (p *SyslParser) Http_path_static() (localctx IHttp_path_staticContext) {
	localctx = NewHttp_path_staticContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SyslParserRULE_http_path_static)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.Http_path_part()
	}

	return localctx
}

// IHttp_path_suffixContext is an interface to support dynamic dispatch.
type IHttp_path_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_suffixContext differentiates from other interfaces.
	IsHttp_path_suffixContext()
}

type Http_path_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_suffixContext() *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_suffix
	return p
}

func (*Http_path_suffixContext) IsHttp_path_suffixContext() {}

func NewHttp_path_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_suffix

	return p
}

func (s *Http_path_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_suffixContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_path_suffixContext) Http_path_static() IHttp_path_staticContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_staticContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_staticContext)
}

func (s *Http_path_suffixContext) Http_path_var_with_type() IHttp_path_var_with_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_var_with_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_var_with_typeContext)
}

func (s *Http_path_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_suffix(s)
	}
}

func (s *Http_path_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_suffix(s)
	}
}

func (p *SyslParser) Http_path_suffix() (localctx IHttp_path_suffixContext) {
	localctx = NewHttp_path_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SyslParserRULE_http_path_suffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		p.Match(SyslParserFORWARD_SLASH)
	}
	p.SetState(708)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDIGITS, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(706)
			p.Http_path_static()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(707)
			p.Http_path_var_with_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_pathContext is an interface to support dynamic dispatch.
type IHttp_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_pathContext differentiates from other interfaces.
	IsHttp_pathContext()
}

type Http_pathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_pathContext() *Http_pathContext {
	var p = new(Http_pathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path
	return p
}

func (*Http_pathContext) IsHttp_pathContext() {}

func NewHttp_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_pathContext {
	var p = new(Http_pathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path

	return p
}

func (s *Http_pathContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_pathContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_pathContext) AllHttp_path_suffix() []IHttp_path_suffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem())
	var tst = make([]IHttp_path_suffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHttp_path_suffixContext)
		}
	}

	return tst
}

func (s *Http_pathContext) Http_path_suffix(i int) IHttp_path_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_suffixContext)
}

func (s *Http_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path(s)
	}
}

func (s *Http_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path(s)
	}
}

func (p *SyslParser) Http_path() (localctx IHttp_pathContext) {
	localctx = NewHttp_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SyslParserRULE_http_path)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(710)
			p.Match(SyslParserFORWARD_SLASH)
		}

	case 2:
		p.SetState(712)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
			{
				p.SetState(711)
				p.Http_path_suffix()
			}

			p.SetState(714)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEndpoint_nameContext is an interface to support dynamic dispatch.
type IEndpoint_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndpoint_nameContext differentiates from other interfaces.
	IsEndpoint_nameContext()
}

type Endpoint_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpoint_nameContext() *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_endpoint_name
	return p
}

func (*Endpoint_nameContext) IsEndpoint_nameContext() {}

func NewEndpoint_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_endpoint_name

	return p
}

func (s *Endpoint_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Endpoint_nameContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Endpoint_nameContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Endpoint_nameContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Endpoint_nameContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Endpoint_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Endpoint_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Endpoint_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEndpoint_name(s)
	}
}

func (s *Endpoint_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEndpoint_name(s)
	}
}

func (p *SyslParser) Endpoint_name() (localctx IEndpoint_nameContext) {
	localctx = NewEndpoint_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SyslParserRULE_endpoint_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.Name_str()
	}
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(719)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(720)
			p.Name_str()
		}

		p.SetState(725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRet_stmtContext is an interface to support dynamic dispatch.
type IRet_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRet_stmtContext differentiates from other interfaces.
	IsRet_stmtContext()
}

type Ret_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRet_stmtContext() *Ret_stmtContext {
	var p = new(Ret_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ret_stmt
	return p
}

func (*Ret_stmtContext) IsRet_stmtContext() {}

func NewRet_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ret_stmtContext {
	var p = new(Ret_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ret_stmt

	return p
}

func (s *Ret_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Ret_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SyslParserRETURN, 0)
}

func (s *Ret_stmtContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Ret_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ret_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ret_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRet_stmt(s)
	}
}

func (s *Ret_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRet_stmt(s)
	}
}

func (p *SyslParser) Ret_stmt() (localctx IRet_stmtContext) {
	localctx = NewRet_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SyslParserRULE_ret_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Match(SyslParserRETURN)
	}
	{
		p.SetState(727)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target
	return p
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget(s)
	}
}

func (s *TargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget(s)
	}
}

func (p *SyslParser) Target() (localctx ITargetContext) {
	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SyslParserRULE_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.App_name()
	}

	return localctx
}

// ITarget_endpointContext is an interface to support dynamic dispatch.
type ITarget_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTarget_endpointContext differentiates from other interfaces.
	IsTarget_endpointContext()
}

type Target_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTarget_endpointContext() *Target_endpointContext {
	var p = new(Target_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target_endpoint
	return p
}

func (*Target_endpointContext) IsTarget_endpointContext() {}

func NewTarget_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Target_endpointContext {
	var p = new(Target_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target_endpoint

	return p
}

func (s *Target_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Target_endpointContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Target_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Target_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget_endpoint(s)
	}
}

func (s *Target_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget_endpoint(s)
	}
}

func (p *SyslParser) Target_endpoint() (localctx ITarget_endpointContext) {
	localctx = NewTarget_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SyslParserRULE_target_endpoint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.Name_str()
	}

	return localctx
}

// ICall_argContext is an interface to support dynamic dispatch.
type ICall_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argContext differentiates from other interfaces.
	IsCall_argContext()
}

type Call_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argContext() *Call_argContext {
	var p = new(Call_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_arg
	return p
}

func (*Call_argContext) IsCall_argContext() {}

func NewCall_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argContext {
	var p = new(Call_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_arg

	return p
}

func (s *Call_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *Call_argContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *Call_argContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Call_argContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Call_argContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Call_argContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Call_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_arg(s)
	}
}

func (s *Call_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_arg(s)
	}
}

func (p *SyslParser) Call_arg() (localctx ICall_argContext) {
	localctx = NewCall_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SyslParserRULE_call_arg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(745)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(SyslParserQSTRING-60))|(1<<(SyslParserTEXT_LINE-60))|(1<<(SyslParserName-60)))) != 0) || _la == SyslParserE_Name {
			p.SetState(735)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserQSTRING:
				{
					p.SetState(733)
					p.Match(SyslParserQSTRING)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(734)
					p.Name_str()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(737)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.Name_str()
		}
		{
			p.SetState(740)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(741)
				p.Name_str()
			}

		case SyslParserNativeDataTypes:
			{
				p.SetState(742)
				p.Match(SyslParserNativeDataTypes)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ICall_argsContext is an interface to support dynamic dispatch.
type ICall_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argsContext differentiates from other interfaces.
	IsCall_argsContext()
}

type Call_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argsContext() *Call_argsContext {
	var p = new(Call_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_args
	return p
}

func (*Call_argsContext) IsCall_argsContext() {}

func NewCall_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argsContext {
	var p = new(Call_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_args

	return p
}

func (s *Call_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Call_argsContext) AllCall_arg() []ICall_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICall_argContext)(nil)).Elem())
	var tst = make([]ICall_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICall_argContext)
		}
	}

	return tst
}

func (s *Call_argsContext) Call_arg(i int) ICall_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICall_argContext)
}

func (s *Call_argsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Call_argsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Call_argsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Call_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_args(s)
	}
}

func (s *Call_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_args(s)
	}
}

func (p *SyslParser) Call_args() (localctx ICall_argsContext) {
	localctx = NewCall_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SyslParserRULE_call_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(748)
		p.Call_arg()
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(749)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(750)
			p.Call_arg()
		}

		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(756)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// ICall_stmtContext is an interface to support dynamic dispatch.
type ICall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_stmtContext differentiates from other interfaces.
	IsCall_stmtContext()
}

type Call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_stmtContext() *Call_stmtContext {
	var p = new(Call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_stmt
	return p
}

func (*Call_stmtContext) IsCall_stmtContext() {}

func NewCall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_stmtContext {
	var p = new(Call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_stmt

	return p
}

func (s *Call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Call_stmtContext) DOT_ARROW() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT_ARROW, 0)
}

func (s *Call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Call_stmtContext) Call_args() ICall_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_argsContext)
}

func (s *Call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_stmt(s)
	}
}

func (s *Call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_stmt(s)
	}
}

func (p *SyslParser) Call_stmt() (localctx ICall_stmtContext) {
	localctx = NewCall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SyslParserRULE_call_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(762)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDOT_ARROW:
		{
			p.SetState(758)
			p.Match(SyslParserDOT_ARROW)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(759)
			p.Target()
		}
		{
			p.SetState(760)
			p.Match(SyslParserARROW_LEFT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(764)
		p.Target_endpoint()
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(765)
			p.Call_args()
		}

	}

	return localctx
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_stmt
	return p
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SyslParserIF, 0)
}

func (s *If_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *If_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *If_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *SyslParser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SyslParserRULE_if_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(SyslParserIF)
	}
	{
		p.SetState(769)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(770)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(771)
		p.Match(SyslParserINDENT)
	}
	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserPIPE-46))|(1<<(SyslParserQSTRING-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(772)
			p.Statements()
		}

		p.SetState(777)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(778)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IElse_stmtContext is an interface to support dynamic dispatch.
type IElse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_stmtContext differentiates from other interfaces.
	IsElse_stmtContext()
}

type Else_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_stmtContext() *Else_stmtContext {
	var p = new(Else_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_stmt
	return p
}

func (*Else_stmtContext) IsElse_stmtContext() {}

func NewElse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_stmtContext {
	var p = new(Else_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_stmt

	return p
}

func (s *Else_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserELSE, 0)
}

func (s *Else_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Else_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Else_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Else_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *Else_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Else_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Else_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_stmt(s)
	}
}

func (s *Else_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_stmt(s)
	}
}

func (p *SyslParser) Else_stmt() (localctx IElse_stmtContext) {
	localctx = NewElse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SyslParserRULE_else_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(SyslParserELSE)
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserPREDICATE_VALUE {
		{
			p.SetState(781)
			p.Match(SyslParserPREDICATE_VALUE)
		}

	}
	{
		p.SetState(784)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(785)
		p.Match(SyslParserINDENT)
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserPIPE-46))|(1<<(SyslParserQSTRING-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(786)
			p.Statements()
		}

		p.SetState(791)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(792)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IIf_elseContext is an interface to support dynamic dispatch.
type IIf_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_elseContext differentiates from other interfaces.
	IsIf_elseContext()
}

type If_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_elseContext() *If_elseContext {
	var p = new(If_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_else
	return p
}

func (*If_elseContext) IsIf_elseContext() {}

func NewIf_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_elseContext {
	var p = new(If_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_else

	return p
}

func (s *If_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *If_elseContext) If_stmt() IIf_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *If_elseContext) AllElse_stmt() []IElse_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem())
	var tst = make([]IElse_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElse_stmtContext)
		}
	}

	return tst
}

func (s *If_elseContext) Else_stmt(i int) IElse_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElse_stmtContext)
}

func (s *If_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_else(s)
	}
}

func (s *If_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_else(s)
	}
}

func (p *SyslParser) If_else() (localctx IIf_elseContext) {
	localctx = NewIf_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SyslParserRULE_if_else)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(794)
		p.If_stmt()
	}
	p.SetState(798)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserELSE {
		{
			p.SetState(795)
			p.Else_stmt()
		}

		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_for_stmt
	return p
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *For_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *For_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *For_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *For_stmtContext) ALT() antlr.TerminalNode {
	return s.GetToken(SyslParserALT, 0)
}

func (s *For_stmtContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(SyslParserUNTIL, 0)
}

func (s *For_stmtContext) FOR_EACH() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR_EACH, 0)
}

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR, 0)
}

func (s *For_stmtContext) LOOP() antlr.TerminalNode {
	return s.GetToken(SyslParserLOOP, 0)
}

func (s *For_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(SyslParserWHILE, 0)
}

func (s *For_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *For_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (p *SyslParser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SyslParserRULE_for_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(801)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(802)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(803)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(804)
		p.Match(SyslParserINDENT)
	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserPIPE-46))|(1<<(SyslParserQSTRING-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(805)
			p.Statements()
		}

		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(811)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IHttp_method_commentContext is an interface to support dynamic dispatch.
type IHttp_method_commentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_method_commentContext differentiates from other interfaces.
	IsHttp_method_commentContext()
}

type Http_method_commentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_method_commentContext() *Http_method_commentContext {
	var p = new(Http_method_commentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_method_comment
	return p
}

func (*Http_method_commentContext) IsHttp_method_commentContext() {}

func NewHttp_method_commentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_method_commentContext {
	var p = new(Http_method_commentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_method_comment

	return p
}

func (s *Http_method_commentContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_method_commentContext) SYSL_COMMENT() antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, 0)
}

func (s *Http_method_commentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_method_commentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_method_commentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_method_comment(s)
	}
}

func (s *Http_method_commentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_method_comment(s)
	}
}

func (p *SyslParser) Http_method_comment() (localctx IHttp_method_commentContext) {
	localctx = NewHttp_method_commentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SyslParserRULE_http_method_comment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(813)
		p.Match(SyslParserSYSL_COMMENT)
	}

	return localctx
}

// IGroup_stmtContext is an interface to support dynamic dispatch.
type IGroup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_stmtContext differentiates from other interfaces.
	IsGroup_stmtContext()
}

type Group_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_stmtContext() *Group_stmtContext {
	var p = new(Group_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_group_stmt
	return p
}

func (*Group_stmtContext) IsGroup_stmtContext() {}

func NewGroup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_stmtContext {
	var p = new(Group_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_group_stmt

	return p
}

func (s *Group_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Group_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Group_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Group_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Group_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Group_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Group_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterGroup_stmt(s)
	}
}

func (s *Group_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitGroup_stmt(s)
	}
}

func (p *SyslParser) Group_stmt() (localctx IGroup_stmtContext) {
	localctx = NewGroup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SyslParserRULE_group_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(815)
		p.Name_str()
	}
	{
		p.SetState(816)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(817)
		p.Match(SyslParserINDENT)
	}
	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserPIPE-46))|(1<<(SyslParserQSTRING-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(818)
			p.Statements()
		}

		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(823)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_case_labelContext is an interface to support dynamic dispatch.
type IOne_of_case_labelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_case_labelContext differentiates from other interfaces.
	IsOne_of_case_labelContext()
}

type One_of_case_labelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_case_labelContext() *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_case_label
	return p
}

func (*One_of_case_labelContext) IsOne_of_case_labelContext() {}

func NewOne_of_case_labelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_case_label

	return p
}

func (s *One_of_case_labelContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_case_labelContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *One_of_case_labelContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *One_of_case_labelContext) AllTEXT_LINE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserTEXT_LINE)
}

func (s *One_of_case_labelContext) TEXT_LINE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, i)
}

func (s *One_of_case_labelContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *One_of_case_labelContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *One_of_case_labelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_case_labelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_case_labelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_case_label(s)
	}
}

func (s *One_of_case_labelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_case_label(s)
	}
}

func (p *SyslParser) One_of_case_label() (localctx IOne_of_case_labelContext) {
	localctx = NewOne_of_case_labelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SyslParserRULE_one_of_case_label)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(SyslParserQSTRING-60))|(1<<(SyslParserTEXT_LINE-60))|(1<<(SyslParserName-60)))) != 0) {
		p.SetState(825)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(SyslParserQSTRING-60))|(1<<(SyslParserTEXT_LINE-60))|(1<<(SyslParserName-60)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOne_of_casesContext is an interface to support dynamic dispatch.
type IOne_of_casesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_casesContext differentiates from other interfaces.
	IsOne_of_casesContext()
}

type One_of_casesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_casesContext() *One_of_casesContext {
	var p = new(One_of_casesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_cases
	return p
}

func (*One_of_casesContext) IsOne_of_casesContext() {}

func NewOne_of_casesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_casesContext {
	var p = new(One_of_casesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_cases

	return p
}

func (s *One_of_casesContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_casesContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_casesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_casesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_casesContext) One_of_case_label() IOne_of_case_labelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_case_labelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_case_labelContext)
}

func (s *One_of_casesContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *One_of_casesContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *One_of_casesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_casesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_casesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_cases(s)
	}
}

func (s *One_of_casesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_cases(s)
	}
}

func (p *SyslParser) One_of_cases() (localctx IOne_of_casesContext) {
	localctx = NewOne_of_casesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SyslParserRULE_one_of_cases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(SyslParserQSTRING-60))|(1<<(SyslParserTEXT_LINE-60))|(1<<(SyslParserName-60)))) != 0 {
		{
			p.SetState(830)
			p.One_of_case_label()
		}

	}
	{
		p.SetState(833)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(834)
		p.Match(SyslParserINDENT)
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserPIPE-46))|(1<<(SyslParserQSTRING-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(835)
			p.Statements()
		}

		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(840)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_stmtContext is an interface to support dynamic dispatch.
type IOne_of_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_stmtContext differentiates from other interfaces.
	IsOne_of_stmtContext()
}

type One_of_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_stmtContext() *One_of_stmtContext {
	var p = new(One_of_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_stmt
	return p
}

func (*One_of_stmtContext) IsOne_of_stmtContext() {}

func NewOne_of_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_stmtContext {
	var p = new(One_of_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_stmt

	return p
}

func (s *One_of_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_stmtContext) ONE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserONE_OF, 0)
}

func (s *One_of_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_stmtContext) AllOne_of_cases() []IOne_of_casesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem())
	var tst = make([]IOne_of_casesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOne_of_casesContext)
		}
	}

	return tst
}

func (s *One_of_stmtContext) One_of_cases(i int) IOne_of_casesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOne_of_casesContext)
}

func (s *One_of_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_stmt(s)
	}
}

func (s *One_of_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_stmt(s)
	}
}

func (p *SyslParser) One_of_stmt() (localctx IOne_of_stmtContext) {
	localctx = NewOne_of_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SyslParserRULE_one_of_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(842)
		p.Match(SyslParserONE_OF)
	}
	{
		p.SetState(843)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(844)
		p.Match(SyslParserINDENT)
	}
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserCOLON-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) {
		{
			p.SetState(845)
			p.One_of_cases()
		}

		p.SetState(848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(850)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IText_stmtContext is an interface to support dynamic dispatch.
type IText_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_stmtContext differentiates from other interfaces.
	IsText_stmtContext()
}

type Text_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_stmtContext() *Text_stmtContext {
	var p = new(Text_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_text_stmt
	return p
}

func (*Text_stmtContext) IsText_stmtContext() {}

func NewText_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_stmtContext {
	var p = new(Text_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_text_stmt

	return p
}

func (s *Text_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_stmtContext) Doc_string() IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Text_stmtContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Text_stmtContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Text_stmtContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Text_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Text_stmtContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Text_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterText_stmt(s)
	}
}

func (s *Text_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitText_stmt(s)
	}
}

func (p *SyslParser) Text_stmt() (localctx IText_stmtContext) {
	localctx = NewText_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SyslParserRULE_text_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(860)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserPIPE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(852)
			p.Doc_string()
		}

	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(853)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(854)
			p.App_name()
		}
		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserARROW_RIGHT {
			{
				p.SetState(855)
				p.Match(SyslParserARROW_RIGHT)
			}
			{
				p.SetState(856)
				p.Name_str()
			}

		}

	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(859)
			p.Match(SyslParserWHATEVER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMixinContext is an interface to support dynamic dispatch.
type IMixinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinContext differentiates from other interfaces.
	IsMixinContext()
}

type MixinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinContext() *MixinContext {
	var p = new(MixinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_mixin
	return p
}

func (*MixinContext) IsMixinContext() {}

func NewMixinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinContext {
	var p = new(MixinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_mixin

	return p
}

func (s *MixinContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinContext) MIXIN() antlr.TerminalNode {
	return s.GetToken(SyslParserMIXIN, 0)
}

func (s *MixinContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *MixinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMixin(s)
	}
}

func (s *MixinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMixin(s)
	}
}

func (p *SyslParser) Mixin() (localctx IMixinContext) {
	localctx = NewMixinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SyslParserRULE_mixin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(862)
		p.Match(SyslParserMIXIN)
	}
	{
		p.SetState(863)
		p.App_name()
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *ParamContext) Field() IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *SyslParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SyslParserRULE_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(865)
			p.Reference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(866)
			p.Field()
		}

	}

	return localctx
}

// IParam_listContext is an interface to support dynamic dispatch.
type IParam_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_listContext differentiates from other interfaces.
	IsParam_listContext()
}

type Param_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_listContext() *Param_listContext {
	var p = new(Param_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param_list
	return p
}

func (*Param_listContext) IsParam_listContext() {}

func NewParam_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_listContext {
	var p = new(Param_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param_list

	return p
}

func (s *Param_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_listContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *Param_listContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *Param_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Param_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Param_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam_list(s)
	}
}

func (s *Param_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam_list(s)
	}
}

func (p *SyslParser) Param_list() (localctx IParam_listContext) {
	localctx = NewParam_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SyslParserRULE_param_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.Param()
	}
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(870)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(871)
			p.Param()
		}

		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamsContext is an interface to support dynamic dispatch.
type IParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamsContext differentiates from other interfaces.
	IsParamsContext()
}

type ParamsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamsContext() *ParamsContext {
	var p = new(ParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_params
	return p
}

func (*ParamsContext) IsParamsContext() {}

func NewParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamsContext {
	var p = new(ParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_params

	return p
}

func (s *ParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ParamsContext) Param_list() IParam_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_listContext)
}

func (s *ParamsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParams(s)
	}
}

func (s *ParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParams(s)
	}
}

func (p *SyslParser) Params() (localctx IParamsContext) {
	localctx = NewParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SyslParserRULE_params)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(878)
		p.Param_list()
	}
	{
		p.SetState(879)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) If_else() IIf_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_elseContext)
}

func (s *StatementsContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *StatementsContext) Ret_stmt() IRet_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRet_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRet_stmtContext)
}

func (s *StatementsContext) Call_stmt() ICall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_stmtContext)
}

func (s *StatementsContext) One_of_stmt() IOne_of_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_stmtContext)
}

func (s *StatementsContext) Http_method_comment() IHttp_method_commentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_method_commentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_method_commentContext)
}

func (s *StatementsContext) Group_stmt() IGroup_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_stmtContext)
}

func (s *StatementsContext) Text_stmt() IText_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_stmtContext)
}

func (s *StatementsContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *SyslParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SyslParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(890)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(881)
			p.If_else()
		}

	case 2:
		{
			p.SetState(882)
			p.For_stmt()
		}

	case 3:
		{
			p.SetState(883)
			p.Ret_stmt()
		}

	case 4:
		{
			p.SetState(884)
			p.Call_stmt()
		}

	case 5:
		{
			p.SetState(885)
			p.One_of_stmt()
		}

	case 6:
		{
			p.SetState(886)
			p.Http_method_comment()
		}

	case 7:
		{
			p.SetState(887)
			p.Group_stmt()
		}

	case 8:
		{
			p.SetState(888)
			p.Text_stmt()
		}

	case 9:
		{
			p.SetState(889)
			p.Annotation()
		}

	}
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(892)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IMethod_defContext is an interface to support dynamic dispatch.
type IMethod_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_defContext differentiates from other interfaces.
	IsMethod_defContext()
}

type Method_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_defContext() *Method_defContext {
	var p = new(Method_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_method_def
	return p
}

func (*Method_defContext) IsMethod_defContext() {}

func NewMethod_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_defContext {
	var p = new(Method_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_method_def

	return p
}

func (s *Method_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_defContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Method_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Method_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Method_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Method_defContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Method_defContext) Query_param() IQuery_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_paramContext)
}

func (s *Method_defContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Method_defContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Method_defContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Method_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMethod_def(s)
	}
}

func (s *Method_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMethod_def(s)
	}
}

func (p *SyslParser) Method_def() (localctx IMethod_defContext) {
	localctx = NewMethod_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SyslParserRULE_method_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.Match(SyslParserHTTP_VERBS)
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(896)
			p.Params()
		}

	}
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(899)
			p.Query_param()
		}

	}
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(902)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(905)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(906)
		p.Match(SyslParserINDENT)
	}
	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserPIPE-46))|(1<<(SyslParserQSTRING-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(907)
			p.Statements()
		}

		p.SetState(910)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(912)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IShortcutContext is an interface to support dynamic dispatch.
type IShortcutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShortcutContext differentiates from other interfaces.
	IsShortcutContext()
}

type ShortcutContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortcutContext() *ShortcutContext {
	var p = new(ShortcutContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_shortcut
	return p
}

func (*ShortcutContext) IsShortcutContext() {}

func NewShortcutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortcutContext {
	var p = new(ShortcutContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_shortcut

	return p
}

func (s *ShortcutContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortcutContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *ShortcutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortcutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortcutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterShortcut(s)
	}
}

func (s *ShortcutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitShortcut(s)
	}
}

func (p *SyslParser) Shortcut() (localctx IShortcutContext) {
	localctx = NewShortcutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SyslParserRULE_shortcut)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Match(SyslParserWHATEVER)
	}

	return localctx
}

// ISimple_endpointContext is an interface to support dynamic dispatch.
type ISimple_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_endpointContext differentiates from other interfaces.
	IsSimple_endpointContext()
}

type Simple_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_endpointContext() *Simple_endpointContext {
	var p = new(Simple_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_simple_endpoint
	return p
}

func (*Simple_endpointContext) IsSimple_endpointContext() {}

func NewSimple_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_endpointContext {
	var p = new(Simple_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_simple_endpoint

	return p
}

func (s *Simple_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_endpointContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Simple_endpointContext) Endpoint_name() IEndpoint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndpoint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndpoint_nameContext)
}

func (s *Simple_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Simple_endpointContext) Shortcut() IShortcutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShortcutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShortcutContext)
}

func (s *Simple_endpointContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Simple_endpointContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Simple_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Simple_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Simple_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Simple_endpointContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Simple_endpointContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Simple_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSimple_endpoint(s)
	}
}

func (s *Simple_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSimple_endpoint(s)
	}
}

func (p *SyslParser) Simple_endpoint() (localctx ISimple_endpointContext) {
	localctx = NewSimple_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SyslParserRULE_simple_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(939)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(916)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(917)
			p.Endpoint_name()
		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(918)
				p.Match(SyslParserQSTRING)
			}

		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(921)
				p.Params()
			}

		}
		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(924)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(927)
			p.Match(SyslParserCOLON)
		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserWHATEVER:
			{
				p.SetState(928)
				p.Shortcut()
			}

		case SyslParserINDENT:
			{
				p.SetState(929)
				p.Match(SyslParserINDENT)
			}
			p.SetState(931)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserPIPE-46))|(1<<(SyslParserQSTRING-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
				{
					p.SetState(930)
					p.Statements()
				}

				p.SetState(933)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(935)
				p.Match(SyslParserDEDENT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRest_endpointContext is an interface to support dynamic dispatch.
type IRest_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRest_endpointContext differentiates from other interfaces.
	IsRest_endpointContext()
}

type Rest_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRest_endpointContext() *Rest_endpointContext {
	var p = new(Rest_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rest_endpoint
	return p
}

func (*Rest_endpointContext) IsRest_endpointContext() {}

func NewRest_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rest_endpointContext {
	var p = new(Rest_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rest_endpoint

	return p
}

func (s *Rest_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Rest_endpointContext) Http_path() IHttp_pathContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_pathContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_pathContext)
}

func (s *Rest_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Rest_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Rest_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Rest_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Rest_endpointContext) AllMethod_def() []IMethod_defContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethod_defContext)(nil)).Elem())
	var tst = make([]IMethod_defContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethod_defContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Method_def(i int) IMethod_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_defContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethod_defContext)
}

func (s *Rest_endpointContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *Rest_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rest_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rest_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRest_endpoint(s)
	}
}

func (s *Rest_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRest_endpoint(s)
	}
}

func (p *SyslParser) Rest_endpoint() (localctx IRest_endpointContext) {
	localctx = NewRest_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SyslParserRULE_rest_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(941)
		p.Http_path()
	}
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(942)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(945)
		p.Match(SyslParserCOLON)
	}

	{
		p.SetState(946)
		p.Match(SyslParserINDENT)
	}
	p.SetState(949)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserFORWARD_SLASH {
		p.SetState(949)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserHTTP_VERBS:
			{
				p.SetState(947)
				p.Method_def()
			}

		case SyslParserFORWARD_SLASH:
			{
				p.SetState(948)
				p.Rest_endpoint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(953)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ICollector_query_varContext is an interface to support dynamic dispatch.
type ICollector_query_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_varContext differentiates from other interfaces.
	IsCollector_query_varContext()
}

type Collector_query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_varContext() *Collector_query_varContext {
	var p = new(Collector_query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_var
	return p
}

func (*Collector_query_varContext) IsCollector_query_varContext() {}

func NewCollector_query_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_varContext {
	var p = new(Collector_query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_var

	return p
}

func (s *Collector_query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_varContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Collector_query_varContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Collector_query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Collector_query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_var(s)
	}
}

func (s *Collector_query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_var(s)
	}
}

func (p *SyslParser) Collector_query_var() (localctx ICollector_query_varContext) {
	localctx = NewCollector_query_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SyslParserRULE_collector_query_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(955)
		p.Name_str()
	}
	{
		p.SetState(956)
		p.Match(SyslParserEQ)
	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(957)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(958)
			p.Name_str()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_query_paramContext is an interface to support dynamic dispatch.
type ICollector_query_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_paramContext differentiates from other interfaces.
	IsCollector_query_paramContext()
}

type Collector_query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_paramContext() *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_param
	return p
}

func (*Collector_query_paramContext) IsCollector_query_paramContext() {}

func NewCollector_query_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_param

	return p
}

func (s *Collector_query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Collector_query_paramContext) AllCollector_query_var() []ICollector_query_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem())
	var tst = make([]ICollector_query_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_query_varContext)
		}
	}

	return tst
}

func (s *Collector_query_paramContext) Collector_query_var(i int) ICollector_query_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_varContext)
}

func (s *Collector_query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Collector_query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Collector_query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_param(s)
	}
}

func (s *Collector_query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_param(s)
	}
}

func (p *SyslParser) Collector_query_param() (localctx ICollector_query_paramContext) {
	localctx = NewCollector_query_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SyslParserRULE_collector_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(961)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(962)
		p.Collector_query_var()
	}
	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(963)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(964)
			p.Collector_query_var()
		}

		p.SetState(969)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICollector_call_stmtContext is an interface to support dynamic dispatch.
type ICollector_call_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_call_stmtContext differentiates from other interfaces.
	IsCollector_call_stmtContext()
}

type Collector_call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_call_stmtContext() *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_call_stmt
	return p
}

func (*Collector_call_stmtContext) IsCollector_call_stmtContext() {}

func NewCollector_call_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_call_stmt

	return p
}

func (s *Collector_call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Collector_call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Collector_call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_call_stmt(s)
	}
}

func (s *Collector_call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_call_stmt(s)
	}
}

func (p *SyslParser) Collector_call_stmt() (localctx ICollector_call_stmtContext) {
	localctx = NewCollector_call_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SyslParserRULE_collector_call_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(970)
		p.Target()
	}
	{
		p.SetState(971)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(972)
		p.Target_endpoint()
	}

	return localctx
}

// ICollector_http_stmt_partContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_partContext differentiates from other interfaces.
	IsCollector_http_stmt_partContext()
}

type Collector_http_stmt_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_partContext() *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part
	return p
}

func (*Collector_http_stmt_partContext) IsCollector_http_stmt_partContext() {}

func NewCollector_http_stmt_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part

	return p
}

func (s *Collector_http_stmt_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_http_stmt_partContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Collector_http_stmt_partContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Collector_http_stmt_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_part(s)
	}
}

func (s *Collector_http_stmt_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_part(s)
	}
}

func (p *SyslParser) Collector_http_stmt_part() (localctx ICollector_http_stmt_partContext) {
	localctx = NewCollector_http_stmt_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SyslParserRULE_collector_http_stmt_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(979)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(974)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(975)
			p.Match(SyslParserCURLY_OPEN)
		}
		{
			p.SetState(976)
			p.Name_str()
		}
		{
			p.SetState(977)
			p.Match(SyslParserCURLY_CLOSE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_http_stmt_suffixContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_suffixContext differentiates from other interfaces.
	IsCollector_http_stmt_suffixContext()
}

type Collector_http_stmt_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_suffixContext() *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix
	return p
}

func (*Collector_http_stmt_suffixContext) IsCollector_http_stmt_suffixContext() {}

func NewCollector_http_stmt_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix

	return p
}

func (s *Collector_http_stmt_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_suffixContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Collector_http_stmt_suffixContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Collector_http_stmt_suffixContext) AllCollector_http_stmt_part() []ICollector_http_stmt_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem())
	var tst = make([]ICollector_http_stmt_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_http_stmt_partContext)
		}
	}

	return tst
}

func (s *Collector_http_stmt_suffixContext) Collector_http_stmt_part(i int) ICollector_http_stmt_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_partContext)
}

func (s *Collector_http_stmt_suffixContext) Collector_query_param() ICollector_query_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_paramContext)
}

func (s *Collector_http_stmt_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_suffix(s)
	}
}

func (s *Collector_http_stmt_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_suffix(s)
	}
}

func (p *SyslParser) Collector_http_stmt_suffix() (localctx ICollector_http_stmt_suffixContext) {
	localctx = NewCollector_http_stmt_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SyslParserRULE_collector_http_stmt_suffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(983)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(981)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(982)
			p.Collector_http_stmt_part()
		}

		p.SetState(985)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(987)
			p.Collector_query_param()
		}

	}

	return localctx
}

// ICollector_http_stmtContext is an interface to support dynamic dispatch.
type ICollector_http_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmtContext differentiates from other interfaces.
	IsCollector_http_stmtContext()
}

type Collector_http_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmtContext() *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt
	return p
}

func (*Collector_http_stmtContext) IsCollector_http_stmtContext() {}

func NewCollector_http_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt

	return p
}

func (s *Collector_http_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmtContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Collector_http_stmtContext) Collector_http_stmt_suffix() ICollector_http_stmt_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_suffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_suffixContext)
}

func (s *Collector_http_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt(s)
	}
}

func (s *Collector_http_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt(s)
	}
}

func (p *SyslParser) Collector_http_stmt() (localctx ICollector_http_stmtContext) {
	localctx = NewCollector_http_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SyslParserRULE_collector_http_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(990)
		p.Match(SyslParserHTTP_VERBS)
	}
	{
		p.SetState(991)
		p.Collector_http_stmt_suffix()
	}

	return localctx
}

// IPublisherContext is an interface to support dynamic dispatch.
type IPublisherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPublisherContext differentiates from other interfaces.
	IsPublisherContext()
}

type PublisherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPublisherContext() *PublisherContext {
	var p = new(PublisherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_publisher
	return p
}

func (*PublisherContext) IsPublisherContext() {}

func NewPublisherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PublisherContext {
	var p = new(PublisherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_publisher

	return p
}

func (s *PublisherContext) GetParser() antlr.Parser { return s.parser }

func (s *PublisherContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *PublisherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PublisherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PublisherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPublisher(s)
	}
}

func (s *PublisherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPublisher(s)
	}
}

func (p *SyslParser) Publisher() (localctx IPublisherContext) {
	localctx = NewPublisherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SyslParserRULE_publisher)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.App_name()
	}

	return localctx
}

// ISubscriberContext is an interface to support dynamic dispatch.
type ISubscriberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriberContext differentiates from other interfaces.
	IsSubscriberContext()
}

type SubscriberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriberContext() *SubscriberContext {
	var p = new(SubscriberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscriber
	return p
}

func (*SubscriberContext) IsSubscriberContext() {}

func NewSubscriberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriberContext {
	var p = new(SubscriberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscriber

	return p
}

func (s *SubscriberContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriberContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscriberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscriber(s)
	}
}

func (s *SubscriberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscriber(s)
	}
}

func (p *SyslParser) Subscriber() (localctx ISubscriberContext) {
	localctx = NewSubscriberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SyslParserRULE_subscriber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.App_name()
	}

	return localctx
}

// ICollector_pubsub_callContext is an interface to support dynamic dispatch.
type ICollector_pubsub_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_pubsub_callContext differentiates from other interfaces.
	IsCollector_pubsub_callContext()
}

type Collector_pubsub_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_pubsub_callContext() *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_pubsub_call
	return p
}

func (*Collector_pubsub_callContext) IsCollector_pubsub_callContext() {}

func NewCollector_pubsub_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_pubsub_call

	return p
}

func (s *Collector_pubsub_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_pubsub_callContext) Subscriber() ISubscriberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriberContext)
}

func (s *Collector_pubsub_callContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_pubsub_callContext) Publisher() IPublisherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPublisherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPublisherContext)
}

func (s *Collector_pubsub_callContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Collector_pubsub_callContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_pubsub_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_pubsub_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_pubsub_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_pubsub_call(s)
	}
}

func (s *Collector_pubsub_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_pubsub_call(s)
	}
}

func (p *SyslParser) Collector_pubsub_call() (localctx ICollector_pubsub_callContext) {
	localctx = NewCollector_pubsub_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SyslParserRULE_collector_pubsub_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Subscriber()
	}
	{
		p.SetState(998)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(999)
		p.Publisher()
	}
	{
		p.SetState(1000)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(1001)
		p.Name_str()
	}

	return localctx
}

// ICollector_action_stmtContext is an interface to support dynamic dispatch.
type ICollector_action_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_action_stmtContext differentiates from other interfaces.
	IsCollector_action_stmtContext()
}

type Collector_action_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_action_stmtContext() *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_action_stmt
	return p
}

func (*Collector_action_stmtContext) IsCollector_action_stmtContext() {}

func NewCollector_action_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_action_stmt

	return p
}

func (s *Collector_action_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_action_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_action_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_action_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_action_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_action_stmt(s)
	}
}

func (s *Collector_action_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_action_stmt(s)
	}
}

func (p *SyslParser) Collector_action_stmt() (localctx ICollector_action_stmtContext) {
	localctx = NewCollector_action_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SyslParserRULE_collector_action_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1003)
		p.Name_str()
	}

	return localctx
}

// ICollector_stmtsContext is an interface to support dynamic dispatch.
type ICollector_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_stmtsContext differentiates from other interfaces.
	IsCollector_stmtsContext()
}

type Collector_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_stmtsContext() *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_stmts
	return p
}

func (*Collector_stmtsContext) IsCollector_stmtsContext() {}

func NewCollector_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_stmts

	return p
}

func (s *Collector_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_stmtsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Collector_stmtsContext) Collector_action_stmt() ICollector_action_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_action_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_action_stmtContext)
}

func (s *Collector_stmtsContext) Collector_call_stmt() ICollector_call_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_call_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_call_stmtContext)
}

func (s *Collector_stmtsContext) Collector_http_stmt() ICollector_http_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmtContext)
}

func (s *Collector_stmtsContext) Collector_pubsub_call() ICollector_pubsub_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_pubsub_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_pubsub_callContext)
}

func (s *Collector_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_stmts(s)
	}
}

func (s *Collector_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_stmts(s)
	}
}

func (p *SyslParser) Collector_stmts() (localctx ICollector_stmtsContext) {
	localctx = NewCollector_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SyslParserRULE_collector_stmts)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1005)
			p.Collector_action_stmt()
		}

	case 2:
		{
			p.SetState(1006)
			p.Collector_call_stmt()
		}

	case 3:
		{
			p.SetState(1007)
			p.Collector_http_stmt()
		}

	case 4:
		{
			p.SetState(1008)
			p.Collector_pubsub_call()
		}

	}
	{
		p.SetState(1011)
		p.Attribs_or_modifiers()
	}

	return localctx
}

// ICollectorContext is an interface to support dynamic dispatch.
type ICollectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectorContext differentiates from other interfaces.
	IsCollectorContext()
}

type CollectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectorContext() *CollectorContext {
	var p = new(CollectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector
	return p
}

func (*CollectorContext) IsCollectorContext() {}

func NewCollectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectorContext {
	var p = new(CollectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector

	return p
}

func (s *CollectorContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectorContext) COLLECTOR() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLLECTOR, 0)
}

func (s *CollectorContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *CollectorContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *CollectorContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *CollectorContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *CollectorContext) AllCollector_stmts() []ICollector_stmtsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem())
	var tst = make([]ICollector_stmtsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_stmtsContext)
		}
	}

	return tst
}

func (s *CollectorContext) Collector_stmts(i int) ICollector_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_stmtsContext)
}

func (s *CollectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector(s)
	}
}

func (s *CollectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector(s)
	}
}

func (p *SyslParser) Collector() (localctx ICollectorContext) {
	localctx = NewCollectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SyslParserRULE_collector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Match(SyslParserCOLLECTOR)
	}
	{
		p.SetState(1014)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1015)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1016)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1018)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
			{
				p.SetState(1017)
				p.Collector_stmts()
			}

			p.SetState(1020)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1022)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEventContext is an interface to support dynamic dispatch.
type IEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventContext differentiates from other interfaces.
	IsEventContext()
}

type EventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventContext() *EventContext {
	var p = new(EventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_event
	return p
}

func (*EventContext) IsEventContext() {}

func NewEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventContext {
	var p = new(EventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_event

	return p
}

func (s *EventContext) GetParser() antlr.Parser { return s.parser }

func (s *EventContext) DISTANCE() antlr.TerminalNode {
	return s.GetToken(SyslParserDISTANCE, 0)
}

func (s *EventContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *EventContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *EventContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *EventContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *EventContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *EventContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *EventContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *EventContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *EventContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *EventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEvent(s)
	}
}

func (s *EventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEvent(s)
	}
}

func (p *SyslParser) Event() (localctx IEventContext) {
	localctx = NewEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SyslParserRULE_event)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Match(SyslParserDISTANCE)
	}
	{
		p.SetState(1027)
		p.Name_str()
	}
	p.SetState(1029)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(1028)
			p.Params()
		}

	}
	p.SetState(1032)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1031)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1034)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1035)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1036)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserPIPE-46))|(1<<(SyslParserQSTRING-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1037)
				p.Statements()
			}

			p.SetState(1040)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1042)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubscribeContext is an interface to support dynamic dispatch.
type ISubscribeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscribeContext differentiates from other interfaces.
	IsSubscribeContext()
}

type SubscribeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscribeContext() *SubscribeContext {
	var p = new(SubscribeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscribe
	return p
}

func (*SubscribeContext) IsSubscribeContext() {}

func NewSubscribeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscribeContext {
	var p = new(SubscribeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscribe

	return p
}

func (s *SubscribeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscribeContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscribeContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *SubscribeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *SubscribeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *SubscribeContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *SubscribeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *SubscribeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *SubscribeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *SubscribeContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *SubscribeContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *SubscribeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscribeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscribeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscribe(s)
	}
}

func (s *SubscribeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscribe(s)
	}
}

func (p *SyslParser) Subscribe() (localctx ISubscribeContext) {
	localctx = NewSubscribeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SyslParserRULE_subscribe)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1046)
		p.App_name()
	}
	{
		p.SetState(1047)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(1048)
		p.Name_str()
	}
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1049)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1052)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1062)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1053)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1054)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SyslParserAT-46))|(1<<(SyslParserPIPE-46))|(1<<(SyslParserQSTRING-46))|(1<<(SyslParserSYSL_COMMENT-46))|(1<<(SyslParserTEXT_LINE-46))|(1<<(SyslParserName-46)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1055)
				p.Statements()
			}

			p.SetState(1058)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1060)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IView_type_specContext is an interface to support dynamic dispatch.
type IView_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_type_specContext differentiates from other interfaces.
	IsView_type_specContext()
}

type View_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_type_specContext() *View_type_specContext {
	var p = new(View_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_type_spec
	return p
}

func (*View_type_specContext) IsView_type_specContext() {}

func NewView_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_type_specContext {
	var p = new(View_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_type_spec

	return p
}

func (s *View_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *View_type_specContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *View_type_specContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *View_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_type_spec(s)
	}
}

func (s *View_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_type_spec(s)
	}
}

func (p *SyslParser) View_type_spec() (localctx IView_type_specContext) {
	localctx = NewView_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SyslParserRULE_view_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1066)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1064)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1065)
			p.Types()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) E_DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIGITS, 0)
}

func (s *LiteralContext) E_DECIMAL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DECIMAL, 0)
}

func (s *LiteralContext) E_STRING_DBL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STRING_DBL, 0)
}

func (s *LiteralContext) E_STRING_SINGLE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STRING_SINGLE, 0)
}

func (s *LiteralContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *LiteralContext) E_TRUE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TRUE, 0)
}

func (s *LiteralContext) E_FALSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FALSE, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *SyslParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SyslParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1068)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(SyslParserE_TRUE-118))|(1<<(SyslParserE_FALSE-118))|(1<<(SyslParserE_NULL-118))|(1<<(SyslParserE_STRING_DBL-118))|(1<<(SyslParserE_STRING_SINGLE-118))|(1<<(SyslParserE_DECIMAL-118))|(1<<(SyslParserE_DIGITS-118)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_table_of_opContext is an interface to support dynamic dispatch.
type IExpr_table_of_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_table_of_opContext differentiates from other interfaces.
	IsExpr_table_of_opContext()
}

type Expr_table_of_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_table_of_opContext() *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_op
	return p
}

func (*Expr_table_of_opContext) IsExpr_table_of_opContext() {}

func NewExpr_table_of_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_op

	return p
}

func (s *Expr_table_of_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_opContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_opContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_NULLSAFE_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULLSAFE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_op(s)
	}
}

func (s *Expr_table_of_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_op(s)
	}
}

func (p *SyslParser) Expr_table_of_op() (localctx IExpr_table_of_opContext) {
	localctx = NewExpr_table_of_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SyslParserRULE_expr_table_of_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1070)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_NULLSAFE_DOT || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_TABLE_OF {
		{
			p.SetState(1071)
			p.Match(SyslParserE_TABLE_OF)
		}

	}
	{
		p.SetState(1074)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IFunc_argContext is an interface to support dynamic dispatch.
type IFunc_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argContext differentiates from other interfaces.
	IsFunc_argContext()
}

type Func_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argContext() *Func_argContext {
	var p = new(Func_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_arg
	return p
}

func (*Func_argContext) IsFunc_argContext() {}

func NewFunc_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argContext {
	var p = new(Func_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_arg

	return p
}

func (s *Func_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_arg(s)
	}
}

func (s *Func_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_arg(s)
	}
}

func (p *SyslParser) Func_arg() (localctx IFunc_argContext) {
	localctx = NewFunc_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SyslParserRULE_func_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1076)
		p.Expr()
	}

	return localctx
}

// IFunc_argsContext is an interface to support dynamic dispatch.
type IFunc_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argsContext differentiates from other interfaces.
	IsFunc_argsContext()
}

type Func_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argsContext() *Func_argsContext {
	var p = new(Func_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_args
	return p
}

func (*Func_argsContext) IsFunc_argsContext() {}

func NewFunc_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argsContext {
	var p = new(Func_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_args

	return p
}

func (s *Func_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argsContext) AllFunc_arg() []IFunc_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunc_argContext)(nil)).Elem())
	var tst = make([]IFunc_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunc_argContext)
		}
	}

	return tst
}

func (s *Func_argsContext) Func_arg(i int) IFunc_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunc_argContext)
}

func (s *Func_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Func_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Func_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_args(s)
	}
}

func (s *Func_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_args(s)
	}
}

func (p *SyslParser) Func_args() (localctx IFunc_argsContext) {
	localctx = NewFunc_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SyslParserRULE_func_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1078)
		p.Func_arg()
	}
	p.SetState(1083)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1079)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1080)
			p.Func_arg()
		}

		p.SetState(1085)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_funcContext is an interface to support dynamic dispatch.
type IExpr_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_funcContext differentiates from other interfaces.
	IsExpr_funcContext()
}

type Expr_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_funcContext() *Expr_funcContext {
	var p = new(Expr_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_func
	return p
}

func (*Expr_funcContext) IsExpr_funcContext() {}

func NewExpr_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_funcContext {
	var p = new(Expr_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_func

	return p
}

func (s *Expr_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_funcContext) E_FUNC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FUNC, 0)
}

func (s *Expr_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_funcContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Expr_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_func(s)
	}
}

func (s *Expr_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_func(s)
	}
}

func (p *SyslParser) Expr_func() (localctx IExpr_funcContext) {
	localctx = NewExpr_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SyslParserRULE_expr_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1086)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserNativeDataTypes || _la == SyslParserE_FUNC || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1087)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1089)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(SyslParserE_WHATEVER-76))|(1<<(SyslParserE_ARROW_RIGHT-76))|(1<<(SyslParserE_SQ_OPEN-76))|(1<<(SyslParserE_EMPTY_TUPLE-76))|(1<<(SyslParserE_CURLY_OPEN-76))|(1<<(SyslParserE_NULLSAFE_DOT-76))|(1<<(SyslParserE_OPEN_PAREN-76))|(1<<(SyslParserE_PLUS-76))|(1<<(SyslParserE_MINUS-76))|(1<<(SyslParserE_QN-76))|(1<<(SyslParserE_TILDE-76))|(1<<(SyslParserE_NOT-76)))) != 0) || (((_la-114)&-(0x1f+1)) == 0 && ((1<<uint((_la-114)))&((1<<(SyslParserE_IF-114))|(1<<(SyslParserE_TRUE-114))|(1<<(SyslParserE_FALSE-114))|(1<<(SyslParserE_NULL-114))|(1<<(SyslParserE_FUNC-114))|(1<<(SyslParserE_STRING_DBL-114))|(1<<(SyslParserE_STRING_SINGLE-114))|(1<<(SyslParserE_DECIMAL-114))|(1<<(SyslParserE_DIGITS-114))|(1<<(SyslParserE_Name-114))|(1<<(SyslParserE_DOT-114)))) != 0) {
		{
			p.SetState(1088)
			p.Func_args()
		}

	}
	{
		p.SetState(1091)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IRank_exprContext is an interface to support dynamic dispatch.
type IRank_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_exprContext differentiates from other interfaces.
	IsRank_exprContext()
}

type Rank_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_exprContext() *Rank_exprContext {
	var p = new(Rank_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr
	return p
}

func (*Rank_exprContext) IsRank_exprContext() {}

func NewRank_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_exprContext {
	var p = new(Rank_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr

	return p
}

func (s *Rank_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Rank_exprContext) E_ASC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ASC, 0)
}

func (s *Rank_exprContext) E_DESC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DESC, 0)
}

func (s *Rank_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr(s)
	}
}

func (s *Rank_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr(s)
	}
}

func (p *SyslParser) Rank_expr() (localctx IRank_exprContext) {
	localctx = NewRank_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SyslParserRULE_rank_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		p.Expr()
	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ASC || _la == SyslParserE_DESC {
		p.SetState(1094)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserE_ASC || _la == SyslParserE_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IRank_expr_listContext is an interface to support dynamic dispatch.
type IRank_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_expr_listContext differentiates from other interfaces.
	IsRank_expr_listContext()
}

type Rank_expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_expr_listContext() *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr_list
	return p
}

func (*Rank_expr_listContext) IsRank_expr_listContext() {}

func NewRank_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr_list

	return p
}

func (s *Rank_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_expr_listContext) AllRank_expr() []IRank_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRank_exprContext)(nil)).Elem())
	var tst = make([]IRank_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRank_exprContext)
		}
	}

	return tst
}

func (s *Rank_expr_listContext) Rank_expr(i int) IRank_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRank_exprContext)
}

func (s *Rank_expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Rank_expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Rank_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr_list(s)
	}
}

func (s *Rank_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr_list(s)
	}
}

func (p *SyslParser) Rank_expr_list() (localctx IRank_expr_listContext) {
	localctx = NewRank_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SyslParserRULE_rank_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.Rank_expr()
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1098)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1099)
			p.Rank_expr()
		}

		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_rank_funcContext is an interface to support dynamic dispatch.
type IExpr_rank_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_rank_funcContext differentiates from other interfaces.
	IsExpr_rank_funcContext()
}

type Expr_rank_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_rank_funcContext() *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rank_func
	return p
}

func (*Expr_rank_funcContext) IsExpr_rank_funcContext() {}

func NewExpr_rank_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rank_func

	return p
}

func (s *Expr_rank_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_rank_funcContext) E_RELOPS_RANK() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_RANK, 0)
}

func (s *Expr_rank_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_rank_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_rank_funcContext) E_AS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_AS, 0)
}

func (s *Expr_rank_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_rank_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_rank_funcContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *Expr_rank_funcContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Expr_rank_funcContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_rank_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_rank_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_rank_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rank_func(s)
	}
}

func (s *Expr_rank_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rank_func(s)
	}
}

func (p *SyslParser) Expr_rank_func() (localctx IExpr_rank_funcContext) {
	localctx = NewExpr_rank_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SyslParserRULE_expr_rank_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1105)
		p.Match(SyslParserE_RELOPS_RANK)
	}
	p.SetState(1110)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1106)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1107)
			p.View_type_spec()
		}
		{
			p.SetState(1108)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1112)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1113)
		p.Rank_expr_list()
	}
	{
		p.SetState(1114)
		p.Match(SyslParserE_AS)
	}
	{
		p.SetState(1115)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1116)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_agg_funcContext is an interface to support dynamic dispatch.
type IExpr_agg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_agg_funcContext differentiates from other interfaces.
	IsExpr_agg_funcContext()
}

type Expr_agg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_agg_funcContext() *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_agg_func
	return p
}

func (*Expr_agg_funcContext) IsExpr_agg_funcContext() {}

func NewExpr_agg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_agg_func

	return p
}

func (s *Expr_agg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_agg_funcContext) E_RELOPS_AGG() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_AGG, 0)
}

func (s *Expr_agg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_agg_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_agg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_agg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_agg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_agg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_agg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_agg_func(s)
	}
}

func (s *Expr_agg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_agg_func(s)
	}
}

func (p *SyslParser) Expr_agg_func() (localctx IExpr_agg_funcContext) {
	localctx = NewExpr_agg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SyslParserRULE_expr_agg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1118)
		p.Match(SyslParserE_RELOPS_AGG)
	}
	{
		p.SetState(1119)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1121)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1120)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1123)
		p.Func_args()
	}
	{
		p.SetState(1124)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_scope_varContext is an interface to support dynamic dispatch.
type IE_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_scope_varContext differentiates from other interfaces.
	IsE_scope_varContext()
}

type E_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_scope_varContext() *E_scope_varContext {
	var p = new(E_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_scope_var
	return p
}

func (*E_scope_varContext) IsE_scope_varContext() {}

func NewE_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_scope_varContext {
	var p = new(E_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_scope_var

	return p
}

func (s *E_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *E_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *E_scope_varContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *E_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_scope_var(s)
	}
}

func (s *E_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_scope_var(s)
	}
}

func (p *SyslParser) E_scope_var() (localctx IE_scope_varContext) {
	localctx = NewE_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SyslParserRULE_e_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1126)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1127)
		p.Match(SyslParserE_COLON)
	}

	return localctx
}

// IFirst_func_targetContext is an interface to support dynamic dispatch.
type IFirst_func_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFirst_func_targetContext differentiates from other interfaces.
	IsFirst_func_targetContext()
}

type First_func_targetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFirst_func_targetContext() *First_func_targetContext {
	var p = new(First_func_targetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_first_func_target
	return p
}

func (*First_func_targetContext) IsFirst_func_targetContext() {}

func NewFirst_func_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *First_func_targetContext {
	var p = new(First_func_targetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_first_func_target

	return p
}

func (s *First_func_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *First_func_targetContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *First_func_targetContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *First_func_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *First_func_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *First_func_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFirst_func_target(s)
	}
}

func (s *First_func_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFirst_func_target(s)
	}
}

func (p *SyslParser) First_func_target() (localctx IFirst_func_targetContext) {
	localctx = NewFirst_func_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SyslParserRULE_first_func_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1129)
			p.Match(SyslParserE_NULL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1130)
			p.Expr()
		}

	}

	return localctx
}

// IExpr_first_funcContext is an interface to support dynamic dispatch.
type IExpr_first_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_first_funcContext differentiates from other interfaces.
	IsExpr_first_funcContext()
}

type Expr_first_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_first_funcContext() *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_first_func
	return p
}

func (*Expr_first_funcContext) IsExpr_first_funcContext() {}

func NewExpr_first_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_first_func

	return p
}

func (s *Expr_first_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_first_funcContext) E_RELOPS_FIRST() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FIRST, 0)
}

func (s *Expr_first_funcContext) First_func_target() IFirst_func_targetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFirst_func_targetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFirst_func_targetContext)
}

func (s *Expr_first_funcContext) E_BY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_BY, 0)
}

func (s *Expr_first_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_first_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_first_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_first_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_first_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_first_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_first_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_first_func(s)
	}
}

func (s *Expr_first_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_first_func(s)
	}
}

func (p *SyslParser) Expr_first_func() (localctx IExpr_first_funcContext) {
	localctx = NewExpr_first_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SyslParserRULE_expr_first_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1133)
		p.Match(SyslParserE_RELOPS_FIRST)
	}
	{
		p.SetState(1134)
		p.First_func_target()
	}
	{
		p.SetState(1135)
		p.Match(SyslParserE_BY)
	}
	{
		p.SetState(1136)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1138)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1137)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1140)
		p.Rank_expr_list()
	}
	{
		p.SetState(1141)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_single_arg_funcContext is an interface to support dynamic dispatch.
type IE_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_single_arg_funcContext differentiates from other interfaces.
	IsE_single_arg_funcContext()
}

type E_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_single_arg_funcContext() *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_single_arg_func
	return p
}

func (*E_single_arg_funcContext) IsE_single_arg_funcContext() {}

func NewE_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_single_arg_func

	return p
}

func (s *E_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *E_single_arg_funcContext) E_RELOPS_WHERE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_WHERE, 0)
}

func (s *E_single_arg_funcContext) E_RELOPS_FLATTEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FLATTEN, 0)
}

func (s *E_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_single_arg_func(s)
	}
}

func (s *E_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_single_arg_func(s)
	}
}

func (p *SyslParser) E_single_arg_func() (localctx IE_single_arg_funcContext) {
	localctx = NewE_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SyslParserRULE_e_single_arg_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1143)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_RELOPS_WHERE || _la == SyslParserE_RELOPS_FLATTEN) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_single_arg_funcContext is an interface to support dynamic dispatch.
type IExpr_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_arg_funcContext differentiates from other interfaces.
	IsExpr_single_arg_funcContext()
}

type Expr_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_arg_funcContext() *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_arg_func
	return p
}

func (*Expr_single_arg_funcContext) IsExpr_single_arg_funcContext() {}

func NewExpr_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_arg_func

	return p
}

func (s *Expr_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_arg_funcContext) E_single_arg_func() IE_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_single_arg_funcContext)
}

func (s *Expr_single_arg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_single_arg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_arg_func(s)
	}
}

func (s *Expr_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_arg_func(s)
	}
}

func (p *SyslParser) Expr_single_arg_func() (localctx IExpr_single_arg_funcContext) {
	localctx = NewExpr_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SyslParserRULE_expr_single_arg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.E_single_arg_func()
	}
	{
		p.SetState(1146)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1147)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1150)
		p.Expr()
	}
	{
		p.SetState(1151)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_any_funcContext is an interface to support dynamic dispatch.
type IExpr_any_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_any_funcContext differentiates from other interfaces.
	IsExpr_any_funcContext()
}

type Expr_any_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_any_funcContext() *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_any_func
	return p
}

func (*Expr_any_funcContext) IsExpr_any_funcContext() {}

func NewExpr_any_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_any_func

	return p
}

func (s *Expr_any_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_any_funcContext) E_RELOPS_ANY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_ANY, 0)
}

func (s *Expr_any_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_any_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_any_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_any_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_any_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_any_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_any_func(s)
	}
}

func (s *Expr_any_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_any_func(s)
	}
}

func (p *SyslParser) Expr_any_func() (localctx IExpr_any_funcContext) {
	localctx = NewExpr_any_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SyslParserRULE_expr_any_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1153)
		p.Match(SyslParserE_RELOPS_ANY)
	}
	{
		p.SetState(1154)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1155)
		p.Expr()
	}
	{
		p.SetState(1156)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_single_or_nullContext is an interface to support dynamic dispatch.
type IExpr_single_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_or_nullContext differentiates from other interfaces.
	IsExpr_single_or_nullContext()
}

type Expr_single_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_or_nullContext() *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_or_null
	return p
}

func (*Expr_single_or_nullContext) IsExpr_single_or_nullContext() {}

func NewExpr_single_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_or_null

	return p
}

func (s *Expr_single_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_or_nullContext) E_RELOPS_SINGLE_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SINGLE_NULL, 0)
}

func (s *Expr_single_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_or_null(s)
	}
}

func (s *Expr_single_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_or_null(s)
	}
}

func (p *SyslParser) Expr_single_or_null() (localctx IExpr_single_or_nullContext) {
	localctx = NewExpr_single_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SyslParserRULE_expr_single_or_null)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1158)
		p.Match(SyslParserE_RELOPS_SINGLE_NULL)
	}

	return localctx
}

// IExpr_snapshotContext is an interface to support dynamic dispatch.
type IExpr_snapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_snapshotContext differentiates from other interfaces.
	IsExpr_snapshotContext()
}

type Expr_snapshotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_snapshotContext() *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_snapshot
	return p
}

func (*Expr_snapshotContext) IsExpr_snapshotContext() {}

func NewExpr_snapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_snapshot

	return p
}

func (s *Expr_snapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_snapshotContext) E_RELOPS_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SNAPSHOT, 0)
}

func (s *Expr_snapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_snapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_snapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_snapshot(s)
	}
}

func (s *Expr_snapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_snapshot(s)
	}
}

func (p *SyslParser) Expr_snapshot() (localctx IExpr_snapshotContext) {
	localctx = NewExpr_snapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SyslParserRULE_expr_snapshot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		p.Match(SyslParserE_RELOPS_SNAPSHOT)
	}

	return localctx
}

// IExpr_countContext is an interface to support dynamic dispatch.
type IExpr_countContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_countContext differentiates from other interfaces.
	IsExpr_countContext()
}

type Expr_countContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_countContext() *Expr_countContext {
	var p = new(Expr_countContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_count
	return p
}

func (*Expr_countContext) IsExpr_countContext() {}

func NewExpr_countContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_countContext {
	var p = new(Expr_countContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_count

	return p
}

func (s *Expr_countContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_countContext) E_RELOPS_COUNT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_COUNT, 0)
}

func (s *Expr_countContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_countContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_countContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_count(s)
	}
}

func (s *Expr_countContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_count(s)
	}
}

func (p *SyslParser) Expr_count() (localctx IExpr_countContext) {
	localctx = NewExpr_countContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SyslParserRULE_expr_count)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.Match(SyslParserE_RELOPS_COUNT)
	}

	return localctx
}

// IExpr_navigate_attrContext is an interface to support dynamic dispatch.
type IExpr_navigate_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigate_attrContext differentiates from other interfaces.
	IsExpr_navigate_attrContext()
}

type Expr_navigate_attrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigate_attrContext() *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate_attr
	return p
}

func (*Expr_navigate_attrContext) IsExpr_navigate_attrContext() {}

func NewExpr_navigate_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate_attr

	return p
}

func (s *Expr_navigate_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigate_attrContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigate_attrContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_navigate_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigate_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigate_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate_attr(s)
	}
}

func (s *Expr_navigate_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate_attr(s)
	}
}

func (p *SyslParser) Expr_navigate_attr() (localctx IExpr_navigate_attrContext) {
	localctx = NewExpr_navigate_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SyslParserRULE_expr_navigate_attr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1165)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_DOT {
		{
			p.SetState(1164)
			p.Match(SyslParserE_DOT)
		}

	}
	{
		p.SetState(1167)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IExpr_navigateContext is an interface to support dynamic dispatch.
type IExpr_navigateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigateContext differentiates from other interfaces.
	IsExpr_navigateContext()
}

type Expr_navigateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigateContext() *Expr_navigateContext {
	var p = new(Expr_navigateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate
	return p
}

func (*Expr_navigateContext) IsExpr_navigateContext() {}

func NewExpr_navigateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigateContext {
	var p = new(Expr_navigateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate

	return p
}

func (s *Expr_navigateContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigateContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *Expr_navigateContext) Expr_navigate_attr() IExpr_navigate_attrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigate_attrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigate_attrContext)
}

func (s *Expr_navigateContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *Expr_navigateContext) E_VIA() antlr.TerminalNode {
	return s.GetToken(SyslParserE_VIA, 0)
}

func (s *Expr_navigateContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigateContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Expr_navigateContext) E_SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SEQUENCE_OF, 0)
}

func (s *Expr_navigateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate(s)
	}
}

func (s *Expr_navigateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate(s)
	}
}

func (p *SyslParser) Expr_navigate() (localctx IExpr_navigateContext) {
	localctx = NewExpr_navigateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SyslParserRULE_expr_navigate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1170)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1169)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1172)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SEQUENCE_OF || _la == SyslParserE_SET_OF {
		p.SetState(1173)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserE_SEQUENCE_OF || _la == SyslParserE_SET_OF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1176)
		p.Expr_navigate_attr()
	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1177)
			p.Match(SyslParserE_VIA)
		}
		{
			p.SetState(1178)
			p.Match(SyslParserE_Name)
		}

	}

	return localctx
}

// IMatching_rhsContext is an interface to support dynamic dispatch.
type IMatching_rhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatching_rhsContext differentiates from other interfaces.
	IsMatching_rhsContext()
}

type Matching_rhsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatching_rhsContext() *Matching_rhsContext {
	var p = new(Matching_rhsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_matching_rhs
	return p
}

func (*Matching_rhsContext) IsMatching_rhsContext() {}

func NewMatching_rhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Matching_rhsContext {
	var p = new(Matching_rhsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_matching_rhs

	return p
}

func (s *Matching_rhsContext) GetParser() antlr.Parser { return s.parser }

func (s *Matching_rhsContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *Matching_rhsContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Matching_rhsContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *Matching_rhsContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Matching_rhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Matching_rhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Matching_rhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMatching_rhs(s)
	}
}

func (s *Matching_rhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMatching_rhs(s)
	}
}

func (p *SyslParser) Matching_rhs() (localctx IMatching_rhsContext) {
	localctx = NewMatching_rhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SyslParserRULE_matching_rhs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1185)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1181)
			p.Expr_table_of_op()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1182)
			p.Expr_navigate()
		}

	case SyslParserE_OPEN_PAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1183)
			p.AtomT_paren()
		}

	case SyslParserE_Name:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1184)
			p.Match(SyslParserE_Name)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISquiggly_argsContext is an interface to support dynamic dispatch.
type ISquiggly_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSquiggly_argsContext differentiates from other interfaces.
	IsSquiggly_argsContext()
}

type Squiggly_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquiggly_argsContext() *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_squiggly_args
	return p
}

func (*Squiggly_argsContext) IsSquiggly_argsContext() {}

func NewSquiggly_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_squiggly_args

	return p
}

func (s *Squiggly_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Squiggly_argsContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Squiggly_argsContext) AllE_Name() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_Name)
}

func (s *Squiggly_argsContext) E_Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, i)
}

func (s *Squiggly_argsContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Squiggly_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Squiggly_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Squiggly_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Squiggly_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Squiggly_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSquiggly_args(s)
	}
}

func (s *Squiggly_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSquiggly_args(s)
	}
}

func (p *SyslParser) Squiggly_args() (localctx ISquiggly_argsContext) {
	localctx = NewSquiggly_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SyslParserRULE_squiggly_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1188)
		p.Match(SyslParserE_Name)
	}
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1189)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1190)
			p.Match(SyslParserE_Name)
		}

		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1196)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IExpr_matchingContext is an interface to support dynamic dispatch.
type IExpr_matchingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_matchingContext differentiates from other interfaces.
	IsExpr_matchingContext()
}

type Expr_matchingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_matchingContext() *Expr_matchingContext {
	var p = new(Expr_matchingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_matching
	return p
}

func (*Expr_matchingContext) IsExpr_matchingContext() {}

func NewExpr_matchingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_matchingContext {
	var p = new(Expr_matchingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_matching

	return p
}

func (s *Expr_matchingContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_matchingContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *Expr_matchingContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_matchingContext) Matching_rhs() IMatching_rhsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatching_rhsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatching_rhsContext)
}

func (s *Expr_matchingContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *Expr_matchingContext) Squiggly_args() ISquiggly_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISquiggly_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISquiggly_argsContext)
}

func (s *Expr_matchingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_matchingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_matchingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_matching(s)
	}
}

func (s *Expr_matchingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_matching(s)
	}
}

func (p *SyslParser) Expr_matching() (localctx IExpr_matchingContext) {
	localctx = NewExpr_matchingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SyslParserRULE_expr_matching)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1199)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_NOT {
		{
			p.SetState(1198)
			p.Match(SyslParserE_NOT)
		}

	}
	{
		p.SetState(1201)
		p.Match(SyslParserE_TILDE)
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SQ_OPEN {
		{
			p.SetState(1202)
			p.Squiggly_args()
		}

	}
	{
		p.SetState(1205)
		p.Match(SyslParserE_ANGLE_CLOSE)
	}
	{
		p.SetState(1206)
		p.Matching_rhs()
	}

	return localctx
}

// IRelopContext is an interface to support dynamic dispatch.
type IRelopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelopContext differentiates from other interfaces.
	IsRelopContext()
}

type RelopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelopContext() *RelopContext {
	var p = new(RelopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_relop
	return p
}

func (*RelopContext) IsRelopContext() {}

func NewRelopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelopContext {
	var p = new(RelopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_relop

	return p
}

func (s *RelopContext) GetParser() antlr.Parser { return s.parser }

func (s *RelopContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *RelopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *RelopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *RelopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *RelopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *RelopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *RelopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *RelopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *RelopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *RelopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *RelopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *RelopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRelop(s)
	}
}

func (s *RelopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRelop(s)
	}
}

func (p *SyslParser) Relop() (localctx IRelopContext) {
	localctx = NewRelopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SyslParserRULE_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1219)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1208)
			p.Expr_table_of_op()
		}

	case SyslParserE_RELOPS_RANK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1209)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1210)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1211)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1212)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1213)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1214)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1215)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1216)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1217)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1218)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_itemContext is an interface to support dynamic dispatch.
type IList_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_itemContext differentiates from other interfaces.
	IsList_itemContext()
}

type List_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_itemContext() *List_itemContext {
	var p = new(List_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_list_item
	return p
}

func (*List_itemContext) IsList_itemContext() {}

func NewList_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_itemContext {
	var p = new(List_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_list_item

	return p
}

func (s *List_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *List_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterList_item(s)
	}
}

func (s *List_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitList_item(s)
	}
}

func (p *SyslParser) List_item() (localctx IList_itemContext) {
	localctx = NewList_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SyslParserRULE_list_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1221)
		p.Expr()
	}

	return localctx
}

// IExpr_listContext is an interface to support dynamic dispatch.
type IExpr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_listContext differentiates from other interfaces.
	IsExpr_listContext()
}

type Expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_listContext() *Expr_listContext {
	var p = new(Expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_list
	return p
}

func (*Expr_listContext) IsExpr_listContext() {}

func NewExpr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_listContext {
	var p = new(Expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_list

	return p
}

func (s *Expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_listContext) AllList_item() []IList_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_itemContext)(nil)).Elem())
	var tst = make([]IList_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_itemContext)
		}
	}

	return tst
}

func (s *Expr_listContext) List_item(i int) IList_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_itemContext)
}

func (s *Expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_list(s)
	}
}

func (s *Expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_list(s)
	}
}

func (p *SyslParser) Expr_list() (localctx IExpr_listContext) {
	localctx = NewExpr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SyslParserRULE_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1223)
		p.List_item()
	}
	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1224)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1225)
			p.List_item()
		}

		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_setContext is an interface to support dynamic dispatch.
type IExpr_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_setContext differentiates from other interfaces.
	IsExpr_setContext()
}

type Expr_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_setContext() *Expr_setContext {
	var p = new(Expr_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_set
	return p
}

func (*Expr_setContext) IsExpr_setContext() {}

func NewExpr_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_setContext {
	var p = new(Expr_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_set

	return p
}

func (s *Expr_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_setContext) E_CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_OPEN, 0)
}

func (s *Expr_setContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_setContext) E_CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_CLOSE, 0)
}

func (s *Expr_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_set(s)
	}
}

func (s *Expr_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_set(s)
	}
}

func (p *SyslParser) Expr_set() (localctx IExpr_setContext) {
	localctx = NewExpr_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SyslParserRULE_expr_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1231)
		p.Match(SyslParserE_CURLY_OPEN)
	}
	{
		p.SetState(1232)
		p.Expr_list()
	}
	{
		p.SetState(1233)
		p.Match(SyslParserE_CURLY_CLOSE)
	}

	return localctx
}

// IEmpty_tupleContext is an interface to support dynamic dispatch.
type IEmpty_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_tupleContext differentiates from other interfaces.
	IsEmpty_tupleContext()
}

type Empty_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_tupleContext() *Empty_tupleContext {
	var p = new(Empty_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_empty_tuple
	return p
}

func (*Empty_tupleContext) IsEmpty_tupleContext() {}

func NewEmpty_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_tupleContext {
	var p = new(Empty_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_empty_tuple

	return p
}

func (s *Empty_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Empty_tupleContext) E_EMPTY_TUPLE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EMPTY_TUPLE, 0)
}

func (s *Empty_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEmpty_tuple(s)
	}
}

func (s *Empty_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEmpty_tuple(s)
	}
}

func (p *SyslParser) Empty_tuple() (localctx IEmpty_tupleContext) {
	localctx = NewEmpty_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SyslParserRULE_empty_tuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.Match(SyslParserE_EMPTY_TUPLE)
	}

	return localctx
}

// IAtom_dot_relopContext is an interface to support dynamic dispatch.
type IAtom_dot_relopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_dot_relopContext differentiates from other interfaces.
	IsAtom_dot_relopContext()
}

type Atom_dot_relopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_dot_relopContext() *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom_dot_relop
	return p
}

func (*Atom_dot_relopContext) IsAtom_dot_relopContext() {}

func NewAtom_dot_relopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom_dot_relop

	return p
}

func (s *Atom_dot_relopContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_dot_relopContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Atom_dot_relopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *Atom_dot_relopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *Atom_dot_relopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *Atom_dot_relopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *Atom_dot_relopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *Atom_dot_relopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *Atom_dot_relopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Atom_dot_relopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *Atom_dot_relopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_dot_relopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_dot_relopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom_dot_relop(s)
	}
}

func (s *Atom_dot_relopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom_dot_relop(s)
	}
}

func (p *SyslParser) Atom_dot_relop() (localctx IAtom_dot_relopContext) {
	localctx = NewAtom_dot_relopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SyslParserRULE_atom_dot_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.Match(SyslParserE_DOT)
	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_RELOPS_RANK:
		{
			p.SetState(1238)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		{
			p.SetState(1239)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		{
			p.SetState(1240)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		{
			p.SetState(1241)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		{
			p.SetState(1242)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		{
			p.SetState(1243)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		{
			p.SetState(1244)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		{
			p.SetState(1245)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		{
			p.SetState(1246)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		{
			p.SetState(1247)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomT_implied_dotContext is an interface to support dynamic dispatch.
type IAtomT_implied_dotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_implied_dotContext differentiates from other interfaces.
	IsAtomT_implied_dotContext()
}

type AtomT_implied_dotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_implied_dotContext() *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_implied_dot
	return p
}

func (*AtomT_implied_dotContext) IsAtomT_implied_dotContext() {}

func NewAtomT_implied_dotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_implied_dot

	return p
}

func (s *AtomT_implied_dotContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_implied_dotContext) Atom_dot_relop() IAtom_dot_relopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_dot_relopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_dot_relopContext)
}

func (s *AtomT_implied_dotContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *AtomT_implied_dotContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *AtomT_implied_dotContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *AtomT_implied_dotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_implied_dotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_implied_dotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_implied_dot(s)
	}
}

func (s *AtomT_implied_dotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_implied_dot(s)
	}
}

func (p *SyslParser) AtomT_implied_dot() (localctx IAtomT_implied_dotContext) {
	localctx = NewAtomT_implied_dotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SyslParserRULE_atomT_implied_dot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1254)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1250)
			p.Atom_dot_relop()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1251)
			p.Expr_navigate()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1252)
			p.Expr_matching()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1253)
			p.Expr_table_of_op()
		}

	}

	return localctx
}

// IAtomT_nameContext is an interface to support dynamic dispatch.
type IAtomT_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_nameContext differentiates from other interfaces.
	IsAtomT_nameContext()
}

type AtomT_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_nameContext() *AtomT_nameContext {
	var p = new(AtomT_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_name
	return p
}

func (*AtomT_nameContext) IsAtomT_nameContext() {}

func NewAtomT_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_nameContext {
	var p = new(AtomT_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_name

	return p
}

func (s *AtomT_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_nameContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *AtomT_nameContext) E_WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserE_WHATEVER, 0)
}

func (s *AtomT_nameContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *AtomT_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_name(s)
	}
}

func (s *AtomT_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_name(s)
	}
}

func (p *SyslParser) AtomT_name() (localctx IAtomT_nameContext) {
	localctx = NewAtomT_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SyslParserRULE_atomT_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1256)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_WHATEVER || _la == SyslParserE_Name || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IAtomT_parenContext is an interface to support dynamic dispatch.
type IAtomT_parenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_parenContext differentiates from other interfaces.
	IsAtomT_parenContext()
}

type AtomT_parenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_parenContext() *AtomT_parenContext {
	var p = new(AtomT_parenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_paren
	return p
}

func (*AtomT_parenContext) IsAtomT_parenContext() {}

func NewAtomT_parenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_parenContext {
	var p = new(AtomT_parenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_paren

	return p
}

func (s *AtomT_parenContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_parenContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *AtomT_parenContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AtomT_parenContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *AtomT_parenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_parenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_parenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_paren(s)
	}
}

func (s *AtomT_parenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_paren(s)
	}
}

func (p *SyslParser) AtomT_paren() (localctx IAtomT_parenContext) {
	localctx = NewAtomT_parenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SyslParserRULE_atomT_paren)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1259)
		p.Expr()
	}
	{
		p.SetState(1260)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_atom_listContext is an interface to support dynamic dispatch.
type IExpr_atom_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_atom_listContext differentiates from other interfaces.
	IsExpr_atom_listContext()
}

type Expr_atom_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_atom_listContext() *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_atom_list
	return p
}

func (*Expr_atom_listContext) IsExpr_atom_listContext() {}

func NewExpr_atom_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_atom_list

	return p
}

func (s *Expr_atom_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_atom_listContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Expr_atom_listContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_atom_listContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Expr_atom_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_atom_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_atom_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_atom_list(s)
	}
}

func (s *Expr_atom_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_atom_list(s)
	}
}

func (p *SyslParser) Expr_atom_list() (localctx IExpr_atom_listContext) {
	localctx = NewExpr_atom_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SyslParserRULE_expr_atom_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1262)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1263)
		p.Expr_list()
	}
	{
		p.SetState(1264)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IAtomTContext is an interface to support dynamic dispatch.
type IAtomTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomTContext differentiates from other interfaces.
	IsAtomTContext()
}

type AtomTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomTContext() *AtomTContext {
	var p = new(AtomTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT
	return p
}

func (*AtomTContext) IsAtomTContext() {}

func NewAtomTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomTContext {
	var p = new(AtomTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT

	return p
}

func (s *AtomTContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomTContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *AtomTContext) Expr_set() IExpr_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_setContext)
}

func (s *AtomTContext) Expr_atom_list() IExpr_atom_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_atom_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_atom_listContext)
}

func (s *AtomTContext) Empty_tuple() IEmpty_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_tupleContext)
}

func (s *AtomTContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *AtomTContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomTContext) AtomT_implied_dot() IAtomT_implied_dotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_implied_dotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_implied_dotContext)
}

func (s *AtomTContext) AtomT_name() IAtomT_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_nameContext)
}

func (s *AtomTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT(s)
	}
}

func (s *AtomTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT(s)
	}
}

func (p *SyslParser) AtomT() (localctx IAtomTContext) {
	localctx = NewAtomTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SyslParserRULE_atomT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1266)
			p.Expr_func()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1267)
			p.Expr_set()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1268)
			p.Expr_atom_list()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1269)
			p.Empty_tuple()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1270)
			p.AtomT_paren()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1271)
			p.Literal()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1272)
			p.AtomT_implied_dot()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1273)
			p.AtomT_name()
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) AtomT() IAtomTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomTContext)
}

func (s *AtomContext) AllRelop() []IRelopContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelopContext)(nil)).Elem())
	var tst = make([]IRelopContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelopContext)
		}
	}

	return tst
}

func (s *AtomContext) Relop(i int) IRelopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelopContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelopContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *SyslParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SyslParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1276)
		p.AtomT()
	}
	p.SetState(1280)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1277)
				p.Relop()
			}

		}
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())
	}

	return localctx
}

// IPowerTContext is an interface to support dynamic dispatch.
type IPowerTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerTContext differentiates from other interfaces.
	IsPowerTContext()
}

type PowerTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerTContext() *PowerTContext {
	var p = new(PowerTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_powerT
	return p
}

func (*PowerTContext) IsPowerTContext() {}

func NewPowerTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerTContext {
	var p = new(PowerTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_powerT

	return p
}

func (s *PowerTContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerTContext) E_POW() antlr.TerminalNode {
	return s.GetToken(SyslParserE_POW, 0)
}

func (s *PowerTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *PowerTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPowerT(s)
	}
}

func (s *PowerTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPowerT(s)
	}
}

func (p *SyslParser) PowerT() (localctx IPowerTContext) {
	localctx = NewPowerTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SyslParserRULE_powerT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1283)
		p.Match(SyslParserE_POW)
	}
	{
		p.SetState(1284)
		p.UnaryTerm()
	}

	return localctx
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PowerContext) PowerT() IPowerTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerTContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPower(s)
	}
}

func (p *SyslParser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SyslParserRULE_power)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1286)
		p.Atom()
	}
	p.SetState(1288)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1287)
			p.PowerT()
		}

	}

	return localctx
}

// IUnaryTermContext is an interface to support dynamic dispatch.
type IUnaryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryTermContext differentiates from other interfaces.
	IsUnaryTermContext()
}

type UnaryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryTermContext() *UnaryTermContext {
	var p = new(UnaryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_unaryTerm
	return p
}

func (*UnaryTermContext) IsUnaryTermContext() {}

func NewUnaryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryTermContext {
	var p = new(UnaryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_unaryTerm

	return p
}

func (s *UnaryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryTermContext) Power() IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *UnaryTermContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *UnaryTermContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *UnaryTermContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *UnaryTermContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *UnaryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnaryTerm(s)
	}
}

func (s *UnaryTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnaryTerm(s)
	}
}

func (p *SyslParser) UnaryTerm() (localctx IUnaryTermContext) {
	localctx = NewUnaryTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SyslParserRULE_unaryTerm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
		p.SetState(1290)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SyslParserE_PLUS-97))|(1<<(SyslParserE_MINUS-97))|(1<<(SyslParserE_TILDE-97))|(1<<(SyslParserE_NOT-97)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1293)
		p.Power()
	}

	return localctx
}

// ITermTContext is an interface to support dynamic dispatch.
type ITermTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermTContext differentiates from other interfaces.
	IsTermTContext()
}

type TermTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermTContext() *TermTContext {
	var p = new(TermTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_termT
	return p
}

func (*TermTContext) IsTermTContext() {}

func NewTermTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermTContext {
	var p = new(TermTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_termT

	return p
}

func (s *TermTContext) GetParser() antlr.Parser { return s.parser }

func (s *TermTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermTContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *TermTContext) E_DIVIDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIVIDE, 0)
}

func (s *TermTContext) E_MOD() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MOD, 0)
}

func (s *TermTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTermT(s)
	}
}

func (s *TermTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTermT(s)
	}
}

func (p *SyslParser) TermT() (localctx ITermTContext) {
	localctx = NewTermTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SyslParserRULE_termT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1295)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(SyslParserE_DIVIDE-98))|(1<<(SyslParserE_MOD-98))|(1<<(SyslParserE_STAR-98)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1296)
		p.UnaryTerm()
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermContext) AllTermT() []ITermTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermTContext)(nil)).Elem())
	var tst = make([]ITermTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermTContext)
		}
	}

	return tst
}

func (s *TermContext) TermT(i int) ITermTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermTContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *SyslParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SyslParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1298)
		p.UnaryTerm()
	}
	p.SetState(1302)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1299)
				p.TermT()
			}

		}
		p.SetState(1304)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())
	}

	return localctx
}

// IBinexprTContext is an interface to support dynamic dispatch.
type IBinexprTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprTContext differentiates from other interfaces.
	IsBinexprTContext()
}

type BinexprTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprTContext() *BinexprTContext {
	var p = new(BinexprTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexprT
	return p
}

func (*BinexprTContext) IsBinexprTContext() {}

func NewBinexprTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprTContext {
	var p = new(BinexprTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexprT

	return p
}

func (s *BinexprTContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprTContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprTContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *BinexprTContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *BinexprTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexprT(s)
	}
}

func (s *BinexprTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexprT(s)
	}
}

func (p *SyslParser) BinexprT() (localctx IBinexprTContext) {
	localctx = NewBinexprTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SyslParserRULE_binexprT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1305)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_PLUS || _la == SyslParserE_MINUS) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1306)
		p.Term()
	}

	return localctx
}

// IBinexprContext is an interface to support dynamic dispatch.
type IBinexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprContext differentiates from other interfaces.
	IsBinexprContext()
}

type BinexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprContext() *BinexprContext {
	var p = new(BinexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexpr
	return p
}

func (*BinexprContext) IsBinexprContext() {}

func NewBinexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprContext {
	var p = new(BinexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexpr

	return p
}

func (s *BinexprContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprContext) AllBinexprT() []IBinexprTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprTContext)(nil)).Elem())
	var tst = make([]IBinexprTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprTContext)
		}
	}

	return tst
}

func (s *BinexprContext) BinexprT(i int) IBinexprTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprTContext)
}

func (s *BinexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexpr(s)
	}
}

func (s *BinexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexpr(s)
	}
}

func (p *SyslParser) Binexpr() (localctx IBinexprContext) {
	localctx = NewBinexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SyslParserRULE_binexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1308)
		p.Term()
	}
	p.SetState(1312)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1309)
				p.BinexprT()
			}

		}
		p.SetState(1314)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}

	return localctx
}

// IE_compare_opsContext is an interface to support dynamic dispatch.
type IE_compare_opsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_compare_opsContext differentiates from other interfaces.
	IsE_compare_opsContext()
}

type E_compare_opsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_compare_opsContext() *E_compare_opsContext {
	var p = new(E_compare_opsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_compare_ops
	return p
}

func (*E_compare_opsContext) IsE_compare_opsContext() {}

func NewE_compare_opsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_compare_opsContext {
	var p = new(E_compare_opsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_compare_ops

	return p
}

func (s *E_compare_opsContext) GetParser() antlr.Parser { return s.parser }

func (s *E_compare_opsContext) E_REL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_REL, 0)
}

func (s *E_compare_opsContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *E_compare_opsContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *E_compare_opsContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *E_compare_opsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_compare_opsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_compare_opsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_compare_ops(s)
	}
}

func (s *E_compare_opsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_compare_ops(s)
	}
}

func (p *SyslParser) E_compare_ops() (localctx IE_compare_opsContext) {
	localctx = NewE_compare_opsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SyslParserRULE_e_compare_ops)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1315)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(SyslParserE_DOUBLE_EQ-79))|(1<<(SyslParserE_REL-79))|(1<<(SyslParserE_ANGLE_OPEN-79))|(1<<(SyslParserE_ANGLE_CLOSE-79)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_relContext is an interface to support dynamic dispatch.
type IExpr_relContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_relContext differentiates from other interfaces.
	IsExpr_relContext()
}

type Expr_relContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_relContext() *Expr_relContext {
	var p = new(Expr_relContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rel
	return p
}

func (*Expr_relContext) IsExpr_relContext() {}

func NewExpr_relContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_relContext {
	var p = new(Expr_relContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rel

	return p
}

func (s *Expr_relContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_relContext) AllBinexpr() []IBinexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprContext)(nil)).Elem())
	var tst = make([]IBinexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprContext)
		}
	}

	return tst
}

func (s *Expr_relContext) Binexpr(i int) IBinexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprContext)
}

func (s *Expr_relContext) AllE_compare_ops() []IE_compare_opsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem())
	var tst = make([]IE_compare_opsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IE_compare_opsContext)
		}
	}

	return tst
}

func (s *Expr_relContext) E_compare_ops(i int) IE_compare_opsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IE_compare_opsContext)
}

func (s *Expr_relContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_relContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_relContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rel(s)
	}
}

func (s *Expr_relContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rel(s)
	}
}

func (p *SyslParser) Expr_rel() (localctx IExpr_relContext) {
	localctx = NewExpr_relContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SyslParserRULE_expr_rel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1317)
		p.Binexpr()
	}
	p.SetState(1323)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1318)
				p.E_compare_ops()
			}
			{
				p.SetState(1319)
				p.Binexpr()
			}

		}
		p.SetState(1325)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitandContext is an interface to support dynamic dispatch.
type IExpr_bitandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitandContext differentiates from other interfaces.
	IsExpr_bitandContext()
}

type Expr_bitandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitandContext() *Expr_bitandContext {
	var p = new(Expr_bitandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitand
	return p
}

func (*Expr_bitandContext) IsExpr_bitandContext() {}

func NewExpr_bitandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitandContext {
	var p = new(Expr_bitandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitand

	return p
}

func (s *Expr_bitandContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitandContext) AllExpr_rel() []IExpr_relContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_relContext)(nil)).Elem())
	var tst = make([]IExpr_relContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_relContext)
		}
	}

	return tst
}

func (s *Expr_bitandContext) Expr_rel(i int) IExpr_relContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_relContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_relContext)
}

func (s *Expr_bitandContext) AllE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AMP)
}

func (s *Expr_bitandContext) E_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AMP, i)
}

func (s *Expr_bitandContext) AllE_AND() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AND)
}

func (s *Expr_bitandContext) E_AND(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AND, i)
}

func (s *Expr_bitandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitand(s)
	}
}

func (s *Expr_bitandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitand(s)
	}
}

func (p *SyslParser) Expr_bitand() (localctx IExpr_bitandContext) {
	localctx = NewExpr_bitandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SyslParserRULE_expr_bitand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1326)
		p.Expr_rel()
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1327)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SyslParserE_AMP || _la == SyslParserE_AND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(1328)
				p.Expr_rel()
			}

		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitxorContext is an interface to support dynamic dispatch.
type IExpr_bitxorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitxorContext differentiates from other interfaces.
	IsExpr_bitxorContext()
}

type Expr_bitxorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitxorContext() *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitxor
	return p
}

func (*Expr_bitxorContext) IsExpr_bitxorContext() {}

func NewExpr_bitxorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitxor

	return p
}

func (s *Expr_bitxorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitxorContext) AllExpr_bitand() []IExpr_bitandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem())
	var tst = make([]IExpr_bitandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitandContext)
		}
	}

	return tst
}

func (s *Expr_bitxorContext) Expr_bitand(i int) IExpr_bitandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitandContext)
}

func (s *Expr_bitxorContext) AllE_XOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_XOR)
}

func (s *Expr_bitxorContext) E_XOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_XOR, i)
}

func (s *Expr_bitxorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitxorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitxorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitxor(s)
	}
}

func (s *Expr_bitxorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitxor(s)
	}
}

func (p *SyslParser) Expr_bitxor() (localctx IExpr_bitxorContext) {
	localctx = NewExpr_bitxorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SyslParserRULE_expr_bitxor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1334)
		p.Expr_bitand()
	}
	p.SetState(1339)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1335)
				p.Match(SyslParserE_XOR)
			}
			{
				p.SetState(1336)
				p.Expr_bitand()
			}

		}
		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitorContext is an interface to support dynamic dispatch.
type IExpr_bitorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitorContext differentiates from other interfaces.
	IsExpr_bitorContext()
}

type Expr_bitorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitorContext() *Expr_bitorContext {
	var p = new(Expr_bitorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitor
	return p
}

func (*Expr_bitorContext) IsExpr_bitorContext() {}

func NewExpr_bitorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitorContext {
	var p = new(Expr_bitorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitor

	return p
}

func (s *Expr_bitorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitorContext) AllExpr_bitxor() []IExpr_bitxorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem())
	var tst = make([]IExpr_bitxorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitxorContext)
		}
	}

	return tst
}

func (s *Expr_bitorContext) Expr_bitxor(i int) IExpr_bitxorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitxorContext)
}

func (s *Expr_bitorContext) AllE_BITOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BITOR)
}

func (s *Expr_bitorContext) E_BITOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BITOR, i)
}

func (s *Expr_bitorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitor(s)
	}
}

func (s *Expr_bitorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitor(s)
	}
}

func (p *SyslParser) Expr_bitor() (localctx IExpr_bitorContext) {
	localctx = NewExpr_bitorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SyslParserRULE_expr_bitor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1342)
		p.Expr_bitxor()
	}
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1343)
				p.Match(SyslParserE_BITOR)
			}
			{
				p.SetState(1344)
				p.Expr_bitxor()
			}

		}
		p.SetState(1349)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_andContext is an interface to support dynamic dispatch.
type IExpr_andContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_andContext differentiates from other interfaces.
	IsExpr_andContext()
}

type Expr_andContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_andContext() *Expr_andContext {
	var p = new(Expr_andContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_and
	return p
}

func (*Expr_andContext) IsExpr_andContext() {}

func NewExpr_andContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_andContext {
	var p = new(Expr_andContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_and

	return p
}

func (s *Expr_andContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_andContext) AllExpr_bitor() []IExpr_bitorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem())
	var tst = make([]IExpr_bitorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitorContext)
		}
	}

	return tst
}

func (s *Expr_andContext) Expr_bitor(i int) IExpr_bitorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitorContext)
}

func (s *Expr_andContext) AllE_DOUBLE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOUBLE_AMP)
}

func (s *Expr_andContext) E_DOUBLE_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_AMP, i)
}

func (s *Expr_andContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_andContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_andContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_and(s)
	}
}

func (s *Expr_andContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_and(s)
	}
}

func (p *SyslParser) Expr_and() (localctx IExpr_andContext) {
	localctx = NewExpr_andContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SyslParserRULE_expr_and)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1350)
		p.Expr_bitor()
	}
	p.SetState(1355)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1351)
				p.Match(SyslParserE_DOUBLE_AMP)
			}
			{
				p.SetState(1352)
				p.Expr_bitor()
			}

		}
		p.SetState(1357)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_orContext is an interface to support dynamic dispatch.
type IExpr_orContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_orContext differentiates from other interfaces.
	IsExpr_orContext()
}

type Expr_orContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_orContext() *Expr_orContext {
	var p = new(Expr_orContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_or
	return p
}

func (*Expr_orContext) IsExpr_orContext() {}

func NewExpr_orContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_orContext {
	var p = new(Expr_orContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_or

	return p
}

func (s *Expr_orContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_orContext) AllExpr_and() []IExpr_andContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_andContext)(nil)).Elem())
	var tst = make([]IExpr_andContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_andContext)
		}
	}

	return tst
}

func (s *Expr_orContext) Expr_and(i int) IExpr_andContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_andContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_andContext)
}

func (s *Expr_orContext) AllE_LOGIC_OR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_LOGIC_OR)
}

func (s *Expr_orContext) E_LOGIC_OR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_LOGIC_OR, i)
}

func (s *Expr_orContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_orContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_orContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_or(s)
	}
}

func (s *Expr_orContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_or(s)
	}
}

func (p *SyslParser) Expr_or() (localctx IExpr_orContext) {
	localctx = NewExpr_orContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SyslParserRULE_expr_or)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1358)
		p.Expr_and()
	}
	p.SetState(1363)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1359)
				p.Match(SyslParserE_LOGIC_OR)
			}
			{
				p.SetState(1360)
				p.Expr_and()
			}

		}
		p.SetState(1365)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_but_notContext is an interface to support dynamic dispatch.
type IExpr_but_notContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_but_notContext differentiates from other interfaces.
	IsExpr_but_notContext()
}

type Expr_but_notContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_but_notContext() *Expr_but_notContext {
	var p = new(Expr_but_notContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_but_not
	return p
}

func (*Expr_but_notContext) IsExpr_but_notContext() {}

func NewExpr_but_notContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_but_notContext {
	var p = new(Expr_but_notContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_but_not

	return p
}

func (s *Expr_but_notContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_but_notContext) AllExpr_or() []IExpr_orContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_orContext)(nil)).Elem())
	var tst = make([]IExpr_orContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_orContext)
		}
	}

	return tst
}

func (s *Expr_but_notContext) Expr_or(i int) IExpr_orContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_orContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_orContext)
}

func (s *Expr_but_notContext) AllE_BUTNOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BUTNOT)
}

func (s *Expr_but_notContext) E_BUTNOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BUTNOT, i)
}

func (s *Expr_but_notContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_but_notContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_but_notContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_but_not(s)
	}
}

func (s *Expr_but_notContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_but_not(s)
	}
}

func (p *SyslParser) Expr_but_not() (localctx IExpr_but_notContext) {
	localctx = NewExpr_but_notContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SyslParserRULE_expr_but_not)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1366)
		p.Expr_or()
	}
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1367)
				p.Match(SyslParserE_BUTNOT)
			}
			{
				p.SetState(1368)
				p.Expr_or()
			}

		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_coalesceContext is an interface to support dynamic dispatch.
type IExpr_coalesceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_coalesceContext differentiates from other interfaces.
	IsExpr_coalesceContext()
}

type Expr_coalesceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_coalesceContext() *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_coalesce
	return p
}

func (*Expr_coalesceContext) IsExpr_coalesceContext() {}

func NewExpr_coalesceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_coalesce

	return p
}

func (s *Expr_coalesceContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_coalesceContext) AllExpr_but_not() []IExpr_but_notContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem())
	var tst = make([]IExpr_but_notContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_but_notContext)
		}
	}

	return tst
}

func (s *Expr_coalesceContext) Expr_but_not(i int) IExpr_but_notContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_but_notContext)
}

func (s *Expr_coalesceContext) AllE_COALESCE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COALESCE)
}

func (s *Expr_coalesceContext) E_COALESCE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COALESCE, i)
}

func (s *Expr_coalesceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_coalesceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_coalesceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_coalesce(s)
	}
}

func (s *Expr_coalesceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_coalesce(s)
	}
}

func (p *SyslParser) Expr_coalesce() (localctx IExpr_coalesceContext) {
	localctx = NewExpr_coalesceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SyslParserRULE_expr_coalesce)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1374)
		p.Expr_but_not()
	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1375)
				p.Match(SyslParserE_COALESCE)
			}
			{
				p.SetState(1376)
				p.Expr_but_not()
			}

		}
		p.SetState(1381)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())
	}

	return localctx
}

// IIf_one_linerContext is an interface to support dynamic dispatch.
type IIf_one_linerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_one_linerContext differentiates from other interfaces.
	IsIf_one_linerContext()
}

type If_one_linerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_one_linerContext() *If_one_linerContext {
	var p = new(If_one_linerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_one_liner
	return p
}

func (*If_one_linerContext) IsIf_one_linerContext() {}

func NewIf_one_linerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_one_linerContext {
	var p = new(If_one_linerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_one_liner

	return p
}

func (s *If_one_linerContext) GetParser() antlr.Parser { return s.parser }

func (s *If_one_linerContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *If_one_linerContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *If_one_linerContext) E_THEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_THEN, 0)
}

func (s *If_one_linerContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *If_one_linerContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *If_one_linerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_one_linerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_one_linerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_one_liner(s)
	}
}

func (s *If_one_linerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_one_liner(s)
	}
}

func (p *SyslParser) If_one_liner() (localctx IIf_one_linerContext) {
	localctx = NewIf_one_linerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SyslParserRULE_if_one_liner)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1382)
		p.Expr()
	}
	p.SetState(1384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1383)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1386)
		p.Match(SyslParserE_THEN)
	}
	{
		p.SetState(1387)
		p.Expr()
	}
	{
		p.SetState(1388)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1389)
		p.Expr()
	}

	return localctx
}

// IElse_block_stmtContext is an interface to support dynamic dispatch.
type IElse_block_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsElse_block_stmtContext differentiates from other interfaces.
	IsElse_block_stmtContext()
}

type Else_block_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyElse_block_stmtContext() *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_block_stmt
	return p
}

func (*Else_block_stmtContext) IsElse_block_stmtContext() {}

func NewElse_block_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_block_stmt

	return p
}

func (s *Else_block_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_block_stmtContext) Get_expr() IExprContext { return s._expr }

func (s *Else_block_stmtContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Else_block_stmtContext) GetNested() bool { return s.nested }

func (s *Else_block_stmtContext) SetNested(v bool) { s.nested = v }

func (s *Else_block_stmtContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Else_block_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_block_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_block_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_block_stmt(s)
	}
}

func (s *Else_block_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_block_stmt(s)
	}
}

func (p *SyslParser) Else_block_stmt() (localctx IElse_block_stmtContext) {
	localctx = NewElse_block_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SyslParserRULE_else_block_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1391)

		var _x = p.Expr()

		localctx.(*Else_block_stmtContext)._expr = _x
	}
	localctx.(*Else_block_stmtContext).SetNested(localctx.(*Else_block_stmtContext).Get_expr().GetNested())

	return localctx
}

// IControl_itemContext is an interface to support dynamic dispatch.
type IControl_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsControl_itemContext differentiates from other interfaces.
	IsControl_itemContext()
}

type Control_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControl_itemContext() *Control_itemContext {
	var p = new(Control_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_control_item
	return p
}

func (*Control_itemContext) IsControl_itemContext() {}

func NewControl_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Control_itemContext {
	var p = new(Control_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_control_item

	return p
}

func (s *Control_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Control_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Control_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Control_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Control_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterControl_item(s)
	}
}

func (s *Control_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitControl_item(s)
	}
}

func (p *SyslParser) Control_item() (localctx IControl_itemContext) {
	localctx = NewControl_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SyslParserRULE_control_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1394)
		p.Expr()
	}

	return localctx
}

// IIf_controlsContext is an interface to support dynamic dispatch.
type IIf_controlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_controlsContext differentiates from other interfaces.
	IsIf_controlsContext()
}

type If_controlsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_controlsContext() *If_controlsContext {
	var p = new(If_controlsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_controls
	return p
}

func (*If_controlsContext) IsIf_controlsContext() {}

func NewIf_controlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_controlsContext {
	var p = new(If_controlsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_controls

	return p
}

func (s *If_controlsContext) GetParser() antlr.Parser { return s.parser }

func (s *If_controlsContext) AllControl_item() []IControl_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IControl_itemContext)(nil)).Elem())
	var tst = make([]IControl_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IControl_itemContext)
		}
	}

	return tst
}

func (s *If_controlsContext) Control_item(i int) IControl_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControl_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IControl_itemContext)
}

func (s *If_controlsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *If_controlsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *If_controlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_controlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_controlsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_controls(s)
	}
}

func (s *If_controlsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_controls(s)
	}
}

func (p *SyslParser) If_controls() (localctx IIf_controlsContext) {
	localctx = NewIf_controlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SyslParserRULE_if_controls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1396)
		p.Control_item()
	}
	p.SetState(1401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1397)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1398)
			p.Control_item()
		}

		p.SetState(1403)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICond_blockContext is an interface to support dynamic dispatch.
type ICond_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_else_block_stmt returns the _else_block_stmt rule contexts.
	Get_else_block_stmt() IElse_block_stmtContext

	// Set_else_block_stmt sets the _else_block_stmt rule contexts.
	Set_else_block_stmt(IElse_block_stmtContext)

	// IsCond_blockContext differentiates from other interfaces.
	IsCond_blockContext()
}

type Cond_blockContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	_else_block_stmt IElse_block_stmtContext
}

func NewEmptyCond_blockContext() *Cond_blockContext {
	var p = new(Cond_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_cond_block
	return p
}

func (*Cond_blockContext) IsCond_blockContext() {}

func NewCond_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_blockContext {
	var p = new(Cond_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_cond_block

	return p
}

func (s *Cond_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_blockContext) Get_else_block_stmt() IElse_block_stmtContext { return s._else_block_stmt }

func (s *Cond_blockContext) Set_else_block_stmt(v IElse_block_stmtContext) { s._else_block_stmt = v }

func (s *Cond_blockContext) If_controls() IIf_controlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_controlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_controlsContext)
}

func (s *Cond_blockContext) E_EQ_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ_RIGHT, 0)
}

func (s *Cond_blockContext) Else_block_stmt() IElse_block_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_block_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_block_stmtContext)
}

func (s *Cond_blockContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Cond_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCond_block(s)
	}
}

func (s *Cond_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCond_block(s)
	}
}

func (p *SyslParser) Cond_block() (localctx ICond_blockContext) {
	localctx = NewCond_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SyslParserRULE_cond_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1404)
		p.If_controls()
	}
	{
		p.SetState(1405)
		p.Match(SyslParserE_EQ_RIGHT)
	}
	{
		p.SetState(1406)

		var _x = p.Else_block_stmt()

		localctx.(*Cond_blockContext)._else_block_stmt = _x
	}
	p.SetState(1409)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1407)

		if !(localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$else_block_stmt.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1408)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IFinal_elseContext is an interface to support dynamic dispatch.
type IFinal_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// IsFinal_elseContext differentiates from other interfaces.
	IsFinal_elseContext()
}

type Final_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_expr  IExprContext
}

func NewEmptyFinal_elseContext() *Final_elseContext {
	var p = new(Final_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_final_else
	return p
}

func (*Final_elseContext) IsFinal_elseContext() {}

func NewFinal_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Final_elseContext {
	var p = new(Final_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_final_else

	return p
}

func (s *Final_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Final_elseContext) Get_expr() IExprContext { return s._expr }

func (s *Final_elseContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Final_elseContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *Final_elseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Final_elseContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Final_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Final_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Final_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFinal_else(s)
	}
}

func (s *Final_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFinal_else(s)
	}
}

func (p *SyslParser) Final_else() (localctx IFinal_elseContext) {
	localctx = NewFinal_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SyslParserRULE_final_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1411)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1412)

		var _x = p.Expr()

		localctx.(*Final_elseContext)._expr = _x
	}
	p.SetState(1415)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1413)

		if !(localctx.(*Final_elseContext).Get_expr().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$expr.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1414)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IIfvarContext is an interface to support dynamic dispatch.
type IIfvarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfvarContext differentiates from other interfaces.
	IsIfvarContext()
}

type IfvarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfvarContext() *IfvarContext {
	var p = new(IfvarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ifvar
	return p
}

func (*IfvarContext) IsIfvarContext() {}

func NewIfvarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfvarContext {
	var p = new(IfvarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ifvar

	return p
}

func (s *IfvarContext) GetParser() antlr.Parser { return s.parser }

func (s *IfvarContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfvarContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *IfvarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfvarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfvarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIfvar(s)
	}
}

func (s *IfvarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIfvar(s)
	}
}

func (p *SyslParser) Ifvar() (localctx IIfvarContext) {
	localctx = NewIfvarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SyslParserRULE_ifvar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.Expr()
	}
	{
		p.SetState(1418)
		p.Match(SyslParserE_DOUBLE_EQ)
	}

	return localctx
}

// IIf_multiple_linesContext is an interface to support dynamic dispatch.
type IIf_multiple_linesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_multiple_linesContext differentiates from other interfaces.
	IsIf_multiple_linesContext()
}

type If_multiple_linesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_multiple_linesContext() *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_multiple_lines
	return p
}

func (*If_multiple_linesContext) IsIf_multiple_linesContext() {}

func NewIf_multiple_linesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_multiple_lines

	return p
}

func (s *If_multiple_linesContext) GetParser() antlr.Parser { return s.parser }

func (s *If_multiple_linesContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *If_multiple_linesContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *If_multiple_linesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_multiple_linesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_multiple_linesContext) Ifvar() IIfvarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfvarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfvarContext)
}

func (s *If_multiple_linesContext) AllCond_block() []ICond_blockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICond_blockContext)(nil)).Elem())
	var tst = make([]ICond_blockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICond_blockContext)
		}
	}

	return tst
}

func (s *If_multiple_linesContext) Cond_block(i int) ICond_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_blockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICond_blockContext)
}

func (s *If_multiple_linesContext) Final_else() IFinal_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinal_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinal_elseContext)
}

func (s *If_multiple_linesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_multiple_linesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_multiple_linesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_multiple_lines(s)
	}
}

func (s *If_multiple_linesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_multiple_lines(s)
	}
}

func (p *SyslParser) If_multiple_lines() (localctx IIf_multiple_linesContext) {
	localctx = NewIf_multiple_linesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SyslParserRULE_if_multiple_lines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(SyslParserE_WHATEVER-76))|(1<<(SyslParserE_ARROW_RIGHT-76))|(1<<(SyslParserE_SQ_OPEN-76))|(1<<(SyslParserE_EMPTY_TUPLE-76))|(1<<(SyslParserE_CURLY_OPEN-76))|(1<<(SyslParserE_NULLSAFE_DOT-76))|(1<<(SyslParserE_OPEN_PAREN-76))|(1<<(SyslParserE_PLUS-76))|(1<<(SyslParserE_MINUS-76))|(1<<(SyslParserE_QN-76))|(1<<(SyslParserE_TILDE-76))|(1<<(SyslParserE_NOT-76)))) != 0) || (((_la-114)&-(0x1f+1)) == 0 && ((1<<uint((_la-114)))&((1<<(SyslParserE_IF-114))|(1<<(SyslParserE_TRUE-114))|(1<<(SyslParserE_FALSE-114))|(1<<(SyslParserE_NULL-114))|(1<<(SyslParserE_FUNC-114))|(1<<(SyslParserE_STRING_DBL-114))|(1<<(SyslParserE_STRING_SINGLE-114))|(1<<(SyslParserE_DECIMAL-114))|(1<<(SyslParserE_DIGITS-114))|(1<<(SyslParserE_Name-114))|(1<<(SyslParserE_DOT-114)))) != 0) {
		{
			p.SetState(1420)
			p.Ifvar()
		}

	}
	{
		p.SetState(1423)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1424)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1425)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1427)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(SyslParserE_WHATEVER-76))|(1<<(SyslParserE_ARROW_RIGHT-76))|(1<<(SyslParserE_SQ_OPEN-76))|(1<<(SyslParserE_EMPTY_TUPLE-76))|(1<<(SyslParserE_CURLY_OPEN-76))|(1<<(SyslParserE_NULLSAFE_DOT-76))|(1<<(SyslParserE_OPEN_PAREN-76))|(1<<(SyslParserE_PLUS-76))|(1<<(SyslParserE_MINUS-76))|(1<<(SyslParserE_QN-76))|(1<<(SyslParserE_TILDE-76))|(1<<(SyslParserE_NOT-76)))) != 0) || (((_la-114)&-(0x1f+1)) == 0 && ((1<<uint((_la-114)))&((1<<(SyslParserE_IF-114))|(1<<(SyslParserE_TRUE-114))|(1<<(SyslParserE_FALSE-114))|(1<<(SyslParserE_NULL-114))|(1<<(SyslParserE_FUNC-114))|(1<<(SyslParserE_STRING_DBL-114))|(1<<(SyslParserE_STRING_SINGLE-114))|(1<<(SyslParserE_DECIMAL-114))|(1<<(SyslParserE_DIGITS-114))|(1<<(SyslParserE_Name-114))|(1<<(SyslParserE_DOT-114)))) != 0) {
		{
			p.SetState(1426)
			p.Cond_block()
		}

		p.SetState(1429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ELSE {
		{
			p.SetState(1431)
			p.Final_else()
		}

	}
	{
		p.SetState(1434)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IExpr_if_elseContext is an interface to support dynamic dispatch.
type IExpr_if_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_if_elseContext differentiates from other interfaces.
	IsExpr_if_elseContext()
}

type Expr_if_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
}

func NewEmptyExpr_if_elseContext() *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_if_else
	return p
}

func (*Expr_if_elseContext) IsExpr_if_elseContext() {}

func NewExpr_if_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_if_else

	return p
}

func (s *Expr_if_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_if_elseContext) GetNested() bool { return s.nested }

func (s *Expr_if_elseContext) SetNested(v bool) { s.nested = v }

func (s *Expr_if_elseContext) E_IF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_IF, 0)
}

func (s *Expr_if_elseContext) If_one_liner() IIf_one_linerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_one_linerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_one_linerContext)
}

func (s *Expr_if_elseContext) If_multiple_lines() IIf_multiple_linesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_multiple_linesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_multiple_linesContext)
}

func (s *Expr_if_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_if_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_if_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_if_else(s)
	}
}

func (s *Expr_if_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_if_else(s)
	}
}

func (p *SyslParser) Expr_if_else() (localctx IExpr_if_elseContext) {
	localctx = NewExpr_if_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SyslParserRULE_expr_if_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1436)
		p.Match(SyslParserE_IF)
	}
	p.SetState(1441)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1437)
			p.If_one_liner()
		}

	case 2:
		{
			p.SetState(1438)
			p.If_multiple_lines()
		}
		localctx.(*Expr_if_elseContext).SetNested(true)

	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_if_else returns the _expr_if_else rule contexts.
	Get_expr_if_else() IExpr_if_elseContext

	// Set_expr_if_else sets the _expr_if_else rule contexts.
	Set_expr_if_else(IExpr_if_elseContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	nested        bool
	_expr_if_else IExpr_if_elseContext
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) Get_expr_if_else() IExpr_if_elseContext { return s._expr_if_else }

func (s *ExprContext) Set_expr_if_else(v IExpr_if_elseContext) { s._expr_if_else = v }

func (s *ExprContext) GetNested() bool { return s.nested }

func (s *ExprContext) SetNested(v bool) { s.nested = v }

func (s *ExprContext) Expr_if_else() IExpr_if_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_if_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_if_elseContext)
}

func (s *ExprContext) Expr_coalesce() IExpr_coalesceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_coalesceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_coalesceContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *SyslParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SyslParserRULE_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1447)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_IF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1443)

			var _x = p.Expr_if_else()

			localctx.(*ExprContext)._expr_if_else = _x
		}
		localctx.(*ExprContext).SetNested(localctx.(*ExprContext).Get_expr_if_else().GetNested())

	case SyslParserNativeDataTypes, SyslParserE_WHATEVER, SyslParserE_ARROW_RIGHT, SyslParserE_SQ_OPEN, SyslParserE_EMPTY_TUPLE, SyslParserE_CURLY_OPEN, SyslParserE_NULLSAFE_DOT, SyslParserE_OPEN_PAREN, SyslParserE_PLUS, SyslParserE_MINUS, SyslParserE_QN, SyslParserE_TILDE, SyslParserE_NOT, SyslParserE_TRUE, SyslParserE_FALSE, SyslParserE_NULL, SyslParserE_FUNC, SyslParserE_STRING_DBL, SyslParserE_STRING_SINGLE, SyslParserE_DECIMAL, SyslParserE_DIGITS, SyslParserE_Name, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1446)
			p.Expr_coalesce()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpr_assignContext is an interface to support dynamic dispatch.
type IExpr_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_assignContext differentiates from other interfaces.
	IsExpr_assignContext()
}

type Expr_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyExpr_assignContext() *Expr_assignContext {
	var p = new(Expr_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_assign
	return p
}

func (*Expr_assignContext) IsExpr_assignContext() {}

func NewExpr_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_assignContext {
	var p = new(Expr_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_assign

	return p
}

func (s *Expr_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_assignContext) Get_expr() IExprContext { return s._expr }

func (s *Expr_assignContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Expr_assignContext) GetNested() bool { return s.nested }

func (s *Expr_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_assignContext) E_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ, 0)
}

func (s *Expr_assignContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_assignContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_assign(s)
	}
}

func (s *Expr_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_assign(s)
	}
}

func (p *SyslParser) Expr_assign() (localctx IExpr_assignContext) {
	localctx = NewExpr_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SyslParserRULE_expr_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1449)
		p.Match(SyslParserE_EQ)
	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1450)

			var _x = p.Expr()

			localctx.(*Expr_assignContext)._expr = _x
		}
		localctx.(*Expr_assignContext).SetNested(localctx.(*Expr_assignContext).Get_expr().GetNested())

	case 2:
		{
			p.SetState(1453)
			p.Transform()
		}
		localctx.(*Expr_assignContext).SetNested(true)

	}

	return localctx
}

// IExpr_simple_assignContext is an interface to support dynamic dispatch.
type IExpr_simple_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_simple_assignContext differentiates from other interfaces.
	IsExpr_simple_assignContext()
}

type Expr_simple_assignContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_simple_assignContext() *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_simple_assign
	return p
}

func (*Expr_simple_assignContext) IsExpr_simple_assignContext() {}

func NewExpr_simple_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_simple_assign

	return p
}

func (s *Expr_simple_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_simple_assignContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_simple_assignContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_simple_assignContext) GetNested() bool { return s.nested }

func (s *Expr_simple_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_simple_assignContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_simple_assignContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_simple_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_simple_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_simple_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_simple_assign(s)
	}
}

func (s *Expr_simple_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_simple_assign(s)
	}
}

func (p *SyslParser) Expr_simple_assign() (localctx IExpr_simple_assignContext) {
	localctx = NewExpr_simple_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SyslParserRULE_expr_simple_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1458)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1459)

		var _x = p.Expr_assign()

		localctx.(*Expr_simple_assignContext)._expr_assign = _x
	}
	localctx.(*Expr_simple_assignContext).SetNested(localctx.(*Expr_simple_assignContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_let_statementContext is an interface to support dynamic dispatch.
type IExpr_let_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_let_statementContext differentiates from other interfaces.
	IsExpr_let_statementContext()
}

type Expr_let_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_let_statementContext() *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_let_statement
	return p
}

func (*Expr_let_statementContext) IsExpr_let_statementContext() {}

func NewExpr_let_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_let_statement

	return p
}

func (s *Expr_let_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_let_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_let_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_let_statementContext) GetNested() bool { return s.nested }

func (s *Expr_let_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_let_statementContext) E_LET() antlr.TerminalNode {
	return s.GetToken(SyslParserE_LET, 0)
}

func (s *Expr_let_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_let_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_let_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_let_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_let_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_let_statement(s)
	}
}

func (s *Expr_let_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_let_statement(s)
	}
}

func (p *SyslParser) Expr_let_statement() (localctx IExpr_let_statementContext) {
	localctx = NewExpr_let_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SyslParserRULE_expr_let_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1462)
		p.Match(SyslParserE_LET)
	}
	{
		p.SetState(1463)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1464)

		var _x = p.Expr_assign()

		localctx.(*Expr_let_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_let_statementContext).SetNested(localctx.(*Expr_let_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_table_of_statementContext is an interface to support dynamic dispatch.
type IExpr_table_of_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_table_of_statementContext differentiates from other interfaces.
	IsExpr_table_of_statementContext()
}

type Expr_table_of_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_table_of_statementContext() *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_statement
	return p
}

func (*Expr_table_of_statementContext) IsExpr_table_of_statementContext() {}

func NewExpr_table_of_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_statement

	return p
}

func (s *Expr_table_of_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_table_of_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_table_of_statementContext) GetNested() bool { return s.nested }

func (s *Expr_table_of_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_table_of_statementContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_table_of_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_statement(s)
	}
}

func (s *Expr_table_of_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_statement(s)
	}
}

func (p *SyslParser) Expr_table_of_statement() (localctx IExpr_table_of_statementContext) {
	localctx = NewExpr_table_of_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SyslParserRULE_expr_table_of_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1467)
		p.Match(SyslParserE_TABLE_OF)
	}
	{
		p.SetState(1468)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1469)

		var _x = p.Expr_assign()

		localctx.(*Expr_table_of_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_table_of_statementContext).SetNested(localctx.(*Expr_table_of_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_dot_assignContext is an interface to support dynamic dispatch.
type IExpr_dot_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_dot_assignContext differentiates from other interfaces.
	IsExpr_dot_assignContext()
}

type Expr_dot_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_assignContext() *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_dot_assign
	return p
}

func (*Expr_dot_assignContext) IsExpr_dot_assignContext() {}

func NewExpr_dot_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_dot_assign

	return p
}

func (s *Expr_dot_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_assignContext) E_DOT_NAME_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT_NAME_NL, 0)
}

func (s *Expr_dot_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dot_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_dot_assign(s)
	}
}

func (s *Expr_dot_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_dot_assign(s)
	}
}

func (p *SyslParser) Expr_dot_assign() (localctx IExpr_dot_assignContext) {
	localctx = NewExpr_dot_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SyslParserRULE_expr_dot_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1472)
		p.Match(SyslParserE_DOT_NAME_NL)
	}

	return localctx
}

// IExpr_statement_no_nlContext is an interface to support dynamic dispatch.
type IExpr_statement_no_nlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_statement_no_nlContext differentiates from other interfaces.
	IsExpr_statement_no_nlContext()
}

type Expr_statement_no_nlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_statement_no_nlContext() *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl
	return p
}

func (*Expr_statement_no_nlContext) IsExpr_statement_no_nlContext() {}

func NewExpr_statement_no_nlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl

	return p
}

func (s *Expr_statement_no_nlContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statement_no_nlContext) Expr_dot_assign() IExpr_dot_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_dot_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_assignContext)
}

func (s *Expr_statement_no_nlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statement_no_nlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statement_no_nlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement_no_nl(s)
	}
}

func (s *Expr_statement_no_nlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement_no_nl(s)
	}
}

func (p *SyslParser) Expr_statement_no_nl() (localctx IExpr_statement_no_nlContext) {
	localctx = NewExpr_statement_no_nlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SyslParserRULE_expr_statement_no_nl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1474)
		p.Expr_dot_assign()
	}

	return localctx
}

// ITemplate_expressionContext is an interface to support dynamic dispatch.
type ITemplate_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_expressionContext differentiates from other interfaces.
	IsTemplate_expressionContext()
}

type Template_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_expressionContext() *Template_expressionContext {
	var p = new(Template_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_template_expression
	return p
}

func (*Template_expressionContext) IsTemplate_expressionContext() {}

func NewTemplate_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_expressionContext {
	var p = new(Template_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_template_expression

	return p
}

func (s *Template_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_expressionContext) TMPL_TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTMPL_TEXT, 0)
}

func (s *Template_expressionContext) E_RAW_TEXT_END() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RAW_TEXT_END, 0)
}

func (s *Template_expressionContext) E_RAW_TEXT_START() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RAW_TEXT_START, 0)
}

func (s *Template_expressionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *Template_expressionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Template_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTemplate_expression(s)
	}
}

func (s *Template_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTemplate_expression(s)
	}
}

func (p *SyslParser) Template_expression() (localctx ITemplate_expressionContext) {
	localctx = NewTemplate_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SyslParserRULE_template_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1485)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTMPL_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1476)
			p.Match(SyslParserTMPL_TEXT)
		}

	case SyslParserE_RAW_TEXT_END:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1477)
			p.Match(SyslParserE_RAW_TEXT_END)
		}
		p.SetState(1481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserNativeDataTypes || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(SyslParserE_WHATEVER-76))|(1<<(SyslParserE_ARROW_RIGHT-76))|(1<<(SyslParserE_SQ_OPEN-76))|(1<<(SyslParserE_EMPTY_TUPLE-76))|(1<<(SyslParserE_CURLY_OPEN-76))|(1<<(SyslParserE_NULLSAFE_DOT-76))|(1<<(SyslParserE_OPEN_PAREN-76))|(1<<(SyslParserE_PLUS-76))|(1<<(SyslParserE_MINUS-76))|(1<<(SyslParserE_QN-76))|(1<<(SyslParserE_TILDE-76))|(1<<(SyslParserE_NOT-76)))) != 0) || (((_la-114)&-(0x1f+1)) == 0 && ((1<<uint((_la-114)))&((1<<(SyslParserE_IF-114))|(1<<(SyslParserE_TRUE-114))|(1<<(SyslParserE_FALSE-114))|(1<<(SyslParserE_NULL-114))|(1<<(SyslParserE_FUNC-114))|(1<<(SyslParserE_STRING_DBL-114))|(1<<(SyslParserE_STRING_SINGLE-114))|(1<<(SyslParserE_DECIMAL-114))|(1<<(SyslParserE_DIGITS-114))|(1<<(SyslParserE_Name-114))|(1<<(SyslParserE_DOT-114)))) != 0) {
			{
				p.SetState(1478)
				p.Expr()
			}

			p.SetState(1483)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1484)
			p.Match(SyslParserE_RAW_TEXT_START)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITemplate_statementContext is an interface to support dynamic dispatch.
type ITemplate_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_statementContext differentiates from other interfaces.
	IsTemplate_statementContext()
}

type Template_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_statementContext() *Template_statementContext {
	var p = new(Template_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_template_statement
	return p
}

func (*Template_statementContext) IsTemplate_statementContext() {}

func NewTemplate_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_statementContext {
	var p = new(Template_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_template_statement

	return p
}

func (s *Template_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_statementContext) E_RAW_TEXT_START() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RAW_TEXT_START, 0)
}

func (s *Template_statementContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Template_statementContext) TMPL_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserTMPL_NL, 0)
}

func (s *Template_statementContext) TMPL_DEBUG() antlr.TerminalNode {
	return s.GetToken(SyslParserTMPL_DEBUG, 0)
}

func (s *Template_statementContext) AllTemplate_expression() []ITemplate_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITemplate_expressionContext)(nil)).Elem())
	var tst = make([]ITemplate_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITemplate_expressionContext)
		}
	}

	return tst
}

func (s *Template_statementContext) Template_expression(i int) ITemplate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITemplate_expressionContext)
}

func (s *Template_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTemplate_statement(s)
	}
}

func (s *Template_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTemplate_statement(s)
	}
}

func (p *SyslParser) Template_statement() (localctx ITemplate_statementContext) {
	localctx = NewTemplate_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SyslParserRULE_template_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1487)
		p.Match(SyslParserE_RAW_TEXT_START)
	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserTMPL_DEBUG {
		{
			p.SetState(1488)
			p.Match(SyslParserTMPL_DEBUG)
		}

	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_RAW_TEXT_END || _la == SyslParserTMPL_TEXT {
		{
			p.SetState(1491)
			p.Template_expression()
		}

		p.SetState(1496)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1497)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_NL || _la == SyslParserTMPL_NL) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_statementContext is an interface to support dynamic dispatch.
type IExpr_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_let_statement returns the _expr_let_statement rule contexts.
	Get_expr_let_statement() IExpr_let_statementContext

	// Get_expr_table_of_statement returns the _expr_table_of_statement rule contexts.
	Get_expr_table_of_statement() IExpr_table_of_statementContext

	// Get_expr_simple_assign returns the _expr_simple_assign rule contexts.
	Get_expr_simple_assign() IExpr_simple_assignContext

	// Set_expr_let_statement sets the _expr_let_statement rule contexts.
	Set_expr_let_statement(IExpr_let_statementContext)

	// Set_expr_table_of_statement sets the _expr_table_of_statement rule contexts.
	Set_expr_table_of_statement(IExpr_table_of_statementContext)

	// Set_expr_simple_assign sets the _expr_simple_assign rule contexts.
	Set_expr_simple_assign(IExpr_simple_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_statementContext differentiates from other interfaces.
	IsExpr_statementContext()
}

type Expr_statementContext struct {
	*antlr.BaseParserRuleContext
	parser                   antlr.Parser
	nested                   bool
	_expr_let_statement      IExpr_let_statementContext
	_expr_table_of_statement IExpr_table_of_statementContext
	_expr_simple_assign      IExpr_simple_assignContext
}

func NewEmptyExpr_statementContext() *Expr_statementContext {
	var p = new(Expr_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement
	return p
}

func (*Expr_statementContext) IsExpr_statementContext() {}

func NewExpr_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statementContext {
	var p = new(Expr_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement

	return p
}

func (s *Expr_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statementContext) Get_expr_let_statement() IExpr_let_statementContext {
	return s._expr_let_statement
}

func (s *Expr_statementContext) Get_expr_table_of_statement() IExpr_table_of_statementContext {
	return s._expr_table_of_statement
}

func (s *Expr_statementContext) Get_expr_simple_assign() IExpr_simple_assignContext {
	return s._expr_simple_assign
}

func (s *Expr_statementContext) Set_expr_let_statement(v IExpr_let_statementContext) {
	s._expr_let_statement = v
}

func (s *Expr_statementContext) Set_expr_table_of_statement(v IExpr_table_of_statementContext) {
	s._expr_table_of_statement = v
}

func (s *Expr_statementContext) Set_expr_simple_assign(v IExpr_simple_assignContext) {
	s._expr_simple_assign = v
}

func (s *Expr_statementContext) GetNested() bool { return s.nested }

func (s *Expr_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_statementContext) Expr_let_statement() IExpr_let_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_let_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_let_statementContext)
}

func (s *Expr_statementContext) Expr_table_of_statement() IExpr_table_of_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_statementContext)
}

func (s *Expr_statementContext) Expr_simple_assign() IExpr_simple_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_simple_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_simple_assignContext)
}

func (s *Expr_statementContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement(s)
	}
}

func (s *Expr_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement(s)
	}
}

func (p *SyslParser) Expr_statement() (localctx IExpr_statementContext) {
	localctx = NewExpr_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SyslParserRULE_expr_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_LET:
		{
			p.SetState(1499)

			var _x = p.Expr_let_statement()

			localctx.(*Expr_statementContext)._expr_let_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_let_statement().GetNested())

	case SyslParserE_TABLE_OF:
		{
			p.SetState(1502)

			var _x = p.Expr_table_of_statement()

			localctx.(*Expr_statementContext)._expr_table_of_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_table_of_statement().GetNested())

	case SyslParserE_Name:
		{
			p.SetState(1505)

			var _x = p.Expr_simple_assign()

			localctx.(*Expr_statementContext)._expr_simple_assign = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_simple_assign().GetNested())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1512)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1510)

		if !(localctx.(*Expr_statementContext).nested == true) {
			panic(antlr.NewFailedPredicateException(p, "$nested == true", ""))
		}

	case 2:
		{
			p.SetState(1511)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IExpr_inject_stmtContext is an interface to support dynamic dispatch.
type IExpr_inject_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_inject_stmtContext differentiates from other interfaces.
	IsExpr_inject_stmtContext()
}

type Expr_inject_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_inject_stmtContext() *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_inject_stmt
	return p
}

func (*Expr_inject_stmtContext) IsExpr_inject_stmtContext() {}

func NewExpr_inject_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_inject_stmt

	return p
}

func (s *Expr_inject_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_inject_stmtContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_inject_stmtContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_inject_stmtContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *Expr_inject_stmtContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_inject_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_inject_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_inject_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_inject_stmt(s)
	}
}

func (s *Expr_inject_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_inject_stmt(s)
	}
}

func (p *SyslParser) Expr_inject_stmt() (localctx IExpr_inject_stmtContext) {
	localctx = NewExpr_inject_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SyslParserRULE_expr_inject_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1514)
		p.Expr_func()
	}
	{
		p.SetState(1515)
		p.Match(SyslParserE_DOT)
	}
	{
		p.SetState(1516)
		p.Match(SyslParserE_STAR)
	}
	{
		p.SetState(1517)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_stmt
	return p
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) Expr_statement_no_nl() IExpr_statement_no_nlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statement_no_nlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statement_no_nlContext)
}

func (s *Expr_stmtContext) Expr_statement() IExpr_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statementContext)
}

func (s *Expr_stmtContext) Expr_inject_stmt() IExpr_inject_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_inject_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_inject_stmtContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (p *SyslParser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SyslParserRULE_expr_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1522)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1519)
			p.Expr_statement_no_nl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1520)
			p.Expr_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1521)
			p.Expr_inject_stmt()
		}

	}

	return localctx
}

// ITransform_return_typeContext is an interface to support dynamic dispatch.
type ITransform_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_return_typeContext differentiates from other interfaces.
	IsTransform_return_typeContext()
}

type Transform_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_return_typeContext() *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_return_type
	return p
}

func (*Transform_return_typeContext) IsTransform_return_typeContext() {}

func NewTransform_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_return_type

	return p
}

func (s *Transform_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_return_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Transform_return_typeContext) Sequence_of() ISequence_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_ofContext)
}

func (s *Transform_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Transform_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_return_type(s)
	}
}

func (s *Transform_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_return_type(s)
	}
}

func (p *SyslParser) Transform_return_type() (localctx ITransform_return_typeContext) {
	localctx = NewTransform_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SyslParserRULE_transform_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1527)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1524)
			p.Set_of()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1525)
			p.Sequence_of()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1526)
			p.View_type_spec()
		}

	}

	return localctx
}

// IView_return_typeContext is an interface to support dynamic dispatch.
type IView_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_return_typeContext differentiates from other interfaces.
	IsView_return_typeContext()
}

type View_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_return_typeContext() *View_return_typeContext {
	var p = new(View_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_return_type
	return p
}

func (*View_return_typeContext) IsView_return_typeContext() {}

func NewView_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_return_typeContext {
	var p = new(View_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_return_type

	return p
}

func (s *View_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *View_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_return_type(s)
	}
}

func (s *View_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_return_type(s)
	}
}

func (p *SyslParser) View_return_type() (localctx IView_return_typeContext) {
	localctx = NewView_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SyslParserRULE_view_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1529)
		p.View_type_spec()
	}

	return localctx
}

// ITransform_scope_varContext is an interface to support dynamic dispatch.
type ITransform_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_scope_varContext differentiates from other interfaces.
	IsTransform_scope_varContext()
}

type Transform_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_scope_varContext() *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_scope_var
	return p
}

func (*Transform_scope_varContext) IsTransform_scope_varContext() {}

func NewTransform_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_scope_var

	return p
}

func (s *Transform_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Transform_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_scope_var(s)
	}
}

func (s *Transform_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_scope_var(s)
	}
}

func (p *SyslParser) Transform_scope_var() (localctx ITransform_scope_varContext) {
	localctx = NewTransform_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SyslParserRULE_transform_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1531)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// ITransform_argContext is an interface to support dynamic dispatch.
type ITransform_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_argContext differentiates from other interfaces.
	IsTransform_argContext()
}

type Transform_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_argContext() *Transform_argContext {
	var p = new(Transform_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_arg
	return p
}

func (*Transform_argContext) IsTransform_argContext() {}

func NewTransform_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_argContext {
	var p = new(Transform_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_arg

	return p
}

func (s *Transform_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Transform_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_arg(s)
	}
}

func (s *Transform_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_arg(s)
	}
}

func (p *SyslParser) Transform_arg() (localctx ITransform_argContext) {
	localctx = NewTransform_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SyslParserRULE_transform_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1533)
		p.Expr()
	}

	return localctx
}

// ITransformContext is an interface to support dynamic dispatch.
type ITransformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransformContext differentiates from other interfaces.
	IsTransformContext()
}

type TransformContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformContext() *TransformContext {
	var p = new(TransformContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform
	return p
}

func (*TransformContext) IsTransformContext() {}

func NewTransformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformContext {
	var p = new(TransformContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform

	return p
}

func (s *TransformContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *TransformContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *TransformContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *TransformContext) AllE_NL() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_NL)
}

func (s *TransformContext) E_NL(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, i)
}

func (s *TransformContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *TransformContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *TransformContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *TransformContext) Transform_arg() ITransform_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_argContext)
}

func (s *TransformContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *TransformContext) Transform_return_type() ITransform_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_return_typeContext)
}

func (s *TransformContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *TransformContext) Transform_scope_var() ITransform_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_scope_varContext)
}

func (s *TransformContext) AllExpr_stmt() []IExpr_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem())
	var tst = make([]IExpr_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_stmtContext)
		}
	}

	return tst
}

func (s *TransformContext) Expr_stmt(i int) IExpr_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *TransformContext) AllTemplate_statement() []ITemplate_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITemplate_statementContext)(nil)).Elem())
	var tst = make([]ITemplate_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITemplate_statementContext)
		}
	}

	return tst
}

func (s *TransformContext) Template_statement(i int) ITemplate_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITemplate_statementContext)
}

func (s *TransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform(s)
	}
}

func (s *TransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform(s)
	}
}

func (p *SyslParser) Transform() (localctx ITransformContext) {
	localctx = NewTransformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SyslParserRULE_transform)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1536)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1535)
			p.Transform_arg()
		}

	}
	{
		p.SetState(1538)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1543)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1539)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1540)
			p.Transform_return_type()
		}
		{
			p.SetState(1541)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1545)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1547)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_Name {
		{
			p.SetState(1546)
			p.Transform_scope_var()
		}

	}
	{
		p.SetState(1549)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1550)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1551)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || _la == SyslParserE_TABLE_OF || _la == SyslParserE_LET || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(SyslParserE_FUNC-135))|(1<<(SyslParserE_RAW_TEXT_START-135))|(1<<(SyslParserE_DOT_NAME_NL-135))|(1<<(SyslParserE_Name-135)))) != 0) {
		p.SetState(1554)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserE_TABLE_OF, SyslParserE_LET, SyslParserE_FUNC, SyslParserE_DOT_NAME_NL, SyslParserE_Name:
			{
				p.SetState(1552)
				p.Expr_stmt()
			}

		case SyslParserE_RAW_TEXT_START:
			{
				p.SetState(1553)
				p.Template_statement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1558)
		p.Match(SyslParserDEDENT)
	}
	{
		p.SetState(1559)
		p.Match(SyslParserE_CLOSE_PAREN)
	}
	{
		p.SetState(1560)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_blockContext is an interface to support dynamic dispatch.
type IExpr_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_blockContext differentiates from other interfaces.
	IsExpr_blockContext()
}

type Expr_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_blockContext() *Expr_blockContext {
	var p = new(Expr_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_block
	return p
}

func (*Expr_blockContext) IsExpr_blockContext() {}

func NewExpr_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_blockContext {
	var p = new(Expr_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_block

	return p
}

func (s *Expr_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_blockContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Expr_blockContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_blockContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Expr_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_block(s)
	}
}

func (s *Expr_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_block(s)
	}
}

func (p *SyslParser) Expr_block() (localctx IExpr_blockContext) {
	localctx = NewExpr_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SyslParserRULE_expr_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1562)
		p.Match(SyslParserINDENT)
	}
	{
		p.SetState(1563)
		p.Transform()
	}
	{
		p.SetState(1564)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IView_paramContext is an interface to support dynamic dispatch.
type IView_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramContext differentiates from other interfaces.
	IsView_paramContext()
}

type View_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramContext() *View_paramContext {
	var p = new(View_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_param
	return p
}

func (*View_paramContext) IsView_paramContext() {}

func NewView_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramContext {
	var p = new(View_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_param

	return p
}

func (s *View_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *View_paramContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *View_paramContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_param(s)
	}
}

func (s *View_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_param(s)
	}
}

func (p *SyslParser) View_param() (localctx IView_paramContext) {
	localctx = NewView_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SyslParserRULE_view_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1566)
		p.Name_str()
	}
	{
		p.SetState(1567)
		p.Match(SyslParserLESS_COLON)
	}
	{
		p.SetState(1568)
		p.View_type_spec()
	}

	return localctx
}

// IView_paramsContext is an interface to support dynamic dispatch.
type IView_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramsContext differentiates from other interfaces.
	IsView_paramsContext()
}

type View_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramsContext() *View_paramsContext {
	var p = new(View_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_params
	return p
}

func (*View_paramsContext) IsView_paramsContext() {}

func NewView_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramsContext {
	var p = new(View_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_params

	return p
}

func (s *View_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramsContext) AllView_param() []IView_paramContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IView_paramContext)(nil)).Elem())
	var tst = make([]IView_paramContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IView_paramContext)
		}
	}

	return tst
}

func (s *View_paramsContext) View_param(i int) IView_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IView_paramContext)
}

func (s *View_paramsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *View_paramsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *View_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_params(s)
	}
}

func (s *View_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_params(s)
	}
}

func (p *SyslParser) View_params() (localctx IView_paramsContext) {
	localctx = NewView_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SyslParserRULE_view_params)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1570)
		p.View_param()
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(1571)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(1572)
			p.View_param()
		}

		p.SetState(1577)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAbstract_viewContext is an interface to support dynamic dispatch.
type IAbstract_viewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_viewContext differentiates from other interfaces.
	IsAbstract_viewContext()
}

type Abstract_viewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_viewContext() *Abstract_viewContext {
	var p = new(Abstract_viewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_abstract_view
	return p
}

func (*Abstract_viewContext) IsAbstract_viewContext() {}

func NewAbstract_viewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_viewContext {
	var p = new(Abstract_viewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_abstract_view

	return p
}

func (s *Abstract_viewContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_viewContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(SyslParserABSTRACT, 0)
}

func (s *Abstract_viewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_viewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Abstract_viewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAbstract_view(s)
	}
}

func (s *Abstract_viewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAbstract_view(s)
	}
}

func (p *SyslParser) Abstract_view() (localctx IAbstract_viewContext) {
	localctx = NewAbstract_viewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, SyslParserRULE_abstract_view)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1578)
		p.Match(SyslParserABSTRACT)
	}

	return localctx
}

// IViewContext is an interface to support dynamic dispatch.
type IViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAbstractView returns the abstractView attribute.
	GetAbstractView() bool

	// SetAbstractView sets the abstractView attribute.
	SetAbstractView(bool)

	// IsViewContext differentiates from other interfaces.
	IsViewContext()
}

type ViewContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	abstractView bool
}

func NewEmptyViewContext() *ViewContext {
	var p = new(ViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view
	return p
}

func (*ViewContext) IsViewContext() {}

func NewViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewContext {
	var p = new(ViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view

	return p
}

func (s *ViewContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewContext) GetAbstractView() bool { return s.abstractView }

func (s *ViewContext) SetAbstractView(v bool) { s.abstractView = v }

func (s *ViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SyslParserVIEW, 0)
}

func (s *ViewContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ViewContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ViewContext) View_params() IView_paramsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_paramsContext)
}

func (s *ViewContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ViewContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ViewContext) Expr_block() IExpr_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_blockContext)
}

func (s *ViewContext) Abstract_view() IAbstract_viewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_viewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_viewContext)
}

func (s *ViewContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *ViewContext) View_return_type() IView_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_return_typeContext)
}

func (s *ViewContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *ViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView(s)
	}
}

func (s *ViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView(s)
	}
}

func (p *SyslParser) View() (localctx IViewContext) {
	localctx = NewViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SyslParserRULE_view)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1580)
		p.Match(SyslParserVIEW)
	}
	{
		p.SetState(1581)
		p.Name_str()
	}
	{
		p.SetState(1582)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(1583)
		p.View_params()
	}
	{
		p.SetState(1584)
		p.Match(SyslParserCLOSE_PAREN)
	}
	p.SetState(1587)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserARROW_RIGHT {
		{
			p.SetState(1585)
			p.Match(SyslParserARROW_RIGHT)
		}
		{
			p.SetState(1586)
			p.View_return_type()
		}

	}
	p.SetState(1597)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserCOLON, SyslParserSQ_OPEN:
		p.SetState(1590)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(1589)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(1592)
			p.Match(SyslParserCOLON)
		}
		{
			p.SetState(1593)
			p.Expr_block()
		}

	case SyslParserABSTRACT:
		{
			p.SetState(1594)
			p.Abstract_view()
		}
		localctx.(*ViewContext).SetAbstractView(true)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(SyslParserALIAS, 0)
}

func (s *AliasContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *AliasContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *AliasContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *AliasContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *AliasContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *AliasContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *AliasContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *AliasContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AliasContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (p *SyslParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SyslParserRULE_alias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1599)
		p.Match(SyslParserALIAS)
	}
	{
		p.SetState(1600)
		p.Name_str()
	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1601)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1604)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1628)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes, SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserAT, SyslParserTEXT_LINE, SyslParserName, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF, SyslParserE_Name:
		p.SetState(1608)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserAT {
			{
				p.SetState(1605)
				p.Annotation()
			}

			p.SetState(1610)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1613)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(1611)
				p.Types()
			}

		case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
			{
				p.SetState(1612)
				p.Collection_type()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case SyslParserINDENT:
		{
			p.SetState(1615)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserAT {
			{
				p.SetState(1616)
				p.Annotation()
			}

			p.SetState(1621)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1624)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(1622)
				p.Types()
			}

		case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
			{
				p.SetState(1623)
				p.Collection_type()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1626)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumerationContext is an interface to support dynamic dispatch.
type IEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationContext differentiates from other interfaces.
	IsEnumerationContext()
}

type EnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationContext() *EnumerationContext {
	var p = new(EnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_enumeration
	return p
}

func (*EnumerationContext) IsEnumerationContext() {}

func NewEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationContext {
	var p = new(EnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_enumeration

	return p
}

func (s *EnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *EnumerationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *EnumerationContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, 0)
}

func (s *EnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEnumeration(s)
	}
}

func (s *EnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEnumeration(s)
	}
}

func (p *SyslParser) Enumeration() (localctx IEnumerationContext) {
	localctx = NewEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, SyslParserRULE_enumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1630)
		p.Match(SyslParserName)
	}
	{
		p.SetState(1631)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(1632)
		p.Match(SyslParserDIGITS)
	}

	return localctx
}

// IEnum_stmtsContext is an interface to support dynamic dispatch.
type IEnum_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_stmtsContext differentiates from other interfaces.
	IsEnum_stmtsContext()
}

type Enum_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_stmtsContext() *Enum_stmtsContext {
	var p = new(Enum_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_enum_stmts
	return p
}

func (*Enum_stmtsContext) IsEnum_stmtsContext() {}

func NewEnum_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_stmtsContext {
	var p = new(Enum_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_enum_stmts

	return p
}

func (s *Enum_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_stmtsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Enum_stmtsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Enum_stmtsContext) AllEnumeration() []IEnumerationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumerationContext)(nil)).Elem())
	var tst = make([]IEnumerationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumerationContext)
		}
	}

	return tst
}

func (s *Enum_stmtsContext) Enumeration(i int) IEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumerationContext)
}

func (s *Enum_stmtsContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *Enum_stmtsContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *Enum_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEnum_stmts(s)
	}
}

func (s *Enum_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEnum_stmts(s)
	}
}

func (p *SyslParser) Enum_stmts() (localctx IEnum_stmtsContext) {
	localctx = NewEnum_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SyslParserRULE_enum_stmts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1634)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserWHATEVER || _la == SyslParserName {
		p.SetState(1637)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserName:
			{
				p.SetState(1635)
				p.Enumeration()
			}

		case SyslParserWHATEVER:
			{
				p.SetState(1636)
				p.Match(SyslParserWHATEVER)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1639)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1641)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IEnumContext is an interface to support dynamic dispatch.
type IEnumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumContext differentiates from other interfaces.
	IsEnumContext()
}

type EnumContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumContext() *EnumContext {
	var p = new(EnumContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_enum
	return p
}

func (*EnumContext) IsEnumContext() {}

func NewEnumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumContext {
	var p = new(EnumContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_enum

	return p
}

func (s *EnumContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumContext) ENUM() antlr.TerminalNode {
	return s.GetToken(SyslParserENUM, 0)
}

func (s *EnumContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *EnumContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *EnumContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *EnumContext) Enum_stmts() IEnum_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_stmtsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_stmtsContext)
}

func (s *EnumContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *EnumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEnum(s)
	}
}

func (s *EnumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEnum(s)
	}
}

func (p *SyslParser) Enum() (localctx IEnumContext) {
	localctx = NewEnumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SyslParserRULE_enum)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1643)
		p.Match(SyslParserENUM)
	}
	{
		p.SetState(1644)
		p.Match(SyslParserName)
	}
	p.SetState(1646)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1645)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1648)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1649)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1650)
			p.Enum_stmts()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IApp_declContext is an interface to support dynamic dispatch.
type IApp_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_view returns the _view rule contexts.
	Get_view() IViewContext

	// Set_view sets the _view rule contexts.
	Set_view(IViewContext)

	// GetCheck returns the check attribute.
	GetCheck() bool

	// SetCheck sets the check attribute.
	SetCheck(bool)

	// IsApp_declContext differentiates from other interfaces.
	IsApp_declContext()
}

type App_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	check  bool
	_view  IViewContext
}

func NewEmptyApp_declContext() *App_declContext {
	var p = new(App_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_decl
	return p
}

func (*App_declContext) IsApp_declContext() {}

func NewApp_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_declContext {
	var p = new(App_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_decl

	return p
}

func (s *App_declContext) GetParser() antlr.Parser { return s.parser }

func (s *App_declContext) Get_view() IViewContext { return s._view }

func (s *App_declContext) Set_view(v IViewContext) { s._view = v }

func (s *App_declContext) GetCheck() bool { return s.check }

func (s *App_declContext) SetCheck(v bool) { s.check = v }

func (s *App_declContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *App_declContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *App_declContext) AllAlias() []IAliasContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAliasContext)(nil)).Elem())
	var tst = make([]IAliasContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAliasContext)
		}
	}

	return tst
}

func (s *App_declContext) Alias(i int) IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *App_declContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *App_declContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *App_declContext) AllCollector() []ICollectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollectorContext)(nil)).Elem())
	var tst = make([]ICollectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollectorContext)
		}
	}

	return tst
}

func (s *App_declContext) Collector(i int) ICollectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollectorContext)
}

func (s *App_declContext) AllEnum() []IEnumContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumContext)(nil)).Elem())
	var tst = make([]IEnumContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumContext)
		}
	}

	return tst
}

func (s *App_declContext) Enum(i int) IEnumContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumContext)
}

func (s *App_declContext) AllEvent() []IEventContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEventContext)(nil)).Elem())
	var tst = make([]IEventContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEventContext)
		}
	}

	return tst
}

func (s *App_declContext) Event(i int) IEventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEventContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEventContext)
}

func (s *App_declContext) AllFacade() []IFacadeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFacadeContext)(nil)).Elem())
	var tst = make([]IFacadeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFacadeContext)
		}
	}

	return tst
}

func (s *App_declContext) Facade(i int) IFacadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFacadeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFacadeContext)
}

func (s *App_declContext) AllMixin() []IMixinContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMixinContext)(nil)).Elem())
	var tst = make([]IMixinContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMixinContext)
		}
	}

	return tst
}

func (s *App_declContext) Mixin(i int) IMixinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMixinContext)
}

func (s *App_declContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *App_declContext) AllSimple_endpoint() []ISimple_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem())
	var tst = make([]ISimple_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Simple_endpoint(i int) ISimple_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_endpointContext)
}

func (s *App_declContext) AllSubscribe() []ISubscribeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscribeContext)(nil)).Elem())
	var tst = make([]ISubscribeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscribeContext)
		}
	}

	return tst
}

func (s *App_declContext) Subscribe(i int) ISubscribeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscribeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscribeContext)
}

func (s *App_declContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *App_declContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *App_declContext) AllUnion() []IUnionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionContext)(nil)).Elem())
	var tst = make([]IUnionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionContext)
		}
	}

	return tst
}

func (s *App_declContext) Union(i int) IUnionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionContext)
}

func (s *App_declContext) AllView() []IViewContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IViewContext)(nil)).Elem())
	var tst = make([]IViewContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IViewContext)
		}
	}

	return tst
}

func (s *App_declContext) View(i int) IViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IViewContext)
}

func (s *App_declContext) AllTable() []ITableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableContext)(nil)).Elem())
	var tst = make([]ITableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableContext)
		}
	}

	return tst
}

func (s *App_declContext) Table(i int) ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *App_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_decl(s)
	}
}

func (s *App_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_decl(s)
	}
}

func (p *SyslParser) App_decl() (localctx IApp_declContext) {
	localctx = NewApp_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, SyslParserRULE_app_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1653)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1670)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1670)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1654)
					p.Alias()
				}

			case 2:
				{
					p.SetState(1655)
					p.Annotation()
				}

			case 3:
				{
					p.SetState(1656)
					p.Collector()
				}

			case 4:
				{
					p.SetState(1657)
					p.Enum()
				}

			case 5:
				{
					p.SetState(1658)
					p.Event()
				}

			case 6:
				{
					p.SetState(1659)
					p.Facade()
				}

			case 7:
				{
					p.SetState(1660)
					p.Mixin()
				}

			case 8:
				{
					p.SetState(1661)
					p.Rest_endpoint()
				}

			case 9:
				{
					p.SetState(1662)
					p.Simple_endpoint()
				}

			case 10:
				{
					p.SetState(1663)
					p.Subscribe()
				}

			case 11:
				{
					p.SetState(1664)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case 12:
				{
					p.SetState(1665)
					p.Union()
				}

			case 13:
				{
					p.SetState(1666)

					var _x = p.View()

					localctx.(*App_declContext)._view = _x
				}
				localctx.(*App_declContext).SetCheck(localctx.(*App_declContext).Get_view().GetAbstractView())

			case 14:
				{
					p.SetState(1669)
					p.Table()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext())
	}
	p.SetState(1676)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1674)

		if !(localctx.(*App_declContext).check) {
			panic(antlr.NewFailedPredicateException(p, "$check", ""))
		}

	case 2:
		{
			p.SetState(1675)
			p.Match(SyslParserDEDENT)
		}

	}

	return localctx
}

// IApplicationContext is an interface to support dynamic dispatch.
type IApplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApplicationContext differentiates from other interfaces.
	IsApplicationContext()
}

type ApplicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApplicationContext() *ApplicationContext {
	var p = new(ApplicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_application
	return p
}

func (*ApplicationContext) IsApplicationContext() {}

func NewApplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApplicationContext {
	var p = new(ApplicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_application

	return p
}

func (s *ApplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *ApplicationContext) Name_with_attribs() IName_with_attribsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_with_attribsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_with_attribsContext)
}

func (s *ApplicationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ApplicationContext) App_decl() IApp_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_declContext)
}

func (s *ApplicationContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *ApplicationContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *ApplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApplication(s)
	}
}

func (s *ApplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApplication(s)
	}
}

func (p *SyslParser) Application() (localctx IApplicationContext) {
	localctx = NewApplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, SyslParserRULE_application)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1681)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(1678)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(1683)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1684)
		p.Name_with_attribs()
	}
	{
		p.SetState(1685)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(1686)
		p.App_decl()
	}

	return localctx
}

// IImport_modeContext is an interface to support dynamic dispatch.
type IImport_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_modeContext differentiates from other interfaces.
	IsImport_modeContext()
}

type Import_modeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_modeContext() *Import_modeContext {
	var p = new(Import_modeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_import_mode
	return p
}

func (*Import_modeContext) IsImport_modeContext() {}

func NewImport_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_modeContext {
	var p = new(Import_modeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_import_mode

	return p
}

func (s *Import_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_modeContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserTILDE, 0)
}

func (s *Import_modeContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Import_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImport_mode(s)
	}
}

func (s *Import_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImport_mode(s)
	}
}

func (p *SyslParser) Import_mode() (localctx IImport_modeContext) {
	localctx = NewImport_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, SyslParserRULE_import_mode)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1688)
		p.Match(SyslParserTILDE)
	}
	{
		p.SetState(1689)
		p.Match(SyslParserName)
	}

	return localctx
}

// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_import_stmt
	return p
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SyslParserIMPORT, 0)
}

func (s *Import_stmtContext) IMPORT_PATH() antlr.TerminalNode {
	return s.GetToken(SyslParserIMPORT_PATH, 0)
}

func (s *Import_stmtContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(SyslParserNEWLINE, 0)
}

func (s *Import_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(SyslParserAS, 0)
}

func (s *Import_stmtContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *Import_stmtContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *Import_stmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWS)
}

func (s *Import_stmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWS, i)
}

func (s *Import_stmtContext) Import_mode() IImport_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_modeContext)
}

func (s *Import_stmtContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *Import_stmtContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *Import_stmtContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDOT)
}

func (s *Import_stmtContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, i)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (p *SyslParser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, SyslParserRULE_import_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1691)
		p.Match(SyslParserIMPORT)
	}
	{
		p.SetState(1692)
		p.Match(SyslParserIMPORT_PATH)
	}
	p.SetState(1702)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserAS {
		{
			p.SetState(1693)
			p.Match(SyslParserAS)
		}
		{
			p.SetState(1694)
			p.Match(SyslParserName)
		}
		p.SetState(1699)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SyslParserDOT {
			{
				p.SetState(1695)
				p.Match(SyslParserDOT)
			}
			{
				p.SetState(1696)
				p.Match(SyslParserName)
			}

			p.SetState(1701)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserWS {
		{
			p.SetState(1704)
			p.Match(SyslParserWS)
		}

		p.SetState(1709)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserTILDE {
		{
			p.SetState(1710)
			p.Import_mode()
		}

	}
	p.SetState(1720)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserIMPORT, SyslParserSYSL_COMMENT, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.SetState(1716)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1713)
					p.Match(SyslParserSYSL_COMMENT)
				}

			}
			p.SetState(1718)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext())
		}

	case SyslParserNEWLINE:
		{
			p.SetState(1719)
			p.Match(SyslParserNEWLINE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImports_declContext is an interface to support dynamic dispatch.
type IImports_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImports_declContext differentiates from other interfaces.
	IsImports_declContext()
}

type Imports_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImports_declContext() *Imports_declContext {
	var p = new(Imports_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_imports_decl
	return p
}

func (*Imports_declContext) IsImports_declContext() {}

func NewImports_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imports_declContext {
	var p = new(Imports_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_imports_decl

	return p
}

func (s *Imports_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Imports_declContext) AllImport_stmt() []IImport_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem())
	var tst = make([]IImport_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_stmtContext)
		}
	}

	return tst
}

func (s *Imports_declContext) Import_stmt(i int) IImport_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Imports_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imports_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imports_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImports_decl(s)
	}
}

func (s *Imports_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImports_decl(s)
	}
}

func (p *SyslParser) Imports_decl() (localctx IImports_declContext) {
	localctx = NewImports_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, SyslParserRULE_imports_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserIMPORT {
		{
			p.SetState(1722)
			p.Import_stmt()
		}

		p.SetState(1725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISysl_fileContext is an interface to support dynamic dispatch.
type ISysl_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSysl_fileContext differentiates from other interfaces.
	IsSysl_fileContext()
}

type Sysl_fileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySysl_fileContext() *Sysl_fileContext {
	var p = new(Sysl_fileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sysl_file
	return p
}

func (*Sysl_fileContext) IsSysl_fileContext() {}

func NewSysl_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sysl_fileContext {
	var p = new(Sysl_fileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sysl_file

	return p
}

func (s *Sysl_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Sysl_fileContext) EOF() antlr.TerminalNode {
	return s.GetToken(SyslParserEOF, 0)
}

func (s *Sysl_fileContext) Imports_decl() IImports_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImports_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImports_declContext)
}

func (s *Sysl_fileContext) AllApplication() []IApplicationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApplicationContext)(nil)).Elem())
	var tst = make([]IApplicationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApplicationContext)
		}
	}

	return tst
}

func (s *Sysl_fileContext) Application(i int) IApplicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApplicationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApplicationContext)
}

func (s *Sysl_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sysl_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sysl_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSysl_file(s)
	}
}

func (s *Sysl_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSysl_file(s)
	}
}

func (p *SyslParser) Sysl_file() (localctx ISysl_fileContext) {
	localctx = NewSysl_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, SyslParserRULE_sysl_file)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserIMPORT {
		{
			p.SetState(1727)
			p.Imports_decl()
		}

	}
	p.SetState(1731)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(SyslParserSYSL_COMMENT-62))|(1<<(SyslParserTEXT_LINE-62))|(1<<(SyslParserName-62)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(1730)
			p.Application()
		}

		p.SetState(1733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1735)
		p.Match(SyslParserEOF)
	}

	return localctx
}

func (p *SyslParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 143:
		var t *Cond_blockContext = nil
		if localctx != nil {
			t = localctx.(*Cond_blockContext)
		}
		return p.Cond_block_Sempred(t, predIndex)

	case 144:
		var t *Final_elseContext = nil
		if localctx != nil {
			t = localctx.(*Final_elseContext)
		}
		return p.Final_else_Sempred(t, predIndex)

	case 157:
		var t *Expr_statementContext = nil
		if localctx != nil {
			t = localctx.(*Expr_statementContext)
		}
		return p.Expr_statement_Sempred(t, predIndex)

	case 174:
		var t *App_declContext = nil
		if localctx != nil {
			t = localctx.(*App_declContext)
		}
		return p.App_decl_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SyslParser) Cond_block_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Final_else_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return localctx.(*Final_elseContext).Get_expr().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Expr_statement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return localctx.(*Expr_statementContext).nested == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) App_decl_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return localctx.(*App_declContext).check

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
