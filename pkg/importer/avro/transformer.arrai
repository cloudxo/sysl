# Extra type enum
let rec extraEnums = \schema
  # TODO enum is inside in an array or map
  cond schema {
    {'type':(s: 'enum'), 'name':(s: name), ...}:
      {schema},
    {'type':(s: 'record'), 'name':(s: name), "fields": (a : fields), ...}:
      //rel.union(fields => extraEnums(.@item("type"))),
    (a: types):
      //rel.union(types >> cond . {{"name": (s: name), ...}:.} => .@item => extraEnums(.))
  }
;

# Extra type record
let rec extraRecords = \schema 
  cond schema {
    {"type": (s: "record"), "name": (s: name), "fields": (a : fields), ...}:
      {schema} | //rel.union(fields => extraRecords(.@item("type"))),
    {'type': (s: 'array'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record array
      {schema('items')} | //rel.union(fields => extraRecords(.@item("type"))),
    {'type': (s: 'map'), 'items': {'type': (s: 'record'), "fields": (a : fields), ...}, ...}: # record map
      {schema('items') | {'isMap': (s: 'true')}} | //rel.union(fields => extraRecords(.@item("type"))),  
    (a: types): 
      //rel.union(types >> cond . {{"name": (s: name), ...}:.} => .@item => extraRecords(.))
};

let avroTransform = \schema \appName \packageName
  # Load Avro spec whose format is protobuf 
  let schema = //encoding.json.decode(//os.file(schema));

$'
##########################################
##                                      ##
##  AUTOGENERATED CODE -- DO NOT EDIT!  ##
##                                      ##
##########################################
${appName}:
  @package="${packageName}"
  # Types
  ${extraRecords(schema) => //{./transformRecordToSysl}(.) orderby . ::\n}
  # Unions

  # Enums
  ${extraEnums(schema) => //{./transformEnumToSysl}(.) orderby . ::}
'
;avroTransform