# Utilities

let getAnnotationS = \item \name
    let annotation = item(name)? .s:"";
    let annotationTxt = cond annotation {"":"", _:name + '="' + annotation + '"'};
    annotationTxt
;

# Pretty annotation array
let prettyAnnotations = \annotationArray
    let str = $`${let a = annotationArray where .@item != ""; a >>> \i \item item::, }`;
    cond str {'':$'', _:$'[${str}]'}
;

# Transform Avro primitive types to Sysl ones
let transformPrimitiveType = \type
    cond type {
        'null': 'null',
        'boolean': 'bool',
        'int': 'int32',
        'long': 'int64',
        'float': 'float32',
        'double': 'float64',
        'bytes': "bytes",
        'string': 'string',
        _: "NotPrimitive"               
    }
;

# Transform Avro complex types to Sysl ones
# TODO load all complex types
let transformComplexType = \type
    cond type {
        'PerformedAction': 'PerformedAction'
    }
;

let buildUnionTypes = \types
    let unionType = '!union ' + //seq.concat(types where .@item != 'null' rank (:.@) >> //str.title(.)) + ' ' + //seq.join(' ')(types);
    unionTypes with unionType
;

# 
let combineTypes = \types
    cond //seq.contains(['null'])(types) {
        true:
            cond //seq.has_prefix(['null'])(types) {
                true: # types is ['null', 'string']
                    cond types count {
                        2: //seq.concat(types where .@item != 'null' rank (:.@)) + '?',
                        _: //seq.concat(types where .@item != 'null' rank (:.@) >> //str.title(.)) + '?'
                    }
                ,
                _: # types is ['string', 'null', ...]
                    cond types count {
                        2: //seq.concat(types where .@item != 'null' rank (:.@)) + '?',
                        _: //seq.concat(types where .@item != 'null' rank (:.@) >> //str.title(.)) + $'?'
                    }
            }
        ,
        _: //seq.concat(types >> //str.title(.))
    }
;

let transformType = \type
    cond type {
        (:s):
            let primitive = transformPrimitiveType(type.s);
            cond primitive {
                'NotPrimitive': transformComplexType(type.s), 
                _: cond primitive {
                    "null": "string[~null]",
                    _: primitive
                }
            },
        (:a):
            combineTypes(type.a >> .s), # [(s: 'null'), (s: 'string')] to ['null', 'string']
        _:
            # it is array, map or fixed
            cond type('type').s {
                'array': 'sequence of ' + type('items').s,
                'map': 'sequence of ',
                'fixed': 'fixed',
                _: "NONE" 
            },
    }
;

let util = (
    : prettyAnnotations,
    : transformType,
    : getAnnotationS,
);
util